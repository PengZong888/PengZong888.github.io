<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    
    青稞
  </title>
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="青稞" type="application/atom+xml">
</head>

<body>
  <main class="content">
    <section class="jumbotron">
  <div class="video">
    
    <div class="video-frame">
      <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
    </div>
    
    <div class="video-media">
      <video playsinline="" autoplay="" loop="" muted="" data-autoplay="" poster="/images/ocean/ocean.png"
        x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">青稞</a></h1>
      <p></p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="青稞"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>
<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>
    
    
    <article id="post-文件共享与保护" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2021/12/31/%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4/">文件共享与保护</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/12/31/%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4/" class="article-date">
  <time datetime="2021-12-31T14:24:56.000Z" itemprop="datePublished">2021-12-31</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
      <h1 id="1-文件共享"><a href="#1-文件共享" class="headerlink" title="1. 文件共享"></a>1. 文件共享</h1><p>文件共享使多个用户（进程）共享同一个文件，系统中只需保留该文件的一个副本。随着计算机技术的发展，文件共享的范围已由单机系统发展到多机系统，进而通过网络扩展到全球。这些文件的共享是通过分布式文件系统、远程文件系统、分布式信息系统实现的。这些系统运行多个客户通过C/S模型共享网络中的服务器文件。</p>
<p>现代常用的两种文件共享方法如下：</p>
<h2 id="1-1-基于索引结点的共享方式（硬链接）"><a href="#1-1-基于索引结点的共享方式（硬链接）" class="headerlink" title="1.1 基于索引结点的共享方式（硬链接）"></a>1.1 基于索引结点的共享方式（硬链接）</h2><p>在树形结构的目录中，当有两个或多个用户要共享一个子目录或文件时，必须将共享文件或子目录链接到两个或多个用户的目录中，才能方便地找到该文件，如图所示：</p>
<p><img src="C:/Users/pengbin007/AppData/Roaming/Typora/typora-user-images/image-20220101194616578.png" alt="image-20220101194616578"></p>
<p>在这种共享方式中，诸如文件的物理地址及其他的文件属性等信息，不再放到目录项中，而放在索引结点中。在文件目录中只设置文件名及指向相应索引结点的指针。在索引结点中还应有一个链接计数count，用于表示链接到本索引结点上的用户目录项的数目。</p>
<p>用户A创建一个新文件时，将count置为1。如果此时用户B要共享此文件，则在B的目录中增加一个目录项，并设置一个指针指向该文件的索引结点，此时count = 2。如果A不再使用该文件，A不能删除该文件，因为删除该文件意味着索引结点也被删除了，那么B的指针指向将会失效。因此A只能将count减1，然后删除自己目录中的相应目录项。当count = 0时，表示没有用户使用该文件，系统将负责删除该文件。如图给出了B链接到文件上的前、后情况。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220101194906651.png" alt="image-20220101194906651"></p>
<h2 id="1-2-利用符号链实现文件共享（软链接）"><a href="#1-2-利用符号链实现文件共享（软链接）" class="headerlink" title="1.2 利用符号链实现文件共享（软链接）"></a>1.2 利用符号链实现文件共享（软链接）</h2><p>为使用户B能共享用户A的一个文件F，可以由系统创建一个LINK类型的新文件，也取名为F，并将文件F写入用户B的目录中，以实现用户B的目录与文件F的链接。在新文件中只包含被链接文件F的路径名。这样的链接方法称为<strong>符号链接</strong>。</p>
<p>新文件中的路径名只被视为符号链，当用户B要访问被链接的文件F且正要读LINK类新文件时，OS根据新文件中的路径名去读该文件，从而实现用户B的文件F的共享。</p>
<p>在利用符号链方式实现文件共享时，只有文件的拥有者才拥有指向其索引结点的指针。而共享该文件的其它用户只有该文件的路径名。这样，就不会发生文件主删除文件后，指针悬空的情况。此时，文件删除后，其它用户通过符号链访问它，会出现访问失败，于是将符号链删除，不会产生任何影响。但是，利用符号链依旧存在一个问题：当文件拥有者删除文件后，在其它用户使用符号链访问该文件之前，又有人在同一路径下创建了另一个同名的文件，则该符号链依旧有效，但访问的路径已经改变，从而导致错误。</p>
<p>在符号链的共享方式中，当其它用户读共享文件时，需要根据文件路径名逐个查找目录，直至找到该文件的索引结点。因此，每次访问时，都可能需要多次读盘，使得访问文件的开销变大且增加了启动磁盘的频率。此外，符号链的索引结点也要耗费一定的存储空间。</p>
<p>符号链有一个很大的优点：网络共享只需提供该文件所在机器的网络地址及该机器中的文件路径。</p>
<p>上述两种链接方式都存在一个共同的问题，即每个共享文件都有几个文件名。换言之，每增加一条连接，就增加一个文件名。这实质上是每个用户都使用自己的路径区访问共享文件。当我们试图去遍历整个文件系统时，将会多次遍历到该共享文件。</p>
<p>硬链接和软链接都是文件系统中的静态共享方法，在文件系统中还存在着另外的共享需求u，即两个进程同时对同一个文件进行操作，这样的共享称为动态共享。</p>
<p>可以这样说：文件共享，“软”“硬”兼施。硬链接就是多个指针指向同一个索引结点，保证只要还有一个指针指向索引结点，索引结点就不能删除；软链接就是把到达共享文件的路径记录下来，当要访问文件时，根据路径寻找文件，可以想象，硬链接的查找速度要比软链接块。</p>
<h1 id="2-文件保护"><a href="#2-文件保护" class="headerlink" title="2. 文件保护"></a>2. 文件保护</h1><p>为了防止文件共享可能会导致文件被破坏或未经核准的用户修改文件，文件系统必须控制用户对文件的存取，即解决对文件的读、写、执行的许可问题。为此，必须在文件系统中建立相应的文件保护机制。</p>
<p>文件保护通过口令保护、加密保护和访问控制等方式实现。其中，口令保护和加密保护是为了防止用户文件被他人窃取，而访问控制则用于控制用户对文件的访问方式。</p>
<h2 id="2-1-访问类型"><a href="#2-1-访问类型" class="headerlink" title="2.1 访问类型"></a>2.1 访问类型</h2><p>可加以控制的访问类型主要有以下几种：</p>
<ul>
<li>读。从文件中读。</li>
<li>写。向文件中写。</li>
<li>执行。将文件装入内存并执行。</li>
<li>添加。将新信息添加到文件结尾部分。</li>
<li>删除。删除文件，释放空间。</li>
<li>列表清单。列出文件名和文件属性。</li>
</ul>
<p>此外还可以对文件的重命名、复制、编辑等加以控制。这些高层的功能可以通过系统调用底层系统调用来实现。保护可以只在底层提供。</p>
<h2 id="2-2-访问控制"><a href="#2-2-访问控制" class="headerlink" title="2.2 访问控制"></a>2.2 访问控制</h2><p>解决访问控制最常用的方法是根据用户身份进行控制。而实现基于身份访问的最为普通的方法是，为每个文件和目录增加一个访问控制列表（Access-Control List，ACL），以规定每个用户名及其所允许的访问类型。</p>
<p>这种方法的优点是可以使用复杂的访问方法，缺点是长度无法预计并且可能导致复杂的空间管理，使用精简的访问列表可以解决这个问题。</p>
<p>精简的访问列表采用拥有者、组和其它三种用户类型。这样，只需用三个域即可列出访问表中这三类用户的访问权限。文件拥有者在创建文件时，说明创建者用户名及所在的组名，系统在创建文件时也将文件主的名字、所属组名列在该文件的FCB中。</p>
<p>口令和密码是另外两种访问控制方法。</p>
<p><strong>口令</strong>是指用户在建立一个文件时提供一个口令，系统为其建立FCB时附上相应口令，同时告诉允许共享该文件的其它用户。用户请求访问时必须提供相应的口令。这种方法时间和空间的开销不多，缺点是口令直接存在系统内部，不够安全。</p>
<p><strong>密码</strong>是指用户对文件进行加密，文件被访问时需要使用密钥。这种方法保密性强，节省了存储空间，不过编码和译码要花费一定的时间。</p>
<p>口令和密码都是防止用户文件被他人窃取，并没有控制用户对文件的访问类型。</p>
<p>注意两个问题：</p>
<ol>
<li>现代OS常用的文件保护方法是，将访问控制列表与用户、组和其它成员访问控制方案一起组合使用。</li>
<li>对于多级目录结构而言，不仅需要保护单个文件，而且需要保护子目录内的文件，即需要提供目录保护机制。目录操作与文件操作并不相同，因此需要不同的保护机制。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/31/%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4/" data-id="ckzb6dz44001szwtw3atx5i9s" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-文件实现——文件存储空间管理" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2021/12/31/%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/">文件实现——文件存储空间管理</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/12/31/%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/" class="article-date">
  <time datetime="2021-12-31T07:26:47.000Z" itemprop="datePublished">2021-12-31</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
      <h1 id="1-文件存储器空间的划分与初始化"><a href="#1-文件存储器空间的划分与初始化" class="headerlink" title="1. 文件存储器空间的划分与初始化"></a>1. 文件存储器空间的划分与初始化</h1><p>一般来说，一个文件存储在一个文件卷中。文件卷可以是物理盘的一部分，也可以是整个物理盘，支持超大型文件的文件卷也可由多个物理盘组成，如图所示。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211231220016669.png" alt="image-20211231220016669"></p>
<p>在一个文件卷中，文件数据信息的空间（文件区）和存放文件控制信息FCB的空间（目录区）是分离的。由于存在许多种类的文件表示和存放格式，所以现代OS中一般都有很多不同的文件管理模块，通过它们可以访问不同格式的逻辑卷中的文件。逻辑卷在提供文件服务前，必须由对应的文件程序进行初始化，划分好目录区和文件区，建立空闲空间管理表格及存放逻辑卷信息的超级块。</p>
<h1 id="2-文件存储器空间管理"><a href="#2-文件存储器空间管理" class="headerlink" title="2. 文件存储器空间管理"></a>2. 文件存储器空间管理</h1><p>文件存储设备分成许多大小相同的物理块，并以快为单位交换信息，因此，文件存储设备的管理实质上是对空闲块的组织和管理，它包括空闲块的组织、分配与回收等问题。</p>
<h2 id="2-1-空闲表法"><a href="#2-1-空闲表法" class="headerlink" title="2.1 空闲表法"></a>2.1 空闲表法</h2><p>空闲表法属于连续分配方式，它与内存的动态分配方式类似，为每个文件分配一块连续的存储空间。系统为外存上的所有空闲区建立一张空闲盘块表。空闲盘区的分配与内存的动态分配类似，同样采用首次适应算法、循环首次适应算法等。系统在对用户所释放的存储空间进行回收时，也采取类似于内存回收的方法，即要考虑回收区是否与空闲表中插入点的前区和后区相邻接，对相邻接者应予以合并。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211231220201168.png" alt="image-20211231220201168"></p>
<h2 id="2-2-空闲链表法"><a href="#2-2-空闲链表法" class="headerlink" title="2.2 空闲链表法"></a>2.2 空闲链表法</h2><p>根据构成链所用的基本元素不同，可把链表分成两种形式：空闲盘块链和空闲盘区链。</p>
<p>空闲盘块链将磁盘上的所有空闲空间以盘块为单位拉成一条链。这种方法的优点是分配和回收一个盘块的过程非常简单，但在为一个文件分配盘块时可能要重复多次操作。</p>
<p>空闲盘区链将磁盘上的所有空闲盘区（每个盘区可包含若干盘块）拉成一条链。在每个盘区上除含有用于指示下一个空闲盘区的指针外，还应有能指明本盘区大小（盘块数）的信息。分配的方法与动态分区分配类似，通常采用首次适应算法。在回收盘区时，同样也要将回收区与相邻接的空闲盘区合并。</p>
<h2 id="2-3-位示图法"><a href="#2-3-位示图法" class="headerlink" title="2.3 位示图法"></a>2.3 位示图法</h2><p>位示图利用二进制的一位来表示磁盘中的一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。当其值为“0”时，表示对应的盘块空闲；当其值为“1”时，表示对应的盘块已分配，如图：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211231220915119.png" alt="image-20211231220915119"></p>
<p>盘块的分配：</p>
<ol>
<li>顺序扫描位示图，从中找出一个或一组其值为“0”的二进制位。</li>
<li>将找到的一个或一组二进制位，转换成与之对应的盘块号。若找到的其值位“0”的二进制位位于位示图的第i行、第j列，则其相应的盘块号应按下式计算（n代表每行的位数）：b = n * (i  - 1) + j </li>
<li>修改位示图，令map[i, j] = 1</li>
</ol>
<p>盘块的回收：</p>
<ol>
<li>将回收盘块的盘块号转换成位示图中的行号和列号。转换公式为：i = (b - 1) DIV n + 1;    j = (b - 1) MOD n + 1</li>
<li>修改位示图，令map[i, j] = 0</li>
</ol>
<h2 id="2-4-成组链接法"><a href="#2-4-成组链接法" class="headerlink" title="2.4 成组链接法"></a>2.4 成组链接法</h2><p>空闲表法和空闲链表法都不适用于大型文件系统，因为这会使空闲表或空闲链表太大。在UNIX系统中采用的是成组链接法，这种方法结合了这两种方法，克服了表太大的缺点。其大致思想是：把顺序的n个空闲扇区地址保存在第一个空闲扇区内，其最后一个空闲扇区内则保存另一组顺序空闲扇区的地址，如此继续，直至所有空闲扇区均予以链接。系统只需要保存一个指向第一个空闲扇区的指针。假设磁盘最初全为空闲扇区，其成组链接如图所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211231221706964.png" alt="image-20211231221706964"></p>
<p>通过这种方式可以迅速找到大批空闲块地址。</p>
<p>表示文件存储器空闲空间的“位向量”表或第一个成组链块，以及卷中的目录区、文件区划分信息都需要存放在辅存储器中，一般放在卷头位置，在UNIX系统中称为<strong>超级块</strong>。在对卷中的文件进行操作前，超级块需要预先读入系统空闲的主存，并且经常保持主存超级块与辅存卷中超级块的一致性。</p>
<blockquote>
<p>在这里，我们使用的位示图法中行和列都是从1开始编号。特别注意，若题目指明从0开始编号，则上述计算方法要进行相应调整。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/31/%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/" data-id="ckzb6dz44001tzwtw1ls74kel" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-文件实现——文件分配方式" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2021/12/31/%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F/">文件实现——文件分配方式</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/12/31/%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F/" class="article-date">
  <time datetime="2021-12-31T07:26:27.000Z" itemprop="datePublished">2021-12-31</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
      <p>文件的实现其实就是研究文件的物理结构，即文件数据在物理存储设备上是如何分布和组织的。而文件的实现又分为两个方面：一是文件的分配方式，也就是对磁盘非空闲块的管理；二是文件存储空间管理，对磁盘空闲块的管理。</p>
<p>常用的磁盘空间分配有三种：连续分配、链接分配和索引分配。</p>
<h1 id="1-连续分配"><a href="#1-连续分配" class="headerlink" title="1. 连续分配"></a>1. 连续分配</h1><p>连续分配方法要求每个文件在磁盘上占有一组连续的块，如图所示，。磁盘地址定义了磁盘上的一个线性排序。这种排序使作业访问磁盘时需要的寻道数和寻道时间最小。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211231203004646.png" alt="image-20211231203004646"></p>
<p>文件的连续分配可以用第一块的磁盘地址和连续块的数量来定义。一个文件的目录条目包括开始块的地址和该文件所分配区域的长度。</p>
<p>连续分配支持顺序访问和直接访问。其优点是实现简单、存取速度快。</p>
<p>缺点是文件长度不易动态增加，因为一个文件末尾后的盘块可能已分配给其它文件，一旦需要增减，就需要大量移动盘块。此外，反复增删文件后会产生外部碎片，且很难确定一个文件需要的空间大小，因而只适用于长度固定的文件。</p>
<h1 id="2-链接分配"><a href="#2-链接分配" class="headerlink" title="2. 链接分配"></a>2. 链接分配</h1><p>链接分配采取离散分配的方式，消除了外部碎片，因此显著提高了磁盘空间的利用率；而且，当文件动态增长时，也能动态地再为它分配盘块。此外，对文件的增、删、改也非常方便。链接分配又分为隐式链接和显式链接。</p>
<h2 id="2-1-隐式链接"><a href="#2-1-隐式链接" class="headerlink" title="2.1 隐式链接"></a>2.1 隐式链接</h2><p>如图，每个文件对应一个磁盘块的链表；磁盘块分布在磁盘的任何地方，出最后一个磁盘块外，每个盘块都有指向下一个盘块的指针，这些指针对用户是透明的。目录包括文件的第一块指针和最后一块的指针。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211231203637822.png" alt="image-20211231203637822"></p>
<p>创建新文件时，目录中增加一个新条目。每个目录项都由一个指向文件首块的指针。该指针初始化为NULL以表示空文件，大小字段为0.写文件会通过空闲空间管理系统找到空闲块，将该块链接到文件的尾部，以便写入。该文件则通过块到块的指针顺序读块。</p>
<p>隐式链接分配的缺点是无法直接访问磁盘块，且盘块指针会消耗一定的存储空间。而且它的稳定性也是一个问题，系统在运行过程中由于软件或硬件错误导致链表中的指针丢失或损坏，会导致文件数据的丢失。</p>
<h2 id="2-2-显式链接"><a href="#2-2-显式链接" class="headerlink" title="2.2 显式链接"></a>2.2 显式链接</h2><p>显式链接是指把用于链接文件各物理块的指针，从每个物理块的块末尾中提取出来，显式地存放在内存的一张链表中。该表在整个磁盘中仅设置一张，称为<strong>文件分配表（File Allocation Table，FAT）</strong>。每个表项中存放对应块的下一块链接指针，即下一个盘块号。文件的第一个盘块号记录在目录中。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211231204343174.png" alt="image-20211231204343174"></p>
<p>如图，在这里我们用-1表示文件的最后一块，用-2表示这个磁盘块空闲。因此，FAT不仅记录了文件各块之间的先后链接关系，同时还标记了空闲的磁盘块，OS也可以通过FAT对文件存储空间进行管理。</p>
<p>FAT表在系统启动时就会被读入内存，因此查找FAT的过程是在内存中进行的，因此不仅显著地提高了检索速度，而且明显减少了访问磁盘的次数。</p>
<h1 id="3-索引分配"><a href="#3-索引分配" class="headerlink" title="3. 索引分配"></a>3. 索引分配</h1><p>链接分配虽然解决了连续分配的外部碎片和文件大小管理的问题，但是，链接分配不能有效支持直接访问（FAT除外）。索引分配则解决了这个问题，它把每个文件的所有的盘块号都集中放在一起构成<strong>索引块（表）</strong>，如图所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211231205558889.png" alt="image-20211231205558889"></p>
<p>每个文件都有其索引块，这是一个磁盘块地址的数组。索引块的第i个条目指向文件的第i个块。目录条目包括索引块的地址。</p>
<p>创建文件时，索引块的所有指针都设为空。首次写入第i块时，先从空闲空间中取得一个块，在将其地址写到索引块的第i个条目。索引分配支持直接访问，且没有外部碎片。其缺点是由于索引块的分配，增加了系统存储空间的开销。</p>
<p>索引块的大小是一个重要的问题，每个文件必须有一个索引块，因此索引块应尽可能小，但索引块太小就无法支持大文件。可以采用以下机制来处理这个问题。</p>
<ul>
<li><strong>链接方案</strong>。一个索引块通常为一个磁盘块，因此它本身能直接读写。为了处理大文件，可以将多个索引块链接起来。</li>
<li><strong>多层索引</strong>。多层索引使第一层索引块指向第二层的索引块，第二层索引块再指向文件块。这种方法根据最大文件大小的要求，可以继续到第三次或第四层。</li>
<li><strong>混合索引</strong>。将多种索引分配方式相结合的分配方式。例如，系统既采用直接地址，又采用单级索引分配方式和多级索引分配方式。</li>
</ul>
<h1 id="4-三种分配方式的比较"><a href="#4-三种分配方式的比较" class="headerlink" title="4. 三种分配方式的比较"></a>4. 三种分配方式的比较</h1><table>
<thead>
<tr>
<th></th>
<th>访问第n条记录</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>连续分配</td>
<td>需访问磁盘1次</td>
<td>顺序存储时速度快，文件定长时可根据文件起始地址及记录长度进行随机访问</td>
<td>文件存储要求连续的存储空间，会产生碎片，不利于文件的动态扩充</td>
</tr>
<tr>
<td>链接分配</td>
<td>需访问磁盘n次</td>
<td>可解决外存的碎片问题，提高外存空间的利用率，动态增长较方便</td>
<td>只能按照文件的指针链顺序访问，查找效率低，指针信息存放消耗外存空间</td>
</tr>
<tr>
<td>索引分配</td>
<td>m级需访问磁盘m + 1次</td>
<td>可以随机访问，文件易于增删</td>
<td>索引表增加存储空间的开销，索引表的查找策略对文件系统效率影响较大</td>
</tr>
</tbody></table>
<p>此外，访问文件需要两次访问外存——首先要读取索引块的内容，然后访问具体的磁盘块，因而降低了文件的存取速度。为解决这一问题，通常将文件的索引块读入内存的缓冲区中，以加快文件的访问速度。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/31/%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F/" data-id="ckzb6dz46001vzwtw2cas009l" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-经典IPC问题" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2021/12/30/%E7%BB%8F%E5%85%B8IPC%E9%97%AE%E9%A2%98/">经典IPC问题</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/12/30/%E7%BB%8F%E5%85%B8IPC%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2021-12-30T08:07:21.000Z" itemprop="datePublished">2021-12-30</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
      <blockquote>
<ul>
<li>前P后V</li>
<li>互斥信号量初值一般为1</li>
<li>同步信号量初值一般为0</li>
</ul>
</blockquote>
<h1 id="1-生产者-消费者问题"><a href="#1-生产者-消费者问题" class="headerlink" title="1. 生产者-消费者问题"></a>1. 生产者-消费者问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>一组生产者进程和一组消费者进程共享一个初始为空、大小为n的缓冲区，只有缓冲区没满时，生产者才能把消息放入缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或一个消费者从中取出消息。</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="关系分析"><a href="#关系分析" class="headerlink" title="关系分析"></a>关系分析</h3><p>生产者和消费者对缓冲区的访问具有互斥关系，同时生产者和消费者又是相互协作的同步关系。</p>
<h3 id="整理思路"><a href="#整理思路" class="headerlink" title="整理思路"></a>整理思路</h3><p>这里有生产者和消费者两个进程，两个进程既是同步又是互斥，我们只要设置好PV操作的位置即可</p>
<h3 id="信号量设置"><a href="#信号量设置" class="headerlink" title="信号量设置"></a>信号量设置</h3><p>信号量mutex作为互斥信号量，用于控制互斥访问缓冲池，初值为1；信号量full用于记录当前“满”缓冲区数，初值为0；信号量empty用于记录空闲缓冲区，初值为n。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;	<span class="comment">// 临界区互斥信号量</span></span><br><span class="line">semaphore empty = n;	<span class="comment">// 空闲缓冲区</span></span><br><span class="line">semaphore full = <span class="number">0</span>;		<span class="comment">// 缓冲区初始化为空</span></span><br><span class="line">producer() &#123;	<span class="comment">// 生产者进程</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        produce an item in nextp;	<span class="comment">// 生产者生产好产品，将要将产品放入缓冲区</span></span><br><span class="line">        P(empty);				<span class="comment">// 生产者进程将要对空闲缓冲区操作，空闲缓冲区数量减少</span></span><br><span class="line">        P(mutex);				<span class="comment">// 互斥信号量“夹紧”临界区</span></span><br><span class="line">        add nextp to buffer;	<span class="comment">// 临界区，缓冲区为临界资源</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);				<span class="comment">// 生产者进程结束对空闲缓冲区的操作，“满”缓冲区数量增加</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">consumer() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(full);		<span class="comment">// 消费者要对“满”缓冲区操作，“满”缓冲区数量减少</span></span><br><span class="line">        P(mutex);		<span class="comment">// 互斥夹紧</span></span><br><span class="line">        remove an item from buffer; 	<span class="comment">// 临界区</span></span><br><span class="line">        V(mutex);		</span><br><span class="line">        V(empty);		<span class="comment">// 消费者结束对“满”缓冲区操作，空闲缓冲区增加</span></span><br><span class="line">        consumer the item;		<span class="comment">// 剩余区，消费者消费进程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-多生产者-消费者问题"><a href="#2-多生产者-消费者问题" class="headerlink" title="2.多生产者-消费者问题"></a>2.多生产者-消费者问题</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>桌子上有一个盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈放橘子，儿子专等吃盘子中的橘子，女儿吃苹果。只有盘子为空时，爸爸或妈妈才可向盘子中放一个水果；仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出。</p>
<h2 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="关系分析-1"><a href="#关系分析-1" class="headerlink" title="关系分析"></a>关系分析</h3><p>爸爸和妈妈对盘子的访问是互斥操作；爸爸和女儿对苹果的操作是同步关系；妈妈和儿子对橘子的操作是同步关系；儿子和女儿之间没有同步互斥关系。</p>
<h3 id="整理思路-1"><a href="#整理思路-1" class="headerlink" title="整理思路"></a>整理思路</h3><p>这里有爸爸、妈妈、儿子、女儿四个进程，实际上可以抽象成两个生产者进程和两个消费者进程对一个大小为1的缓冲区的进行操作。</p>
<h3 id="信号量设置-1"><a href="#信号量设置-1" class="headerlink" title="信号量设置"></a>信号量设置</h3><p>信号量plate为互斥信号量；apple用于实现爸爸和女儿的同步关系，初值为0表示盘子为空，1表示盘子中有苹果可以取；同步信号量orange同理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">semaphore plate = <span class="number">1</span>;	<span class="comment">// 互斥信号量</span></span><br><span class="line">semaphore apple = <span class="number">0</span>;	<span class="comment">// 对苹果操作的同步</span></span><br><span class="line">semaphore orange = <span class="number">0</span>;	<span class="comment">// 对橘子操作的同步</span></span><br><span class="line">dad() &#123;		<span class="comment">// 父亲进程</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        prepare an apple;	<span class="comment">// 父亲准备好一个苹果，将要放入盘子中</span></span><br><span class="line">        P(plate);	<span class="comment">// 父亲要对盘子操作，此时如果盘子空闲，则会继续往下执行；否则进入等待序列，等待女儿的解锁</span></span><br><span class="line">        put the apple on the plate;		<span class="comment">// 临界区</span></span><br><span class="line">        V(apple);	<span class="comment">// 盘子中现在有苹果，修改苹果的同步信号量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">mom() &#123;		<span class="comment">// 母亲进程</span></span><br><span class="line">   	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        prepare an orange;	<span class="comment">// 母亲准备好一个橘子，将要放入盘子中</span></span><br><span class="line">        P(plate);	<span class="comment">// 母亲要对盘子操作，此时如果盘子空闲，则会继续往下执行；否则进入等待序列，等待儿子的解锁</span></span><br><span class="line">        put the orange on the plate;	<span class="comment">// 临界区</span></span><br><span class="line">        V(orange);	<span class="comment">// 盘子中现在有橘子，修改橘子的同步信号量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">son() &#123;		<span class="comment">// 儿子进程</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(orange);	<span class="comment">// 儿子要对盘子中的橘子操作，此时如果盘子中有橘子，则会继续往下执行；否则儿子进入等待序列，等待母亲生产橘子</span></span><br><span class="line">        take an orange from plate;	<span class="comment">// 临界区</span></span><br><span class="line">        V(plate);	<span class="comment">// 儿子拿到橘子，此时盘子中没有苹果也没有橘子，因此释放盘子资源，让父亲和母亲可以继续对盘子进行操作</span></span><br><span class="line">        eat the orange;	<span class="comment">// 剩余区，儿子吃橘子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">daughter() &#123;	<span class="comment">// 女儿进程</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(apple);	<span class="comment">// 女儿要对盘子中的苹果操作，此时如果盘子中有苹果，则会继续往下执行；否则女儿进入等待序列，等待父亲生产苹果</span></span><br><span class="line">        take an apple from plate;	<span class="comment">// 临界区</span></span><br><span class="line">        V(plate);	<span class="comment">// 女儿拿到苹果，此时盘子中没有苹果也没有橘子，因此释放盘子资源，让父亲和母亲可以继续对盘子进行操作</span></span><br><span class="line">        eat the apple;	<span class="comment">// 剩余区，女儿吃苹果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，dad()执行完之后一定是daughter()，mom()执行完之后一定是son()，也正是因为这样，只有在儿子拿走橘子或者女儿拿走苹果之后才能释放盘子，即执行V(plate)操作。</p>
<h1 id="3-读者-写者问题"><a href="#3-读者-写者问题" class="headerlink" title="3. 读者-写者问题"></a>3. 读者-写者问题</h1><h2 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h2><p>有读者和写者两组并发进程，共享一个文件，当两个或以上的读进程同时访问共享数据不会产生副作用，但若某个写进程和其它进程同时访问共享数据可能导致数据不一致的错误。因此要求：</p>
<p>① 允许多个读者可以同时对文件执行读操作；</p>
<p>② 允许一个写者往文件中写信息；</p>
<p>③ 任意写者在完成写操作之前不允许其它读者或写者工作；</p>
<p>④ 写者执行写操作前，应让已有的读者和写者全部退出。</p>
<h2 id="问题分析-2"><a href="#问题分析-2" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="关系分析-2"><a href="#关系分析-2" class="headerlink" title="关系分析"></a>关系分析</h3><p>由题目分析可知：读者和写者是互斥的、写者和写者也是互斥的，而读者和读者之间不存在互斥问题，可以并发访问。</p>
<h3 id="整理思路-2"><a href="#整理思路-2" class="headerlink" title="整理思路"></a>整理思路</h3><p>在这里，写者的操作比较简单，它与任何操作都互斥。而读者的问题比较复杂，它必须在实现与写者的互斥同时，又实现与其它读者同步。因此，如果我们只是简单的设置一对PV操作，是无法解决问题的。我们可以设置一个计数器，用它来判断当前是否有读者读文件。当有读者时，写者是无法写文件的，此时读者会一直占用文件这个临界资源，只有当没有读者时，写者才可以操作文件。同时，这里不同读者对计数器的访问也是互斥的。（注意是对计数器的访问，而不是不同读者对文件的访问）。</p>
<h3 id="信号量设置-2"><a href="#信号量设置-2" class="headerlink" title="信号量设置"></a>信号量设置</h3><p>首先设置信号量count为计数器，初值为0.设置mutex为互斥信号量，用于保护更新count变量时的互斥，初值为1；设置rw为互斥信号量，用于保证读者和写者的互斥访问，初值为1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readCount = <span class="number">0</span>;		<span class="comment">// 计数器</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;	<span class="comment">// 对计数器操作的互斥信号量</span></span><br><span class="line">semaphore rw = <span class="number">1</span>;		<span class="comment">// 对文件操作的互斥信号量</span></span><br><span class="line">writer() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(rw);		<span class="comment">// 写者将要对文件进行操作，如果读者没有访问文件，继续往下执行；否则，进入等待序列</span></span><br><span class="line">        writing;	<span class="comment">// 写文件</span></span><br><span class="line">        V(rw);		<span class="comment">// 写者结束对文件的操作，将文件资源释放，以便让读者或其它写者访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">reader() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(mutex);	<span class="comment">// 新的读者进程到来，因此要对计数器加一，如果此时没有另外的读者正在对readCount操作，继续往下执行；否则，进入等待序列</span></span><br><span class="line">        <span class="keyword">if</span> (readCount == <span class="number">0</span>)	<span class="comment">// 如果是第一个读者，说明文件资源并没有被锁住，因此要先锁定文件资源，再进行接下来的操作</span></span><br><span class="line">            P(rw);			<span class="comment">// 如果不是第一个读者，说明文件资源已经被锁定了，那么也就无须再进行锁定文件操作了</span></span><br><span class="line">        readCount++;	<span class="comment">// 读者数量加一</span></span><br><span class="line">        V(mutex);	<span class="comment">// 释放readCount</span></span><br><span class="line">        reading;	<span class="comment">// 读文件</span></span><br><span class="line">        P(mutex);	<span class="comment">// 读者进程将要结束，要对readCount进行减一操作，锁定readCount</span></span><br><span class="line">        readCount--;	<span class="comment">// 读者数量减一</span></span><br><span class="line">        <span class="keyword">if</span> (readCount == <span class="number">0</span>)		<span class="comment">// 读者数量减一之后，readCount等于0，说明已经没有读者了，就要释放读者对文件的锁定</span></span><br><span class="line">            V(rw);				<span class="comment">// 如果不等于0，说明此时还有读者在进行对文件的访问，因此也就不能释放对文件的锁定了</span></span><br><span class="line">        V(mutex);	<span class="comment">// 释放readCount</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是读进程优先的算法，即当存在读进程时，写操作都将被延迟，且只要有一个读进程活跃，那么随之而来的读进程都被允许访问文件，这样的方式可能会导致写进程长时间等待，甚至可能出现“写进程饿死”的情况。</p>
<p>如果我们希望写优先，即当有读进程在访问文件时，此时有写进程请求访问，这时我们应该禁止后续读进程的请求，等到已经在运行的读进程执行完毕，立即让写进程执行，只有在没有写进程执行的情况下才允许读进程再次运行。因此，我们需要再增加一个信号量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readCount = <span class="number">0</span>;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore rw = <span class="number">1</span>;</span><br><span class="line">semaphore w = <span class="number">1</span>;	<span class="comment">// 用于实现写优先</span></span><br><span class="line">writer() &#123;</span><br><span class="line">    P(w);		<span class="comment">// 没有写进程，锁定</span></span><br><span class="line">    P(rw);</span><br><span class="line">    writing;</span><br><span class="line">    V(rw);</span><br><span class="line">    V(w);		<span class="comment">// 写进程结束访问</span></span><br><span class="line">&#125;</span><br><span class="line">reader() &#123;</span><br><span class="line">    P(w);		<span class="comment">// 没有写进程，锁定</span></span><br><span class="line">    P(mutex);</span><br><span class="line">    <span class="keyword">if</span> (readCount == <span class="number">0</span>)</span><br><span class="line">        P(rw);</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(w);		<span class="comment">// 恢复对文件的访问</span></span><br><span class="line">    reading;</span><br><span class="line">    P(mutex);</span><br><span class="line">    <span class="keyword">if</span>	(readCount == <span class="number">0</span>)</span><br><span class="line">        V(rw);</span><br><span class="line">    V(mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的写进程优先是相对上一种算法而言的，有些书上把这个称为“读写公平法”。因为如果读进程释放了w，系统会选择优先进行申请对文件操作的进程（根据等待序列的顺序来执行）。所以如果是读进程比写进程先申请对文件的访问，那么仍然会先执行读进程，再执行写进程。</p>
<h1 id="4-哲学家进餐问题"><a href="#4-哲学家进餐问题" class="headerlink" title="4. 哲学家进餐问题"></a>4. 哲学家进餐问题</h1><h2 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h2><p>一张圆桌边上坐着5名哲学家，每两名哲学家之间的桌上摆一根筷子，两个筷子中间是一碗米饭。哲学家们倾注毕生精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。若筷子已在他人手上，则需要等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，进餐完毕后，放下筷子继续思考。</p>
<h2 id="问题分析-3"><a href="#问题分析-3" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="关系分析-3"><a href="#关系分析-3" class="headerlink" title="关系分析"></a>关系分析</h3><p>5名哲学家与左右邻居对其中间筷子的访问是互斥关系。</p>
<h3 id="整理思路-3"><a href="#整理思路-3" class="headerlink" title="整理思路"></a>整理思路</h3><p>显然，这里有5个进程。我们要解决问题的关键在于：如何让一名哲学家拿到左右两根筷子而不造成死锁或饥饿现象。解决方法有两个：</p>
<ul>
<li>让他同时拿到两根筷子；</li>
<li>对每个哲学家的动作制定规则，避免死锁或饥饿。</li>
</ul>
<h3 id="信号量设置-3"><a href="#信号量设置-3" class="headerlink" title="信号量设置"></a>信号量设置</h3><p>定义互斥信号量数组chopstick[5] = {1, 1, 1, 1, 1}，用于对5根筷子的互斥访问。哲学家按顺序编号为0 ~ 4，哲学家i左边筷子的编号为i，右边筷子编号为(i + 1) % 5。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">Pi() &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        P(chopstick[i]);			<span class="comment">// 取左边筷子</span></span><br><span class="line">        P(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);	<span class="comment">// 取右边筷子</span></span><br><span class="line">        eat;						<span class="comment">// 临界区</span></span><br><span class="line">        V(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);	<span class="comment">// 放右边筷子</span></span><br><span class="line">        V(chopstick[i]);			<span class="comment">// 放左边筷子</span></span><br><span class="line">        think;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个算法存在的问题是：当5名哲学家都想要进餐并都拿起了左边的筷子时，筷子已经被拿光，等到他们再想拿右边的筷子时，就全被阻塞，出现了死锁。</p>
<p>为了防止死锁，我们可以增加一些限制条件，比如① 最多只允许4名哲学家同时进餐；② 仅当一名哲学家左右两边的筷子都可用时，才允许他抓起筷子；③ 对哲学家编号，要求奇数号哲学家先拿左边筷子，然后再拿右边，而偶数号恰好相反。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">Pi() &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        P(mutex);					<span class="comment">// 在取筷子前获得互斥量</span></span><br><span class="line">        P(chopstick[i]);			<span class="comment">// 取左边筷子</span></span><br><span class="line">        P(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);	<span class="comment">// 取右边筷子</span></span><br><span class="line">        V(mutex)					<span class="comment">// 筷子到手释放取筷子的信号量</span></span><br><span class="line">        eat;						<span class="comment">// 临界区</span></span><br><span class="line">        V(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);	<span class="comment">// 放右边筷子</span></span><br><span class="line">        V(chopstick[i]);			<span class="comment">// 放左边筷子</span></span><br><span class="line">        think;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-吸烟者问题"><a href="#5-吸烟者问题" class="headerlink" title="5. 吸烟者问题"></a>5. 吸烟者问题</h1><h2 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h2><p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草，第二个拥有纸，第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放到桌子上，拥有剩下哪种材料的抽烟者卷一根烟并抽掉它，并给供应者一个信号告诉已完成，此时供应者就会将另外两种材料放到桌上，如此重复（让三个抽烟者轮流地抽烟）。</p>
<h2 id="问题分析-4"><a href="#问题分析-4" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="关系分析-4"><a href="#关系分析-4" class="headerlink" title="关系分析"></a>关系分析</h3><p>供应者与三个抽烟者分别是同步关系。由于供应者无法同时满足两个或以上的抽烟者，三个抽烟者对抽烟这个动作互斥。</p>
<h3 id="整理思路-4"><a href="#整理思路-4" class="headerlink" title="整理思路"></a>整理思路</h3><p>显然这里有4个进程。供应者作为生产者向其它三个抽烟者提供材料。</p>
<h3 id="信号量设置-4"><a href="#信号量设置-4" class="headerlink" title="信号量设置"></a>信号量设置</h3><p>offer1：烟草和纸组合的资源；</p>
<p>offer2：烟草和胶水组合的资源；</p>
<p>offer3：纸和胶水组合的资源；</p>
<p>信号量smoke用于互斥进行抽烟。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;	<span class="comment">// 存储随机数</span></span><br><span class="line">semaphore offer1 = <span class="number">0</span>;</span><br><span class="line">semaphore offer2 = <span class="number">0</span>;</span><br><span class="line">semaphore offer3 = <span class="number">0</span>;</span><br><span class="line">semaphore smoke = <span class="number">0</span>;	<span class="comment">// 这里我们将互斥信号量初值设为0，是因为一开始需要供应者提供资源</span></span><br><span class="line"><span class="function">Process <span class="title">P1</span><span class="params">()</span> </span>&#123;		<span class="comment">// 供应者</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        num++;</span><br><span class="line">        num = num % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>) &#123;</span><br><span class="line">            V(offer1);	<span class="comment">// 提供烟草和纸</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">            V(offer2);	<span class="comment">// 提供烟草和胶水</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            V(offer3);	<span class="comment">// 提供纸和胶水</span></span><br><span class="line">        &#125;</span><br><span class="line">        任意两种材料放到桌子上;</span><br><span class="line">        P(smoke);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Process <span class="title">P2</span><span class="params">()</span> </span>&#123;			<span class="comment">// 拥有烟草者</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(offer3);</span><br><span class="line">        拿纸和胶水，卷成烟，抽掉;</span><br><span class="line">        V(smoke);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Process <span class="title">P3</span><span class="params">()</span> </span>&#123;			<span class="comment">// 拥有纸者</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(offer2);</span><br><span class="line">        拿烟草和胶水，卷成烟，抽掉;</span><br><span class="line">        V(smoke);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Process <span class="title">P4</span><span class="params">()</span> </span>&#123;			<span class="comment">// 拥有胶水者</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(offer1);</span><br><span class="line">        拿纸和烟草，卷成烟，抽掉;</span><br><span class="line">        V(smoke);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/30/%E7%BB%8F%E5%85%B8IPC%E9%97%AE%E9%A2%98/" data-id="ckzb6dz4q0023zwtw0zfaf24u" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-进程同步" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2021/12/29/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/">进程同步</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/12/29/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/" class="article-date">
  <time datetime="2021-12-29T13:47:55.000Z" itemprop="datePublished">2021-12-29</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
      <blockquote>
<ol>
<li>为什么要引入进程同步的概念？</li>
<li>不同的进程之间会存在什么关系？</li>
<li>当单纯用本节介绍的方法解决问题会遇到什么新的问题？</li>
</ol>
</blockquote>
<h1 id="1-进程同步的基本概念"><a href="#1-进程同步的基本概念" class="headerlink" title="1. 进程同步的基本概念"></a>1. 进程同步的基本概念</h1><p>在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系，引入了进程同步的概念。</p>
<h2 id="1-1-临界资源"><a href="#1-1-临界资源" class="headerlink" title="1.1 临界资源"></a>1.1 临界资源</h2><p>虽然多个进程可以共享系统中的各种资源，但许多资源一次只能为一个进程服务，我们<strong>将一次仅允许一个进程使用的资源称为临界资源</strong>。许多物理设备都属于临界资源，如打印机等。此外，还有许多变量、数据等。</p>
<p>对临界资源的访问，必须互斥地进行，在每个进程中，<strong>访问临界资源的那段代码称为临界区</strong>。为了保证临界资源的正确使用，可把临界资源的访问过程分为4个部分：</p>
<ul>
<li><strong>进入区</strong>。为了进入临界区使用临界资源，在进入区要检查可否进入临界区，若能进入，则应设置正在访问临界区的标志，以阻止其它进程同时进入临界区。</li>
<li><strong>临界区</strong>。进程中访问临界资源的那段代码，又称临界段。</li>
<li><strong>退出区</strong>。将正在访问临界区的标志清除。</li>
<li><strong>剩余区</strong>。代码中的剩余部分。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	entry section;			<span class="comment">// 进入区</span></span><br><span class="line">    critical section;		<span class="comment">// 临界区</span></span><br><span class="line">    <span class="built_in">exit</span> section;			<span class="comment">// 退出区</span></span><br><span class="line">    remainder section;		<span class="comment">// 剩余区</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<h2 id="1-2-同步"><a href="#1-2-同步" class="headerlink" title="1.2 同步"></a>1.2 同步</h2><p>同步亦称直接制约关系，是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系源于它们之间的相互合作。</p>
<h2 id="1-3-互斥"><a href="#1-3-互斥" class="headerlink" title="1.3 互斥"></a>1.3 互斥</h2><p>互斥也称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一个进程才允许去访问此临界资源。</p>
<p>为禁止两个进程同时进入临界区，同步机制应遵循以下准则：</p>
<blockquote>
<ol>
<li><strong>空闲让进</strong>。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。</li>
<li><strong>忙则等待</strong>。当已有进程进入临界区时，其它试图进入临界区的进程必须等待。</li>
<li><strong>有限等待</strong>。对请求访问的进程，应保证能在有限时间内进入临界区。</li>
<li><strong>让权等待</strong>。当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。</li>
</ol>
</blockquote>
<h1 id="2-实现临界区互斥的基本方法"><a href="#2-实现临界区互斥的基本方法" class="headerlink" title="2. 实现临界区互斥的基本方法"></a>2. 实现临界区互斥的基本方法</h1><h2 id="2-1-软件实现方法"><a href="#2-1-软件实现方法" class="headerlink" title="2.1 软件实现方法"></a>2.1 软件实现方法</h2><p>在进入区设置并检查一些标志来标明是否有进程在临界区中，若已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。</p>
<h3 id="2-1-1-单标志法"><a href="#2-1-1-单标志法" class="headerlink" title="2.1.1 单标志法"></a>2.1.1 单标志法</h3><p>该算法设置一个公用整型变量turn，<strong>用于指示被允许进入临界区的进程编号</strong>。该算法可确保每次只允许一个进程进入临界区，但两个进程必须交替进入临界区，若某个进程不再进入临界区，则另一个进程也将无法进入临界区（违背“空闲让进”）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P0进程						// P1进程</span></span><br><span class="line"><span class="keyword">while</span> (turn != <span class="number">0</span>);			<span class="keyword">while</span> (turn != <span class="number">1</span>);		<span class="comment">// 进入区</span></span><br><span class="line">critical section;			critical section;		<span class="comment">// 临界区</span></span><br><span class="line">turn = <span class="number">1</span>;					turn = <span class="number">0</span>;				<span class="comment">// 退出区</span></span><br><span class="line">remainder section;			remainder section;		<span class="comment">// 剩余区</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-双标志先检查"><a href="#2-1-2-双标志先检查" class="headerlink" title="2.1.2 双标志先检查"></a>2.1.2 双标志先检查</h3><p>该算法的基本思想是在每个进程访问临界区资源之前，先查看临界区资源是否正在被访问，只有不在，进程才能进入自己的临界区；否则等待。为此，设置一个数据flag[i]，如第i个元素值为FALSE，表示Pi进程未进入临界区；值为TRUE，表示Pi进程进入临界区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pi进程						   // Pj进程</span></span><br><span class="line"><span class="keyword">while</span> (flag[j]);	①			<span class="keyword">while</span> (flag[i]);	②	<span class="comment">// 进入区</span></span><br><span class="line">flag[i] = TRUE;		③			flag[j] = TRUE;		④	<span class="comment">// 进入区</span></span><br><span class="line">critical section;				critical section;		<span class="comment">// 临界区</span></span><br><span class="line">flag[i] = FALSE;				flag[j] = FALSE;		<span class="comment">// 退出区</span></span><br><span class="line">remainder section;				remainder section;		<span class="comment">// 剩余区</span></span><br></pre></td></tr></table></figure>

<p>优点：不用交替进入，可连续使用；</p>
<p>缺点：Pi和Pj可能同时进入临界区。按序列①②③④执行时，会同时进入临界区（“违背忙则等待”）。即在检查对方的flag后和切换自己的flag前有一段时间，结果都检查通过。这里的问题就是检查和修改不能一次进行。</p>
<h3 id="2-1-3-双标志后检查"><a href="#2-1-3-双标志后检查" class="headerlink" title="2.1.3 双标志后检查"></a>2.1.3 双标志后检查</h3><p>这里与先检查的区别就是我们先将自己的标志设为TRUE，再检测对方的状态标志。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pi进程						   // Pj进程</span></span><br><span class="line">flag[i] = TRUE;		①			flag[j] = TRUE;		②	<span class="comment">// 进入区</span></span><br><span class="line"><span class="keyword">while</span> (flag[j]);	③			<span class="keyword">while</span> (flag[i]);	④	<span class="comment">// 进入区</span></span><br><span class="line">critical section;				critical section;		<span class="comment">// 临界区</span></span><br><span class="line">flag[i] = FALSE;				flag[j] = FALSE;		<span class="comment">// 退出区</span></span><br><span class="line">remainder section;				remainder section;		<span class="comment">// 剩余区</span></span><br></pre></td></tr></table></figure>

<p>这样，我们虽然避免了“忙则等待”，但是可能会产生”饥饿“现象（按序列①②③④执行）。</p>
<h3 id="2-1-4-Peterson’s-Algorithm"><a href="#2-1-4-Peterson’s-Algorithm" class="headerlink" title="2.1.4 Peterson’s Algorithm"></a>2.1.4 Peterson’s Algorithm</h3><p>为了防止两个进程为进入临界区而无限等待，又设置了变量turn，每个进程先设置自己的标志再设置turn标志。这是，再同时检测另一个进程状态标志和允许进入标志，以便保证两个进程同时要求进入临界区时，只允许一个进程进入临界区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pi进程						   	   // Pj进程</span></span><br><span class="line">flag[i] = TRUE; turn = j;			flag[j] = TRUE; turn = i;			<span class="comment">// 进入区</span></span><br><span class="line"><span class="keyword">while</span> (flag[j] &amp;&amp; turn == j);		<span class="keyword">while</span> (flag[i] &amp;&amp; turn == i);		<span class="comment">// 进入区</span></span><br><span class="line">critical section;					critical section;					<span class="comment">// 临界区</span></span><br><span class="line">flag[i] = FALSE;					flag[j] = FALSE;					<span class="comment">// 退出区</span></span><br><span class="line">remainder section;					remainder section;					<span class="comment">// 剩余区</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-硬件实现方法"><a href="#2-2-硬件实现方法" class="headerlink" title="2.2 硬件实现方法"></a>2.2 硬件实现方法</h2><p>计算机提供了特殊的硬件指令，允许对一个字中的内容进行检测和修正，或对两个字的内容进行交换等。通过硬件支持实现临界段问题的方法称为低级方法，或称元方法。</p>
<h3 id="2-2-1-中断屏蔽方法"><a href="#2-2-1-中断屏蔽方法" class="headerlink" title="2.2.1 中断屏蔽方法"></a>2.2.1 中断屏蔽方法</h3><p>当一个进程正在使用处理机执行它的临界区代码时，防止其它进程进入其临界区进行访问的最简单方法就是：<strong>禁止一切中断发生</strong>，或称之为屏蔽中断、关中断。因为CPU只有在发生中断时才引起进程切换，典型模式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">关中断;</span><br><span class="line">临界区;</span><br><span class="line">开中断;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这种方法限制了处理机交替执行程序的能力，因此执行的效率会明显降低。对内核来说，在它执行更新变量或列表的几条指令期间，关中断是很方便，但是将关中断的权利交给用户是很不明智的，如果一个进程关中断后不再开，则系统可能祭了。</p>
<h3 id="2-2-2-硬件指令方法"><a href="#2-2-2-硬件指令方法" class="headerlink" title="2.2.2 硬件指令方法"></a>2.2.2 硬件指令方法</h3><p><strong>TestAndSet指令</strong>：这条指令是原子操作，即执行该代码时不允许被中断。其功能是读出指定的标志后把该标志设为真。指令的功能描述如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">TestAndSet</span><span class="params">(boolean *lock)</span> </span>&#123;</span><br><span class="line">    boolean old;</span><br><span class="line">    old = *lock;</span><br><span class="line">    *lock = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以为每个临界资源设置一个共享布尔变量lock，表示资源的两种状态：true表示正在被占用，初值为false。在进程访问临界资源之前，利用TestAndSet检查和修改标志lock；若有进程在临界区，则重复检查，知道进程退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (TestAndSet(&amp;lock));</span><br><span class="line">进程的临界区代码段;</span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line">进程的其它代码;</span><br></pre></td></tr></table></figure>

<p><strong>Swap指令</strong>：见名知意，其功能描述如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Swap(boolean *a, boolean *b) &#123;</span><br><span class="line">    boolean temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：以上对TestAndSet和Swap指令的描述仅仅是功能实现，而并非软件实现的定义。事实上，它们是由硬件逻辑直接实现的，不会被中断。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">key = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (key != <span class="literal">false</span>);</span><br><span class="line">	Swap(&amp;lock, &amp;key);</span><br><span class="line">进程的临界区代码段;</span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line">进程的其它代码;</span><br></pre></td></tr></table></figure>

<p>硬件方法的优点：适用于任意数目的进程，而不管是单处理机还是多处理机；简单、容易验证其正确性。可以支持进程内有多个临界区，只需为每个临界区设立一个布尔变量。</p>
<p>硬件方法的缺点：进程等待进入临界区时要耗费处理机时间，不能实现让权等待。从等待进程中随机选择一个进入临界区，有的进程可能一直选不上，从而导致“饥饿”。</p>
<h1 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3. 信号量"></a>3. 信号量</h1><p>信号量机制是一种功能较强的机制，可用来解决同步与互斥问题，它只能被两个标准的原语wait(S)和signal(S)访问，也可记为“P操作”和“V操作”。</p>
<p>原语是指完成某种功能且不被分割、不被中断执行的操作序列，通常可由硬件来实现。例如，上面的TestAndSet和Swap指令就是由硬件实现的原子操作。原语功能的不被中断执行特性在单处理机上可由软件通过屏蔽中断方法实现。</p>
<h2 id="3-1-整型信号量"><a href="#3-1-整型信号量" class="headerlink" title="3.1 整型信号量"></a>3.1 整型信号量</h2><p>整型信号量被定义为一个用于表示资源数目的整型量S，wait和signal操作可描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wait(S) &#123;</span><br><span class="line">	<span class="keyword">while</span> (S &lt;= <span class="number">0</span>);</span><br><span class="line">    S = S - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">signal(S) &#123;</span><br><span class="line">    S = S + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wait操作中，只要信号量S ≤ 0，就会不断地测试。因此，该机制<strong>并未遵循“让权等待”的准则</strong>，而是使进程处于“忙等”的状态。</p>
<h2 id="3-2-记录型信号量"><a href="#3-2-记录型信号量" class="headerlink" title="3.2 记录型信号量"></a>3.2 记录型信号量</h2><p>为解决忙等现象，我们再增加一个进程链表L，用于链接所有等待该资源的进程。记录型信号量得名于采用了记录型的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span></span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure>

<p>相应的wait(S)和signal(S)的操作如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(semaphore S)</span> </span>&#123;	<span class="comment">// 相当于申请资源</span></span><br><span class="line">	S.value--;	<span class="comment">// 进程请求一个该类资源</span></span><br><span class="line">    <span class="keyword">if</span>(S.value &lt; <span class="number">0</span>) &#123;	<span class="comment">// 资源已分配完毕</span></span><br><span class="line">        add <span class="keyword">this</span> process to S.L;	<span class="comment">// 将此进程加入到等待队列中</span></span><br><span class="line">        block(S.L);		<span class="comment">// 调用block原语，进行自我阻塞，放弃处理机，遵循了“让权等待”原则</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">(semaphore S)</span> </span>&#123;	<span class="comment">// 相当于释放资源</span></span><br><span class="line">    S.value++;	<span class="comment">// 使系统中可供分配的该类资源数量加一</span></span><br><span class="line">    <span class="keyword">if</span>(S.value &lt;= <span class="number">0</span>) &#123;	<span class="comment">// 加一之后value仍然小于等于0，说明S.L中仍有等待该资源的进程被阻塞</span></span><br><span class="line">        remove a process P from S.L;</span><br><span class="line">        wakeup(P); <span class="comment">// 调用wakeup原语，将S.L中的第一个等待进程唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-利用信号量实现同步"><a href="#3-3-利用信号量实现同步" class="headerlink" title="3.3 利用信号量实现同步"></a>3.3 利用信号量实现同步</h2><p>设S为实现进程P1，P2同步的公共信号量，初值为0。进程P2中的语句y要使用进程P1中语句x的运行结果，所有只有当语句x完成之后y才能执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">semaphore S = <span class="number">0</span>;	<span class="comment">// 初始化信号量</span></span><br><span class="line">P1() &#123;</span><br><span class="line">    x;				<span class="comment">// 语句x</span></span><br><span class="line">    V(S);			<span class="comment">// 告诉P2，x已经完成</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">P2() &#123;</span><br><span class="line">    ...</span><br><span class="line">    P(S);			<span class="comment">// 检查x是否完成</span></span><br><span class="line">    y;				<span class="comment">// 检查无误，执行y</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-利用信号量实现进程互斥"><a href="#3-4-利用信号量实现进程互斥" class="headerlink" title="3.4 利用信号量实现进程互斥"></a>3.4 利用信号量实现进程互斥</h2><p>设S为实现进程P1，P2互斥的信号量，由于每次只允许一个进程进入临界区，所以S的初值设为1（即可用资源数为1）.只需把临界区置于P(S)和V(S)之间，就可以实现两个进程对临界区资源的互斥访问。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semphore S = <span class="number">1</span>;			<span class="comment">// 初始化信号量</span></span><br><span class="line">P1() &#123;</span><br><span class="line">    ...</span><br><span class="line">    P(S);				<span class="comment">// 准备开始访问临界资源，加锁</span></span><br><span class="line">    进程P1的临界区;</span><br><span class="line">    V(S);				<span class="comment">// 访问结束，解锁</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">P2() &#123;</span><br><span class="line">    ...</span><br><span class="line">    P(S);				<span class="comment">// 准备开始访问临界资源，加锁</span></span><br><span class="line">    进程P2的临界区;		</span><br><span class="line">    V(S);				<span class="comment">// 访问结束，解锁</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单总结PV操作在同步互斥中的应用：在同步问题中，若某个行为要用到某种资源，则在这个行为前面P这种资源一下；若某个行为会提供某种资源，则在这个行为后面V这种资源一下（<strong>前P后V</strong>）。在互斥问题中，P，V操作要紧夹着是哦也能够互斥资源的那个行为，中间不能有其它冗余代码。</p>
<h2 id="3-5-利用信号量实现前驱关系"><a href="#3-5-利用信号量实现前驱关系" class="headerlink" title="3.5 利用信号量实现前驱关系"></a>3.5 利用信号量实现前驱关系</h2><p><img src="C:/Users/pengbin007/AppData/Roaming/Typora/typora-user-images/image-20211230152305157.png" alt="image-20211230152305157"></p>
<p>如图，S1,S2,…,S6是最简单的程序段（只有一条语句）。为使个程序段能正确执行，应设置若干初始值为“0”的信号量。例如，为保证S1→S2，S1→S3的前驱关系，应分别设置a1,a2。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">semaphore a1 = a2 = b1 = b2 = c = d = e = <span class="number">0</span>;	<span class="comment">// 初始化信号量</span></span><br><span class="line">S1() &#123;</span><br><span class="line">    ...;</span><br><span class="line">    V(a1); V(a2);	<span class="comment">// S1运行完成</span></span><br><span class="line">&#125;</span><br><span class="line">S2() &#123;</span><br><span class="line">    P(a1);			<span class="comment">// 检查S1是否完成</span></span><br><span class="line">    ...;</span><br><span class="line">    V(b1); V(b2);	<span class="comment">// S2完成</span></span><br><span class="line">&#125;</span><br><span class="line">S3() &#123;</span><br><span class="line">    P(a2);			<span class="comment">// 检查S1是否完成</span></span><br><span class="line">    ...;</span><br><span class="line">    V(c);			<span class="comment">// S3完成</span></span><br><span class="line">&#125;</span><br><span class="line">S4() &#123;</span><br><span class="line">    P(b1);			<span class="comment">// 检查S2是否完成</span></span><br><span class="line">    ...;</span><br><span class="line">    V(d);			<span class="comment">// S4完成</span></span><br><span class="line">&#125;</span><br><span class="line">S5() &#123;</span><br><span class="line">    P(b2);			<span class="comment">// 检查S2是否完成</span></span><br><span class="line">    ...;</span><br><span class="line">    V(e);			<span class="comment">// S5完成</span></span><br><span class="line">&#125;</span><br><span class="line">S6() &#123;</span><br><span class="line">    P(c);			<span class="comment">// 检查S3是否完成</span></span><br><span class="line">    P(d);			<span class="comment">// 检查S4是否完成</span></span><br><span class="line">    P(e);			<span class="comment">// 检查S5是否完成</span></span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-分析进程同步和互斥问题的方法步骤"><a href="#3-6-分析进程同步和互斥问题的方法步骤" class="headerlink" title="3.6 分析进程同步和互斥问题的方法步骤"></a>3.6 分析进程同步和互斥问题的方法步骤</h2><ol>
<li><strong>关系分析</strong>。</li>
<li><strong>整理思路</strong>。</li>
<li><strong>设置信号量</strong>。</li>
</ol>
<h1 id="4-管程"><a href="#4-管程" class="headerlink" title="4. 管程"></a>4. 管程</h1><p>在信号量机制中，每个要访问临界资源的进程都必须自备同步的PV操作，大量分散的同步操作给系统管理带来了麻烦，且容易因同步操作不当而导致死锁。于是，一种新的同步工具——管程。管程的特性保证了进程互斥，无须程序员自己实现互斥，从而降低了死锁发生的可能性。同时管程提供了条件变量，可以让程序员灵活地实现进程同步。</p>
<h2 id="4-1-管程的定义"><a href="#4-1-管程的定义" class="headerlink" title="4.1 管程的定义"></a>4.1 管程的定义</h2><h2 id="4-2-条件变量"><a href="#4-2-条件变量" class="headerlink" title="4.2 条件变量"></a>4.2 条件变量</h2><h1 id="5-经典同步问题"><a href="#5-经典同步问题" class="headerlink" title="5. 经典同步问题"></a>5. 经典同步问题</h1><h2 id="5-1-生产者-消费者问题"><a href="#5-1-生产者-消费者问题" class="headerlink" title="5.1 生产者-消费者问题"></a>5.1 生产者-消费者问题</h2><h2 id="5-2-读者-写者问题"><a href="#5-2-读者-写者问题" class="headerlink" title="5.2 读者-写者问题"></a>5.2 读者-写者问题</h2><h2 id="5-3-哲学家进餐问题"><a href="#5-3-哲学家进餐问题" class="headerlink" title="5.3 哲学家进餐问题"></a>5.3 哲学家进餐问题</h2><h2 id="5-4-吸烟者问题"><a href="#5-4-吸烟者问题" class="headerlink" title="5.4 吸烟者问题"></a>5.4 吸烟者问题</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/29/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/" data-id="ckzb6dz4x002czwtw6rsnb8ek" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-二十三个实验入门SpringIOC-下" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2021/12/25/%E4%BA%8C%E5%8D%81%E4%B8%89%E4%B8%AA%E5%AE%9E%E9%AA%8C%E5%85%A5%E9%97%A8SpringIOC-%E4%B8%8B/">二十三个实验入门SpringIOC(下)</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/12/25/%E4%BA%8C%E5%8D%81%E4%B8%89%E4%B8%AA%E5%AE%9E%E9%AA%8C%E5%85%A5%E9%97%A8SpringIOC-%E4%B8%8B/" class="article-date">
  <time datetime="2021-12-25T08:27:58.000Z" itemprop="datePublished">2021-12-25</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
      <blockquote>
<p>实验15：通过注解分别创建Dao、Service、Controller★</p>
<p>实验16：使用context:include-filter指定扫描包时要包含的类</p>
<p>实验17：使用context:exclude-filter指定扫描包时不包含的类</p>
<p>实验18：使用@Autowired注解实现根据类型实现自动装配★</p>
<p>实验19：如果资源类型的bean不止一个，默认根据@Autowired注解标记的成员变量名作为id查找bean，进行装配★</p>
<p>实验20：如果根据成员变量名作为id还是找不到bean，可以使用@Qualifier注解明确指定目标bean的id★</p>
<p>实验21：在方法的形参位置使用@Qualifier注解</p>
<p>实验22：@Autowired注解的required属性指定某个属性允许不被设置</p>
<p>实验23：测试泛型依赖注入★</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验23：测试泛型依赖注入★--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        @Autowired、@Resource、@Inject；都是自动装配的意思</span></span><br><span class="line"><span class="comment">        @Autowired：最强大，Spring自己的注解</span></span><br><span class="line"><span class="comment">        @Resource：j2ee：Java的标准</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        @Resource：扩展性更强，如果我们切换成另外一个容器框架，@Resource还是可以使用的，@Autowired就不行了</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验21：在方法的形参位置使用@Qualifier注解--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        @Target(&#123;ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="comment">        @Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment">        @Documented</span></span><br><span class="line"><span class="comment">        public @interface Autowired &#123;</span></span><br><span class="line"><span class="comment">        可以在方法上使用@Autowired注解(@Qualifier也可以)，而这个方法也会在bean创建的时候自动运行，并且这个方法的每一个参数都会自动注入值</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验22：@Autowired注解的required属性指定某个属性允许不被设置--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--实验20：如果根据成员变量名作为id还是找不到bean，可以使用@Qualifier注解明确指定目标bean的id★--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--实验19：如果资源类型的bean不止一个，默认根据@Autowired注解标记的成员变量名作为id查找bean，进行装配★--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--实验18：使用@Autowired注解实现根据类型实现自动装配★--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        使用@Autowired注解，Spring会自动的为这个属性赋值，它一定是去容器中找到对应的组件</span></span><br><span class="line"><span class="comment">        @Autowired</span></span><br><span class="line"><span class="comment">        private BookService bookService;</span></span><br><span class="line"><span class="comment">        @Autowired原理：</span></span><br><span class="line"><span class="comment">            ① 先按照类型去容器中找到对应的组件：bookService = ioc.getBean(BookService.class);</span></span><br><span class="line"><span class="comment">                1)找到一个，就赋值</span></span><br><span class="line"><span class="comment">                2)没找到，抛异常</span></span><br><span class="line"><span class="comment">                3)找到多个</span></span><br><span class="line"><span class="comment">                    ① 按照变量名作为id继续匹配</span></span><br><span class="line"><span class="comment">                        1)匹配上</span></span><br><span class="line"><span class="comment">                        2)没有匹配上</span></span><br><span class="line"><span class="comment">                          没有匹配上是因为我们按照变量名作为id继续匹配的</span></span><br><span class="line"><span class="comment">                          因此我们可以使用@Qualifier(&quot;bookServiceExt&quot;)指定一个新的id</span></span><br><span class="line"><span class="comment">                            找到，装配</span></span><br><span class="line"><span class="comment">                            找不到，报错</span></span><br><span class="line"><span class="comment">        @Autowired标注的自动装配的属性默认是一定装配上的</span></span><br><span class="line"><span class="comment">            找到就装配，找不到就祭了</span></span><br><span class="line"><span class="comment">        我们可以设置@Autowired(required=false)来指定属性可以没有，这是找不到就装配null</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验17：使用context:exclude-filter指定扫描包时不包含的类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atqingke&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            扫描的时候可以排除一些不要的组件</span></span><br><span class="line"><span class="comment">             ★ type=&quot;annotation&quot;：指定排除规则，按照注解进行排除，标注了指定注解的组件不要</span></span><br><span class="line"><span class="comment">                    expression=&quot;&quot;：注解的全类名</span></span><br><span class="line"><span class="comment">             ★ type=&quot;assignable&quot;：指定排除某个具体的类，按照类排除</span></span><br><span class="line"><span class="comment">                    expression=&quot;&quot;：类的全类名</span></span><br><span class="line"><span class="comment">                type=&quot;aspectj&quot;：aspectj表达式</span></span><br><span class="line"><span class="comment">                type=&quot;custom&quot;：自定义一个TypeFilter；自己写代码决定哪些使用</span></span><br><span class="line"><span class="comment">                type=&quot;regex&quot;：正则表达式</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验16：使用context:include-filter指定扫描包时要包含的类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atqingke&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            只扫描哪些组件，默认全部扫描进来</span></span><br><span class="line"><span class="comment">            使用时一定要禁用默认扫描规则：use-default-filters=&quot;false&quot;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;context:include-filter type=&quot;assignable&quot; expression=&quot;com.atqingke.servlet.BookServlet&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验15：通过注解分别创建Dao、Service、Controller（控制器：控制网站跳转逻辑）★--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        通过给bean上添加某些注解，可以快速的将bean加入到ioc容器中</span></span><br><span class="line"><span class="comment">        Ⅰ 某个类上添加上任何一个注解都能快速的将这个组件加入到ioc容器的管理中</span></span><br><span class="line"><span class="comment">        Ⅱ Spring有四个注解：</span></span><br><span class="line"><span class="comment">            @Controller：控制器；我们推荐给控制器层（servlet包下的这些）的组件加这个注解</span></span><br><span class="line"><span class="comment">            @Service：业务逻辑；我们推荐业务逻辑层的组件添加这个注解</span></span><br><span class="line"><span class="comment">            @Repository：给数据库层（持久化层，dao层）的组件添加这个注解</span></span><br><span class="line"><span class="comment">            @Component：给不属于以上几层的组件添加这个注解</span></span><br><span class="line"><span class="comment">        Ⅲ 注解可以随便加，Spring底层不会去验证你的这个组件，时候如你注解所说的就是一个dao层的或者就是一个servlet层的组件</span></span><br><span class="line"><span class="comment">            我们推荐给各层这样加，是为了给程序员看的</span></span><br><span class="line"><span class="comment">        Ⅳ 使用解将组件快速的加入到容器中需要几步：</span></span><br><span class="line"><span class="comment">            ① 给要添加的组件上标四个注解的任何一个</span></span><br><span class="line"><span class="comment">            ② 告诉Spring，自动扫描加了注解的组件；依赖context名称空间</span></span><br><span class="line"><span class="comment">            ③ 一定要导入aop包，支持加注解模式的</span></span><br><span class="line"><span class="comment">        Ⅴ 使用注解加入到容器中的组件，和使用配置加入到容器中的组件行为都是默认一样的</span></span><br><span class="line"><span class="comment">            ① 组件的id，默认就是组件的类名首字母小写</span></span><br><span class="line"><span class="comment">            ② 组件的作用域，默认就是单例的</span></span><br><span class="line"><span class="comment">        Ⅵ 组件的默认行为调整</span></span><br><span class="line"><span class="comment">            ① 在主键中添加默认的value属性值可以修改组件的id    @Controller(&quot;bookservletcontroller&quot;)</span></span><br><span class="line"><span class="comment">            ② 在组件上添加@scope注解，可以修改作用域</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        context:component-scan：自动组件扫描</span></span><br><span class="line"><span class="comment">        base-package：指定扫描的基础包；把基础包及它下面所有的包的所有加了注解的类，自动的扫描进IOC容器</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;context:component-scan base-package=&quot;com.atqingke&quot;/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/25/%E4%BA%8C%E5%8D%81%E4%B8%89%E4%B8%AA%E5%AE%9E%E9%AA%8C%E5%85%A5%E9%97%A8SpringIOC-%E4%B8%8B/" data-id="ckzb6dz3z001lzwtwf7ka2nzo" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-二十三个实验入门SpringIOC-中" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2021/12/25/%E4%BA%8C%E5%8D%81%E4%B8%89%E4%B8%AA%E5%AE%9E%E9%AA%8C%E5%85%A5%E9%97%A8SpringIOC-%E4%B8%AD/">二十三个实验入门SpringIOC(中)</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/12/25/%E4%BA%8C%E5%8D%81%E4%B8%89%E4%B8%AA%E5%AE%9E%E9%AA%8C%E5%85%A5%E9%97%A8SpringIOC-%E4%B8%AD/" class="article-date">
  <time datetime="2021-12-25T08:27:50.000Z" itemprop="datePublished">2021-12-25</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
      <blockquote>
<ul>
<li><p>实验5：配置通过静态工厂方法创建的bean、实例工厂方法创建的bean、FactoryBean★</p>
</li>
<li><p>实验6：通过继承实现bean配置信息的重用</p>
</li>
<li><p>实验7：通过abstract属性创建一个模板bean</p>
</li>
<li><p>实验8：bean之间的依赖</p>
</li>
<li><p>实验9：测试bean的作用域，分别创建单实例和多实例的bean★</p>
</li>
<li><p>实验10：创建带有生命周期方法的bean</p>
</li>
<li><p>实验11：测试bean的后置处理器</p>
</li>
<li><p>实验12：引用外部属性文件★</p>
</li>
<li><p>实验13：基于XML的自动装配</p>
</li>
<li><p>实验14：[SpEL测试I]</p>
<ul>
<li> 在SpEL中使用字面量、</li>
<li> 引用其他bean、</li>
<li> 引用其他bean的某个属性值、</li>
<li> 调用非静态方法</li>
<li> 调用静态方法、</li>
<li> 使用运算符</li>
</ul>
</li>
</ul>
</blockquote>
<p>ioc2.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验14：[SpEL测试I]</span></span><br><span class="line"><span class="comment">        在SpEL中使用字面量、</span></span><br><span class="line"><span class="comment">        引用其他bean、</span></span><br><span class="line"><span class="comment">        引用其他bean的某个属性值、</span></span><br><span class="line"><span class="comment">        调用非静态方法</span></span><br><span class="line"><span class="comment">        调用静态方法、</span></span><br><span class="line"><span class="comment">        使用运算符</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person14&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--字面量：$&#123;&#125;;    #&#123;&#125; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;12*2&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引用其他bean--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;car&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;car&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引用其他bean的某个属性值--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;car.carName&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--调用非静态方法  #&#123;对象.方法名&#125;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;car.getCarName()&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--调用静态方法  #&#123;T(全类名).静态方法名(参数)&#125;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;T(java.util.UUID).randomUUID().toString().substring(0,5)&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用运算符--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验13：基于XML的自动装配--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;car&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Car&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;carName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;宝宝&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        为Person里面的自定义类型的属性赋值</span></span><br><span class="line"><span class="comment">            property：手动赋值 ===== &lt;property name=&quot;car&quot; ref=&quot;car13&quot;/&gt;</span></span><br><span class="line"><span class="comment">            autowire=&quot;default&quot;：不自动装配，（不自动为car属性赋值）</span></span><br><span class="line"><span class="comment">            autowire=&quot;byName&quot;：以属性名作为id去容器中找到这个组件，给它赋值</span></span><br><span class="line"><span class="comment">            autowire=&quot;byType&quot;：以属性类型作为查找依据找到这个组件，给它赋值</span></span><br><span class="line"><span class="comment">            autowire=&quot;constructor&quot;：先按照有参构造器参数的类型进行装配（成功就赋值），没有就直接为组件装配null即可。</span></span><br><span class="line"><span class="comment">                                    如果按照类型找到了多个，参数的名作为id继续匹配，找到就装配，找不到就null</span></span><br><span class="line"><span class="comment">                                    不会报错</span></span><br><span class="line"><span class="comment">            autowire=&quot;no&quot;：同default</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person13&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验12：引用外部属性文件 ★ 依赖context名称空间--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        数据库连接池作为单实例最好：一个项目就一个连接池，连接池里管理很多连接。连接是直接从连接池中拿</span></span><br><span class="line"><span class="comment">        可以让Spring帮我们创建连接池对象（管理连接池）</span></span><br><span class="line"><span class="comment">        加载外部配置文件 固定写法classpath:文件名称；表示引用类路径下的一个资源</span></span><br><span class="line"><span class="comment">        通过$&#123;key&#125;动态取出配置文件中某个key对应的值</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:dbconfig.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--username是Spring的key中的一个关键字，为了防止配置文件中的key与Spring自己的关键字冲突，我们通常在配置文件中加一个前缀--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.jdbcUrl&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClass&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验11：测试bean的后置处理器--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        Spring有一个接口：后置处理器，可以在bean初始化前后调用方法</span></span><br><span class="line"><span class="comment">            （容器启动）构造器=====&gt;后置处理器before=====&gt;初始化方法=====&gt;后置处理器after=====&gt;（容器关闭）销毁方法</span></span><br><span class="line"><span class="comment">        无论bean是否有初始化方法，后置处理器都会默认其有，还会继续工作</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanPostProcessor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.MyBeanPostProcessor&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验10：创建带有生命周期方法的bean--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        生命周期：bean的创建到销毁</span></span><br><span class="line"><span class="comment">            ioc容器中注册的bean：</span></span><br><span class="line"><span class="comment">                1、单例bean，容器启动的时候就会创建好，容器关闭也会销毁创建的bean</span></span><br><span class="line"><span class="comment">                2、多实例bean，获取的时候才创建</span></span><br><span class="line"><span class="comment">            我们可以为bean自定义一些生命周期方法：Spring在创建或销毁的时候就会调用指定方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        单例bean的生命周期：</span></span><br><span class="line"><span class="comment">            构造器  》  初始化方法   》   （容器关闭）销毁方法</span></span><br><span class="line"><span class="comment">        多实例</span></span><br><span class="line"><span class="comment">            获取bean    》    容器关闭不会调用bean的销毁方法</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book10&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Book&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">destroy-method</span>=<span class="string">&quot;myDestory&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;myInit&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验9：测试bean的作用域，分别创建单实例和多实例的bean★--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        scope：指定bean是否是单实例，默认单实例</span></span><br><span class="line"><span class="comment">            prototype：多实例的</span></span><br><span class="line"><span class="comment">                1)、容器启动默认不会去创建多实例</span></span><br><span class="line"><span class="comment">                2)、获取的时候创建这个bean</span></span><br><span class="line"><span class="comment">                3)、每次获取都会创建一个新的对象</span></span><br><span class="line"><span class="comment">            singleton：单实例的，默认的</span></span><br><span class="line"><span class="comment">                1)、在容器启动完成之前就已经创建好了对象，保存在容器中了</span></span><br><span class="line"><span class="comment">                2)、任何获取都是获取之前创建好的那个对象</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person09&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--原来是按照配置的顺序创建bean--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--实验8：bean之间的依赖（只是改变创建顺序）--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        没有配置depends-on之前的bean创建顺序为person08、car、book</span></span><br><span class="line"><span class="comment">        配置之后为book、car、person08</span></span><br><span class="line"><span class="comment">        注意depends-on里面的顺序也会影响创建顺序</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person08&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span> <span class="attr">depends-on</span>=<span class="string">&quot;book,car&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;car08&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Car&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Book&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验7：通过abstract属性创建一个模板bean--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--abstract=&quot;true&quot;：通过这个属性，说明这个bean配置是一个抽象的，不能获取它的实例，只能被别人用来继承--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person07&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验6：通过继承实现bean配置信息的重用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person061&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;23&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;www.atqingke.com&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--我们可以通过parent属性：指定当前bean的配置信息继承于哪个--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person062&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;person061&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;李四&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验5：配置通过静态工厂方法创建的bean、实例工厂方法创建的bean、FactoryBean★--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--bean的创建默认都是框架利用反射new出来的bean实例--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        工厂模式：工厂帮我们创建对象：</span></span><br><span class="line"><span class="comment">        AirPlane ap = AirPlaneFactory.getAirPlane(String jzName);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        静态工厂：工厂本身不用创建对象；通过静态方法调用，对象 = 工厂类.工厂方法名()</span></span><br><span class="line"><span class="comment">        实例工厂：工厂本身需要创建对象；</span></span><br><span class="line"><span class="comment">            工厂类 工厂对象 = new 工厂类();</span></span><br><span class="line"><span class="comment">            工厂对象.getAirPlane(&quot;zs&quot;);</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--静态工厂</span></span><br><span class="line"><span class="comment">            class：指定静态工厂全类名</span></span><br><span class="line"><span class="comment">            factory-method：指定工厂方法</span></span><br><span class="line"><span class="comment">            constructor-arg：为方法传参</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;airPlaneStaticFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.factory.AirPlaneStaticFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getAirPlane&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;李思思&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实例工厂</span></span><br><span class="line"><span class="comment">            先配置出实例工厂</span></span><br><span class="line"><span class="comment">            配置我们要创建的AirPlane使用哪个工厂创建</span></span><br><span class="line"><span class="comment">                factory-bean：指定指定当前对象创建使用哪个工厂</span></span><br><span class="line"><span class="comment">                factory-method：指定使用工厂方法</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;airPlaneInstanceFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.factory.AirPlaneInstanceFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;airPlane&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.AirPlane&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">factory-bean</span>=<span class="string">&quot;airPlaneInstanceFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getAirPlane&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;张三三&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        FactoryBean（是Spring规定的一个接口），</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myFactoryBeanImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.factory.MyFactoryBeanImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>dbconfig.properties:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="meta">jdbc.jdbcUrl</span>=<span class="string">jdbc:mysql://localhost:3306/book</span></span><br><span class="line"><span class="meta">jdbc.driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<p>MyBeanPostProcessor:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/27 19:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化之前调用</span></span><br><span class="line"><span class="comment">     * Object bean：将要初始化的bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【&quot;</span> + beanName + <span class="string">&quot;】bean将要调用初始化方法了。。。BeforeInitialization。。。这个bean是这样【&quot;</span> + bean + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回传入的bean</span></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法之后调用</span></span><br><span class="line"><span class="comment">     *      String beanName：bean在xml中配置的id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【&quot;</span> + beanName + <span class="string">&quot;】bean初始化方法调用完了。。。AfterInitialization。。。这个bean是这样【&quot;</span> + bean + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AirPlaneInstanceFactory:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atqingke.bean.AirPlane;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/27 12:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirPlaneInstanceFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * new AirPlaneInstanceFactory.getAirPlane();</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AirPlane <span class="title">getAirPlane</span><span class="params">(String jzName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实例工厂调用了......&quot;</span>);</span><br><span class="line">        AirPlane airPlane = <span class="keyword">new</span> AirPlane();</span><br><span class="line">        airPlane.setFdj(<span class="string">&quot;太行&quot;</span>);</span><br><span class="line">        airPlane.setFjsName(<span class="string">&quot;pb&quot;</span>);</span><br><span class="line">        airPlane.setJzName(jzName);</span><br><span class="line">        airPlane.setPersonNum(<span class="number">300</span>);</span><br><span class="line">        airPlane.setYc(<span class="string">&quot;198.56m&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> airPlane;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AirPlane:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/27 12:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirPlane</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 发动机 */</span></span><br><span class="line">    <span class="keyword">private</span> String fdj;</span><br><span class="line">    <span class="comment">/** 机翼长度 */</span></span><br><span class="line">    <span class="keyword">private</span> String yc;</span><br><span class="line">    <span class="comment">/** 乘客 */</span></span><br><span class="line">    <span class="keyword">private</span> Integer personNum;</span><br><span class="line">    <span class="comment">/** 机长 */</span></span><br><span class="line">    <span class="keyword">private</span> String jzName;</span><br><span class="line">    <span class="comment">/** 副驾驶 */</span></span><br><span class="line">    <span class="keyword">private</span> String fjsName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AirPlane</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AirPlane</span><span class="params">(String fdj, String yc, Integer personNum, String jzName, String fjsName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fdj = fdj;</span><br><span class="line">        <span class="keyword">this</span>.yc = yc;</span><br><span class="line">        <span class="keyword">this</span>.personNum = personNum;</span><br><span class="line">        <span class="keyword">this</span>.jzName = jzName;</span><br><span class="line">        <span class="keyword">this</span>.fjsName = fjsName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFdj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fdj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFdj</span><span class="params">(String fdj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fdj = fdj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getYc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> yc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setYc</span><span class="params">(String yc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.yc = yc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getPersonNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> personNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPersonNum</span><span class="params">(Integer personNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.personNum = personNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getJzName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jzName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJzName</span><span class="params">(String jzName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jzName = jzName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFjsName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fjsName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFjsName</span><span class="params">(String fjsName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fjsName = fjsName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;AirPlane&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;fdj=&#x27;&quot;</span> + fdj + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, yc=&#x27;&quot;</span> + yc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, personNum=&quot;</span> + personNum +</span><br><span class="line">                <span class="string">&quot;, jzName=&#x27;&quot;</span> + jzName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, fjsName=&#x27;&quot;</span> + fjsName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>AirPlaneStaticFactory:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atqingke.bean.AirPlane;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/27 12:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirPlaneStaticFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AirPlaneStaticFactory.getAirPlane();</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AirPlane <span class="title">getAirPlane</span><span class="params">(String jzName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态工厂调用了......&quot;</span>);</span><br><span class="line">        AirPlane airPlane = <span class="keyword">new</span> AirPlane();</span><br><span class="line">        airPlane.setFdj(<span class="string">&quot;太行&quot;</span>);</span><br><span class="line">        airPlane.setFjsName(<span class="string">&quot;pb&quot;</span>);</span><br><span class="line">        airPlane.setJzName(jzName);</span><br><span class="line">        airPlane.setPersonNum(<span class="number">300</span>);</span><br><span class="line">        airPlane.setYc(<span class="string">&quot;198.56m&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> airPlane;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>MyFactoryBeanImpl:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atqingke.bean.Book;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.FactoryBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现了FactoryBean接口的类是Spring可以认识的工厂类</span></span><br><span class="line"><span class="comment"> * Spring会自动调用工厂方法创建实例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1、编写一个FactoryBean的实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/27 13:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFactoryBeanImpl</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Book</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂方法，返回创建对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Book <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Book book = <span class="keyword">new</span> Book();</span><br><span class="line">        book.setBookName(UUID.randomUUID().toString());</span><br><span class="line">        <span class="keyword">return</span> book;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回创建的对象类型，Spring会自动调用这个方法来确认创建的对象是什么类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Book.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为单例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true,单例；false,不是单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>IOCTest:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atqingke.bean.Book;</span><br><span class="line"><span class="keyword">import</span> com.atqingke.bean.Person;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/26 15:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOCTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;ioc2.xml&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> ConfigurableApplicationContext ioc = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;ioc2.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test14</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person person14 = ioc.getBean(<span class="string">&quot;person14&quot;</span>, Person.class);</span><br><span class="line">        System.out.println(person14);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test13</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person person13 = ioc.getBean(<span class="string">&quot;person13&quot;</span>, Person.class);</span><br><span class="line">        System.out.println(person13);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test11</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        DataSource dataSource = ioc.getBean(DataSource.class);</span><br><span class="line">        System.out.println(dataSource.getConnection());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Book book10 = ioc.getBean(<span class="string">&quot;book10&quot;</span>, Book.class);</span><br><span class="line">        System.out.println(book10);</span><br><span class="line">        ioc.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person person = context.getBean(<span class="string">&quot;person07&quot;</span>,Person.class);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/25/%E4%BA%8C%E5%8D%81%E4%B8%89%E4%B8%AA%E5%AE%9E%E9%AA%8C%E5%85%A5%E9%97%A8SpringIOC-%E4%B8%AD/" data-id="ckzb6dz40001mzwtwcmev1l0f" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-二十三个实验入门SpringIOC-上" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2021/12/25/%E4%BA%8C%E5%8D%81%E4%B8%89%E4%B8%AA%E5%AE%9E%E9%AA%8C%E5%85%A5%E9%97%A8SpringIOC-%E4%B8%8A/">二十三个实验入门SpringIOC(上)</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/12/25/%E4%BA%8C%E5%8D%81%E4%B8%89%E4%B8%AA%E5%AE%9E%E9%AA%8C%E5%85%A5%E9%97%A8SpringIOC-%E4%B8%8A/" class="article-date">
  <time datetime="2021-12-25T08:26:35.000Z" itemprop="datePublished">2021-12-25</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
      <h1 id="搭建实验环境"><a href="#搭建实验环境" class="headerlink" title="搭建实验环境"></a>搭建实验环境</h1><p>新建普通Java工程：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211225163705634.png" alt="image-20211225163705634"></p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211225163912669.png" alt="image-20211225163912669"></p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211225163750396.png" alt="image-20211225163750396"></p>
<p>创建项目包结构如图所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211225164253162.png" alt="image-20211225164253162"></p>
<p>lib目录下引入SpringIOC所需jar包：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211225164356096.png" alt="image-20211225164356096"></p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/idea64_CVGsLXEMFL.png"></p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211225165523791.png" alt="image-20211225165523791"></p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211225165711714.png" alt="image-20211225165711714"></p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211225165753740.png" alt="image-20211225165753740"></p>
<p>bean目录下新建Person类：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211225165846399.png" alt="image-20211225165846399"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/25 16:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String lastName, Integer age, String email, String gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;lastName=&#x27;&quot;</span> + lastName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, email=&#x27;&quot;</span> + email + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, gender=&#x27;&quot;</span> + gender + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>conf目录下新建一个Spring的配置文件，ioc.xml：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211225170136906.png" alt="image-20211225170136906"></p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211225170255175.png" alt="image-20211225170255175"></p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211225170350958.png" alt="image-20211225170350958"></p>
<p>OK，大功告成！</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211225170430871.png" alt="image-20211225170430871"></p>
<h1 id="实验1：通过IOC容器创建对象，并为属性赋值-★"><a href="#实验1：通过IOC容器创建对象，并为属性赋值-★" class="headerlink" title="实验1：通过IOC容器创建对象，并为属性赋值 ★"></a>实验1：通过IOC容器创建对象，并为属性赋值 ★</h1><p> IOC，Spring官网给出的英文释义是：Inversion of control，中文翻译过来就是<strong>控制反转</strong>。那什么是控制反转呢？</p>
<p>我们知道，在没有引入Spring框架之前，我们如果需要使用一个资源，我们需要自己去创建、管理、销毁等等，这是一种主动式的获取资源。而SpringIOC所做的就是控制我们的资源获取方式，将主动式反转成被动式——资源的获取不是我们自己创建，而是交由容器来创建和设置。而所谓<strong>容器</strong>就是：管理所有组件（有功能的类）；简单来说，容器做的就是让主动的new资源变成了被动的接受资源。</p>
<p>而说到容器，就离不开另一个概念——DI（Dependency Injection）依赖注入，通过这个依赖注入，容器能知道哪个组件运行的时候，需要另外的组件。并通过反射的形式，将容器中准备好的对象注入进来。</p>
<p>我们先看没有引入SpringIOC之前，我们的对象创建以及属性赋值操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atqingke.bean.Person;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/26 15:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeIOCTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.setLastName(<span class="string">&quot;引入Spring之前为属性赋值&quot;</span>);</span><br><span class="line">        person.setAge(<span class="number">21</span>);</span><br><span class="line">        person.setEmail(<span class="string">&quot;fff&quot;</span>);</span><br><span class="line">        person.setGender(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们来看实验1！</p>
<p>首先在之前创建的ioc.xml文件中加入以下内容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 注册一个Person对象，Spring会自动创建这个Person对象 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        一个Bean标签可以注册一个组件</span></span><br><span class="line"><span class="comment">        class：写要注册的组件的全类名</span></span><br><span class="line"><span class="comment">        id：这个对象的唯一标识</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">              使用property标签为Person对象的属性赋值</span></span><br><span class="line"><span class="comment">              name指定属性名</span></span><br><span class="line"><span class="comment">              value指定属性值</span></span><br><span class="line"><span class="comment">           --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;引入IOC之后的属性赋值&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;23&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ddd&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ddd&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们在容器中添加一个bean标签，就相当于创建了一个对象，class属性指明了我们创建的对象类型，id就是我们创建的对象名称。在bean标签里有property子标签，property表示的就是对象的属性，我们通过property给对象的属性赋值。property的name属性指明要赋值的属性名称，value属性指明要赋的值。</p>
<p>接下来，我们就可以获取这个由容器管理的组件了。</p>
<h1 id="实验2：根据bean的类型从IOC容器中获取bean的实例-★"><a href="#实验2：根据bean的类型从IOC容器中获取bean的实例-★" class="headerlink" title="实验2：根据bean的类型从IOC容器中获取bean的实例 ★"></a>实验2：根据bean的类型从IOC容器中获取bean的实例 ★</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ackage com.atqingke.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atqingke.bean.Person;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/26 15:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOCTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;ioc.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person person = context.getBean(Person.class);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ApplicationContext是Spring提供给我们的IOC容器的接口，通过这个接口，我们可以读取我们在配置文件中配置的组件。ClassPathXmlApplicationContext表示的就是在类路径下读取配置文件。而getBean方法就是根据bean的类型从IOC容器中获取bean的实例方法。我们来看运行效果：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211226153911719.png" alt="image-20211226153911719"></p>
<p>可以看到报错了，为什么呢？我们知道，ClassPathXmlApplicationContext是从类路径下读取配置文件，而我们的ioc.xml是在conf目录下，所以我们需要将conf目录设为我们工程的资源目录。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211226154259269.png" alt="image-20211226154259269"></p>
<p>成功之后，conf目录图标就变成了Resource资源的图标了：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211226154340666.png" alt="image-20211226154340666"></p>
<p>现在再运行，不报错了！</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211226154423157.png" alt="image-20211226154423157"></p>
<p>现在，我们来看一些细节。</p>
<blockquote>
<ol>
<li>给容器中注册一个组件，我们也从容器中按照id拿到了这个组件的对象，组件的创建工作，是由容器完成的。容器中的对象在容器创建完成的时候就已经创建好了。</li>
<li>同一个组件在IOC容器中是单实例的，容器启动完成之前已经创建好了。</li>
<li>容器中如果没有这个组件，获取组件，报异常：org.springframework.beans.factory.NoSuchBeanDefinitionException:No bean named ‘person2’ available</li>
<li>IOC容器在创建这个组件对象的时候，property标签会利用setter方法为JavaBean的属性进行赋值。</li>
</ol>
</blockquote>
<p>我们除了可以通过ClassPathXmlApplicationContext获取配置文件，还可以通过FileSystemXmlApplicationContext在系统文件路径下获取配置文件。</p>
<h1 id="实验3：通过构造器为bean的属性赋值（index-type属性介绍）"><a href="#实验3：通过构造器为bean的属性赋值（index-type属性介绍）" class="headerlink" title="实验3：通过构造器为bean的属性赋值（index,type属性介绍）"></a>实验3：通过构造器为bean的属性赋值（index,type属性介绍）</h1><p> 实验2的赋值是通过setter方法赋值的，我们也可以通过构造器为bean的属性赋值：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person031&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 调用有参构造器进行创建对象并赋值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小行星&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;4564654@ddd.com&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;55&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在，我们有两个由容器管理的bean对象了，在获取bean对象的时候，我们可以通过在类型前面加一个参数指明要获取的bean的id就可以成功获取了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context.getBean(<span class="string">&quot;person031&quot;</span>, Person.class);</span><br><span class="line"><span class="comment">// 也可以直接省略后面的bean类型</span></span><br></pre></td></tr></table></figure>

<p>我们也可以省略name参数，但这是我们要严格按照构造器中的顺序来赋值，如果没有按顺序，可以通过index属性来指明顺序：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   	可以省略name属性，严格按照构造器参数位置赋值</span></span><br><span class="line"><span class="comment">   	也可以通过index指定对应参数位置</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person032&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;xixi&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span> <span class="attr">index</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;xixi&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;456&quot;</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在构造器有重载的情况下，我们可以用type属性来指明要赋值的属性的类型：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    public Person(String lastName, String gender, String email)</span></span><br><span class="line"><span class="comment">    public Person(String lastName, Integer age, String email)</span></span><br><span class="line"><span class="comment">    在重载情况下，可以通过type指定参数的类型</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person033&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;ddd&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.Integer&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;ddd&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 当我们为一个JavaBean的属性赋值时，如果这个JavaBean出现与其它属性同名的情况，为了区分，我们可以通过p名称空间为bean赋值。要使用新的名称空间，我们需要在配置文件的beans标签中加入该名称空间：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211226161151185.png" alt="image-20211226161151185"></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    通过p名称空间为bean赋值</span></span><br><span class="line"><span class="comment">    名称空间：在xml中名称空间是用来防止标签重复的</span></span><br><span class="line"><span class="comment">    &lt;book&gt;</span></span><br><span class="line"><span class="comment">        &lt;name&gt;西游记&lt;/name&gt;</span></span><br><span class="line"><span class="comment">        &lt;price&gt;155&lt;/price&gt;</span></span><br><span class="line"><span class="comment">        &lt;author&gt;</span></span><br><span class="line"><span class="comment">            &lt;a:name&gt;吴承恩&lt;a:/name&gt;</span></span><br><span class="line"><span class="comment">            &lt;gender&gt;男&lt;/gender&gt;</span></span><br><span class="line"><span class="comment">        &lt;/author&gt;</span></span><br><span class="line"><span class="comment">    &lt;/book&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    带前缀的标签&lt;c:forEach&gt; &lt;jsp:forEach&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person034&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span> <span class="attr">p:age</span>=<span class="string">&quot;15&quot;</span> <span class="attr">p:lastName</span>=<span class="string">&quot;www&quot;</span> <span class="attr">p:email</span>=<span class="string">&quot;fff&quot;</span> <span class="attr">p:gender</span>=<span class="string">&quot;ddd&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="实验4：正确的为各种属性赋值"><a href="#实验4：正确的为各种属性赋值" class="headerlink" title="实验4：正确的为各种属性赋值"></a>实验4：正确的为各种属性赋值</h1><p>在进行实验4之前，我们要对现在的工程进行改造一下：</p>
<p>添加两个类Car和Book：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/26 16:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String carName, Integer price, String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.carName = carName;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCarName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> carName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCarName</span><span class="params">(String carName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.carName = carName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(Integer price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Car&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;carName=&#x27;&quot;</span> + carName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&quot;, color=&#x27;&quot;</span> + color + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/26 16:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String bookName, String author)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookName = bookName;</span><br><span class="line">        <span class="keyword">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBookName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBookName</span><span class="params">(String bookName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookName = bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAuthor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthor</span><span class="params">(String author)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Book&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;bookName=&#x27;&quot;</span> + bookName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, author=&#x27;&quot;</span> + author + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改Person类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Car car;</span><br><span class="line"><span class="keyword">private</span> List&lt;Book&gt; books;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; maps;</span><br><span class="line"><span class="keyword">private</span> Properties properties;</span><br></pre></td></tr></table></figure>

<p>添加四个属性，并重新生成getter、setter方法和toString以及Constructor。</p>
<blockquote>
<ul>
<li> 测试使用null值 </li>
<li> 引用类型赋值（引用其他bean、引用内部bean）</li>
<li> 集合类型赋值（List、Map、Properties）、</li>
<li> util名称空间创建集合类型的bean</li>
<li> 级联属性赋值</li>
</ul>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--级联属性赋值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person045&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;car&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;car01&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;car.price&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456798&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--util名称空间创建集合类型的bean--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--util名称空间创建集合类型的bean，方便别人引用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person044&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maps&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;myMap&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">util:map</span> <span class="attr">id</span>=<span class="string">&quot;myMap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;key01&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;key02&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;key03&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;book01&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;key04&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Car&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;carName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ddd&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;key05&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">util:map</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--集合类型赋值（List、Map、Properties）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person043&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;books&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--list 标签相当于 books = new ArrayList&lt;Book&gt;();--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book000x&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Book&quot;</span> <span class="attr">p:bookName</span>=<span class="string">&quot;西游记&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;book01&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maps&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--map 标签相当于 maps = new LinkedHashMap&lt;&gt;();--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;key01&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;key02&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;key03&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;book01&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;key04&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Car&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;carName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ddd&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;key05&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--props 标签相当于 properties = new Properties();--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;username&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Book&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;水浒传&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--引用类型赋值（引用其他bean、引用内部bean）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person042&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--ref标签就是用来引用外部其它bean--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;car&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;car01&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;car01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Car&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;carName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;五零&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--测试使用null值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person041&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;测试null值&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        通过p名称空间为bean赋值</span></span><br><span class="line"><span class="comment">        名称空间：在xml中名称空间是用来防止标签重复的</span></span><br><span class="line"><span class="comment">        &lt;book&gt;</span></span><br><span class="line"><span class="comment">            &lt;name&gt;西游记&lt;/name&gt;</span></span><br><span class="line"><span class="comment">            &lt;price&gt;155&lt;/price&gt;</span></span><br><span class="line"><span class="comment">            &lt;author&gt;</span></span><br><span class="line"><span class="comment">                &lt;a:name&gt;吴承恩&lt;a:/name&gt;</span></span><br><span class="line"><span class="comment">                &lt;gender&gt;男&lt;/gender&gt;</span></span><br><span class="line"><span class="comment">            &lt;/author&gt;</span></span><br><span class="line"><span class="comment">        &lt;/book&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        带前缀的标签&lt;c:forEach&gt; &lt;jsp:forEach&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person034&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span> <span class="attr">p:age</span>=<span class="string">&quot;15&quot;</span> <span class="attr">p:lastName</span>=<span class="string">&quot;www&quot;</span> <span class="attr">p:email</span>=<span class="string">&quot;fff&quot;</span> <span class="attr">p:gender</span>=<span class="string">&quot;ddd&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        public Person(String lastName, String gender, String email)</span></span><br><span class="line"><span class="comment">        public Person(String lastName, Integer age, String email)</span></span><br><span class="line"><span class="comment">        在重载情况下，可以通过type指定参数的类型</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person033&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;ddd&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.Integer&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;ddd&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        可以省略name属性，严格按照构造器参数位置赋值</span></span><br><span class="line"><span class="comment">        也可以通过index指定对应参数位置</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person032&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;xixi&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span> <span class="attr">index</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;xixi&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;456&quot;</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person031&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 调用有参构造器进行创建对象并赋值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小行星&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;4564654@ddd.com&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;55&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 注册一个Person对象，Spring会自动创建这个Person对象 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        一个Bean标签可以注册一个组件</span></span><br><span class="line"><span class="comment">        class：写要注册的组件的全类名</span></span><br><span class="line"><span class="comment">        id：这个对象的唯一标识</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">              使用property标签为Person对象的属性赋值</span></span><br><span class="line"><span class="comment">              name指定属性名</span></span><br><span class="line"><span class="comment">              value指定属性值</span></span><br><span class="line"><span class="comment">           --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;引入IOC之后的属性赋值&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;23&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ddd&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ddd&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/25/%E4%BA%8C%E5%8D%81%E4%B8%89%E4%B8%AA%E5%AE%9E%E9%AA%8C%E5%85%A5%E9%97%A8SpringIOC-%E4%B8%8A/" data-id="ckzb6dz59002kzwtwft3j8ddq" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-内存管理概念" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2021/12/25/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/">内存管理概念</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/12/25/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/" class="article-date">
  <time datetime="2021-12-25T06:38:59.000Z" itemprop="datePublished">2021-12-25</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
      <blockquote>
<ol>
<li>为什么要进行内存管理？</li>
<li>页式管理中每个页表项的大小的下限如何决定？</li>
<li>多级页表解决了什么问题？又会带来什么问题？</li>
</ol>
</blockquote>
<h1 id="1-内存管理的基本原理和要求"><a href="#1-内存管理的基本原理和要求" class="headerlink" title="1. 内存管理的基本原理和要求"></a>1. 内存管理的基本原理和要求</h1><p>Memory Management是OS设计中最重要和最复杂的内容之一。虽然硬件技术在不断发展，内存容量在不断增大，但仍然不可能将所有用户进程和系统所需的全部资源放入主存，因此OS必须对内存空间进行合理的划分和有效的动态分配，而这就是内存管理的概念。</p>
<p>内存管理的功能有：</p>
<blockquote>
<ul>
<li><strong>内存空间的分配与回收</strong>。由OS完成主存储器空间的分配和管理，使程序员摆脱存储分配的麻烦，提高编程效率。</li>
<li><strong>地址转换。</strong>在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址。</li>
<li><strong>内存空间的扩充。</strong>利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存。</li>
<li><strong>存储保护。</strong>保证所有作业在自己的存储空间内运行，互不干扰。</li>
</ul>
</blockquote>
<h2 id="1-1-程序装入和链接"><a href="#1-1-程序装入和链接" class="headerlink" title="1.1 程序装入和链接"></a>1.1 程序装入和链接</h2><p>创建进程首先要将程序和数据装入内存。将用户源程序变为可在内存中执行的程序，通常需要以下几个步骤：</p>
<blockquote>
<ul>
<li>编译。由编译程序将用户源代码编译成若干目标模块。</li>
<li>链接。由链接程序将编译后形成的一组目标模块及所需的库函数链接在一起，形成一个完整的装入模块。</li>
<li>装入。由装入程序将装入模块装入内存运行。</li>
</ul>
</blockquote>
<p>这三步如图所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211228140435063.png" alt="image-20211228140435063"></p>
<p>程序的链接有以下三种方式：</p>
<ul>
<li><strong>静态链接</strong>。程序运行前，就已经将各个模块和库函数链接成一个可执行程序，以后也不再拆开。</li>
<li><strong>装入时动态链接</strong>。装入内存时，边装入，边链接。</li>
<li><strong>运行时动态链接</strong>。程序运行时链接。便于修改和更新以及实现对目标模块的共享。</li>
</ul>
<p>内存的装入模块在装入内存时，也有三种方式：</p>
<ul>
<li><p><strong>绝对装入</strong>。编译时，就已经知道程序的内存位置。绝对装入程序只要按照模块中的地址，将程序和数据装入进去即可（不需要修改程序和数据）。这种方式只适用于单道程序环境。</p>
</li>
<li><p><strong>可重定位装入</strong>。在多道程序环境下，多个目标模块的起始地址通常都是从0开始，程序中的其它地址都是相对于始址的。根据内存的当前情况，将装入模块装入内存的适当位置。装入时对目标程序中指令和数据的修改过程称为<strong>重定位</strong>，地址变换通常是在装入时一次完成的，所以又称静态重定位。</p>
<p>静态重定位的特点是：一个作业装入内存时，必须给它分配要求的全部内存空间，如果没有足够的空间，则不能装入。此外，作业一旦进入内存空间，就不能移动或者再申请内存空间。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211228145653209.png" alt="image-20211228145653209"></p>
<ul>
<li><p><strong>动态运行时装入</strong>。也称动态重定位。上面讲了，可重定位装入方式一旦作业进入内存空间就不能移动，而通常而言，程序都有移动的需求，因此动态重定位也就产生了。装入程序装入内存后，并不立即把装入模块中的相对地址转换成绝对地址，而是<strong>把这种地址转换推迟到程序真正执行的时候才进行</strong>。因此，装入内存后的所有地址均为相对地址。这种方式需要一个重定位寄存器的支持。</p>
<p>动态重定位的特点是：可以将程序分配到不连续的存储区中；只需要装入部分代码即可运行程序，然后在程序运行期间，动态申请内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。</p>
</li>
</ul>
<h2 id="1-2-逻辑地址空间和物理地址空间"><a href="#1-2-逻辑地址空间和物理地址空间" class="headerlink" title="1.2 逻辑地址空间和物理地址空间"></a>1.2 逻辑地址空间和物理地址空间</h2><p>用户和程序员只需要知道逻辑地址，而内存管理的具体机制则是完全透明的，只有系统编程人员才会涉及内存管理的具体机制。不同进程可以有相同的逻辑地址，因为这些相同的逻辑地址可以映射到主存中的不同位置。</p>
<p>当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址，这个过程称为<strong>地址重定位</strong>。</p>
<h2 id="1-3-内存保护"><a href="#1-3-内存保护" class="headerlink" title="1.3 内存保护"></a>1.3 内存保护</h2><p>内存分配前，需要保护OS不受用户进程的影响，同时保护用户进程不受其它用户进程的影响。内存保护可采取两种方法：</p>
<ol>
<li>在CPU中设置一对上、下限寄存器，存放用户作业在主存中的下限和上限地址，每当CPU要访问一个地址时，分别和两个寄存器的值相比，判断有无越界。</li>
<li>采用重定位寄存器（或基址寄存器）和界地址寄存器（又称限长寄存器）来实现这种保护。重定位寄存器包含最小的物理地址，界地址寄存器包含逻辑地址的最大值。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211228160242172.png" alt="image-20211228160242172"></p>
<p>实现内存保护需要重定位寄存器和界地址寄存器，因此要注意两者区别：</p>
<ul>
<li>重定位寄存器是用来“加”的，逻辑地址 + 重定位寄存器中的值 = 物理地址</li>
<li>界地址寄存器是用来“比”的，通过比较界地址寄存器和逻辑地址的值来判断是否越界。</li>
</ul>
<h1 id="2-覆盖与交换"><a href="#2-覆盖与交换" class="headerlink" title="2. 覆盖与交换"></a>2. 覆盖与交换</h1><p>覆盖与交换技术是用在多道程序环境下用来扩充内存的两种方法。</p>
<h2 id="2-1-覆盖"><a href="#2-1-覆盖" class="headerlink" title="2.1 覆盖"></a>2.1 覆盖</h2><p>由于程序时并非任何时刻都要访问所有数据，因此可以把用户空间分成一个固定区和若干覆盖区。将经常活跃的部分放在固定区，其余按调用关系分段。先将即将访问的段放入覆盖区，其它段放在外存中，需要调用时，系统再将其调入覆盖区，替换覆盖区中原有的段。</p>
<p>覆盖技术的特点是：打破了一个进程必须全部装入主存才能运行的限制，但是当同时运行的程序大于主存的容量，仍然是不能运行的。而且，内存中只有覆盖区可以更新，不在覆盖区的部分会常驻内存。</p>
<h2 id="2-2-交换"><a href="#2-2-交换" class="headerlink" title="2.2 交换"></a>2.2 交换</h2><p>把处于等待状态的程序从内存移到辅存，腾出内存空间，这一过程又称<strong>换出</strong>；把准备好的竞争CPU运行的程序从辅存移到内存，这一过程又称<strong>换入</strong>。</p>
<p>关于交换需要注意的问题：</p>
<ol>
<li>交换需要备份存储，通常是快速磁盘。它必须足够大，并提供对这些内存映像的直接访问。</li>
<li>为了有效使用CPU，需要使每个进程的执行时间比交换时间长。</li>
<li>若换出进程，则必须保证该进程处于完全空闲状态。</li>
<li>交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用起来可能更快。</li>
<li>交换通常在有许多进程运行且内存空间吃紧时开始启动，而在系统负荷降低时就暂停。</li>
<li>普通的交换使用不多，但交换策略的变体在许多系统中仍然发挥作用。</li>
</ol>
<p>交换主要在不同进程之间进行，而覆盖则在同一程序或进程中。</p>
<h1 id="3-连续分配管理方式"><a href="#3-连续分配管理方式" class="headerlink" title="3. 连续分配管理方式"></a>3. 连续分配管理方式</h1><p>连续分配方式是指为一个用户程序分配一个连续的内存空间。主要包括单一连续分配、固定分区分配和动态分区分配。</p>
<h2 id="3-1-单一连续分配"><a href="#3-1-单一连续分配" class="headerlink" title="3.1 单一连续分配"></a>3.1 单一连续分配</h2><p>内存在此方式下分为系统区和用户区，系统区仅供OS使用，通常在低地址部分。这种方式无须进行内存包含，因为内存中永远只有一道程序，因此肯定不会因为访问越界而干扰其它程序。</p>
<p>这种方式简单、无外部碎片，可以采用覆盖技术，不需要额外的技术支持。缺点是只能用于单用户、单任务的OS中，有内部碎片，存储器的利用率极低。</p>
<h2 id="3-2-固定分区分配"><a href="#3-2-固定分区分配" class="headerlink" title="3.2 固定分区分配"></a>3.2 固定分区分配</h2><p>将用户内存空间划分为若干固定大小的区域，每个分区只装入一道作业。在划分分区时有两种不同的方法：</p>
<ul>
<li>分区大小相等</li>
<li>分区大小不等</li>
</ul>
<p>为便于内存分配，通常将分区按大小排队，并为之建立一张分区说明表，其中各表项包括每个分区的始址、大小及状态。当有用户程序要装入时，便检索该表，以找到合适的分区予以分配并将其状态置为“已分配”；没有找到则拒绝分配。</p>
<p>这种方式存在两个问题：</p>
<ol>
<li>程序可能太大而放不进任何一个分区</li>
<li>主存利用率低，当程序小于固定分区大小时，也占用了一个完整的内存分区空间，这样分区内部就存在空间浪费，这种现象称为内部碎片。</li>
</ol>
<h2 id="3-3-动态分区分配"><a href="#3-3-动态分区分配" class="headerlink" title="3.3 动态分区分配"></a>3.3 动态分区分配</h2><p>这种分区方法不预先划分内存，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此，系统中分区的大小和数目是可变的。</p>
<p>动态分区在开始分配时是很好的，但之后会导致内存中出现许多小的内存块，内存利用率也随之下降。克服外部碎片可以通过<strong>紧凑</strong>技术来解决，即OS不时地对进程进行移动和整理。但这需要动态重定位寄存器的支持，且相对费时。</p>
<p>在进程装入或换入主存时，若内存中有多个足够大的空闲块，则OS必须确定分配哪个内存块给进程使用，这就是动态分区的分配策略。考虑以下几种算法：</p>
<ol>
<li><strong>首次适应算法（First Fit）</strong>空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。</li>
<li><strong>最佳适应算法（Best Fit）</strong>空闲分区按容量递增的方式形成分区链，找到第一个能满足要求的空闲分区。</li>
<li><strong>最坏适应算法（Worst Fit）</strong>又称最大适应（Largest Fit）算法，空闲分区以容量递减的次序链接，找到第一个能满足要求的空闲分区，即挑选出最大的分区。</li>
<li><strong>邻近使用算法（Next Fit）</strong>又称循环首次适应算法，由首次适应算法演变而成。不同之处是，分配内存时从上次查找结束的位置开始继续查找。</li>
</ol>
<p>在这几种方法中，First Fit不仅最简单，通常也是最好和最快的。但是会使得低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此增加了查找的开销。</p>
<p>邻近适应算法试图解决这个问题。但实际上，它常常导致在内存的末尾分配空间分裂成小碎片。它通常比首次适应算法的结果要差。</p>
<p>最佳适应虽然称为“最佳”，但是性能通常很差，因为每次最佳的分配会留下很小的难以利用的内存块，会产生最多的外部碎片。</p>
<p>最坏与最佳相反，选择最大的可用块，会很快导致没有可用的大内存块，因此性能也非常差。</p>
<p>Knuth和Shore分别就前三种方法做了模拟实验，结果表明：首次可能比最佳效果好，而这两者一定比最大效果好。另外，在算法实现时，分配操作中最佳和最大需要对可用块进行排序或遍历查找，而首次和邻近只需要简单查找；在回收操作时，当回收的块与原来的空闲块相邻时，需要合并。</p>
<p>三种内存分区管理方式的比较如下表：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211228202338021.png" alt="image-20211228202338021"></p>
<p>以上三种内存分区管理方法有一个共同特点，即用户进程在主存中都是连续存放的。</p>
<h1 id="4-非连续分配管理方式"><a href="#4-非连续分配管理方式" class="headerlink" title="4. 非连续分配管理方式"></a>4. 非连续分配管理方式</h1><p>在连续分配方式中，即使内存中有1GB的空闲空间，但如果不是连续的，那么需要1GB的作业仍然是无法运行的。但如果采用非连续分配方式，则可以将这1GB的作业分散地分配在内存的各个区域，当然，这也需要额外的空间去存储它们（分散区域）的索引，使得非连续分配方式的存储密度低于连续存储方式的。</p>
<p>非连续分配管理方式根据分区的大小是否固定，分为分页存储管理方式和分段存储管理方式。</p>
<p>在分页存储管理方式中，又根据运行作业时是否要把作业的所有页面都装入内存才能运行，分为基本分页存储管理方式和请求分页存储管理方式。</p>
<h2 id="4-1-基本分页存储管理方式"><a href="#4-1-基本分页存储管理方式" class="headerlink" title="4.1 基本分页存储管理方式"></a>4.1 基本分页存储管理方式</h2><p>固定分区会产生内部碎片，动态分区会产生外部碎片，而且这两种技术对内存的利用率都比较低。我们希望内存的使用能尽量避免碎片的产生，这就引入了分页的思想：<strong>把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。</strong></p>
<p>分页从形式上看，类似分区相等的固定分区技术，但是分页管理不会产生外部碎片。但是两者有本质的不同点：<strong>块的大小相对分区的大小要小很多</strong>。而且因为进程也是按块划分的，所以尽管会产生内部碎片，但也只有在进程的最后一个块才有，这种碎片相对进程来说是非常小的，每个进程平均只产生半个块大小的内部碎片（也称<strong>页内碎片</strong>）。</p>
<h3 id="4-1-1-分页存储的几个基本概念"><a href="#4-1-1-分页存储的几个基本概念" class="headerlink" title="4.1.1 分页存储的几个基本概念"></a>4.1.1 分页存储的几个基本概念</h3><ol>
<li><p><strong>页面和页面大小</strong></p>
<p>进程中的块称为<strong>页</strong>，内存中的块称为<strong>页框（或页帧</strong>）。外存也以同样的单位进行划分，直接称为<strong>块</strong>。进程在执行时需要申请主存空间，即要为每个页面分配主存中的可用页框，这就产生了页和页框一一对应。</p>
<p>为方便地址转换，<strong>页面大小应是2的整数幂</strong>。同时页面大小应该适中，<strong>太小</strong>会使进程页面数过多，这样页表就过长，占用大量内存，而且也会增加硬件地址转换的开销，降低页面的换入/换出的效率；页面<strong>过大</strong>会使页内碎片增多，降低内存的利用率。</p>
</li>
<li><p><strong>地址结构</strong></p>
<p>地址结构包含两部分：前一部分为页号P，后一部分为页内偏移量W。地址长度为32位，其中0~11位为页内地址，即每页大小为4KB；12-31位为页号，地址空间最多允许二的二十次方页。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229131227978.png" alt="image-20211229131227978"></p>
<p>注意，地址结构决定了虚拟内存的寻址空间有多大。</p>
</li>
<li><p><strong>页表</strong></p>
<p>为了便于在内存中找到进程的每个页面对应的物理块，系统为每个进程建立了一张页表，它<strong>记录页面在内存中对应的物理块号</strong>，页表一般存放在内存中。</p>
<p>页表是由页表项组成的，页表项和地址都是由两部分组成的，而且第一部分都是页号，但页表项的第二部分是物理内存中的块号，而地址的第二部分是页内偏移；<strong>页表项的第二部分与地址的第二部分共同组成物理地址</strong>。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229132720413.png" alt="image-20211229132720413"></p>
<p><strong>页表的作用就是实现从页号到物理块号的地址映射。</strong></p>
</li>
</ol>
<h3 id="4-1-2-基本地址变换机构"><a href="#4-1-2-基本地址变换机构" class="headerlink" title="4.1.2 基本地址变换机构"></a>4.1.2 基本地址变换机构</h3><p>地址变换机构的任务是将逻辑地址转换为内存中的物理地址。地址变换是借助于页表实现的。如图给出了分页存储管理系统中的地址变换机构：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229135240244.png" alt="image-20211229135240244"></p>
<p>在系统中通常设置一个页表寄存器（PTR），存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和长度存放在进程控制块中，当进程执行时，才将页表始址和长度存入页表寄存器。设页面大小为L，逻辑地址A到物理地址E的变换过程如下（逻辑地址、页号、每页的长度都是十进制数）：</p>
<ol>
<li>计算页号P(P = A / L)和页内偏移量W(W=A % L)。</li>
<li>比较页号P和页表长度M，若P ≥ M，则产生越界中断，否则继续执行。</li>
<li>页表中页号P对应的页表项地址 = 页表始址F + 页号P * 页表项长度，取出该页表项内容b，即为物理块号。要注意区分页表长度和页表项长度。页表长度是指一共有多少页，页表项长度是指页地址占多大存储空间。</li>
<li>计算E = b * L + W，用得到的物理地址E去访问内存。</li>
</ol>
<p>以上整个地址转换由硬件完成。例如，若页面大小L为1KB，页号2对应的物理块为b = 8，计算逻辑地址A = 2500的物理地址E的过程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P = <span class="number">2500</span> / <span class="number">1</span>KB = <span class="number">2</span></span><br><span class="line">W = <span class="number">2500</span> % <span class="number">1</span>KB = <span class="number">452</span></span><br><span class="line">E = <span class="number">8</span> * <span class="number">1024</span> + <span class="number">452</span> = <span class="number">8644</span></span><br></pre></td></tr></table></figure>

<p> 页表项的大小不是随意规定的，而是有所约束的。页表项的作用是找到该页在内存中的位置。以32位逻辑地址空间、字节编址单位、一页4KB为例，地址空间内一共有1MB（2的32B / 4KB）页，因此需要20位才能保证表示范围能容纳所有页面，又因为以字节作为编址单位，即页表项的大小 ≥ 20/8 = 3B。所以在这个条件下，为了保证页表项能够指向所有页面，页表项的大小应该大于3B。</p>
<p>下面讨论分页管理方式存在的两个主要问题：</p>
<ul>
<li>每次访存操作都需要进行逻辑地址到物理地址的转换，地址转换过程必须足够快，否则访存速度会降低；</li>
<li>每个进程引入页表，用于存储映射机制，页表不能太大，否则内存利用率会降低。</li>
</ul>
<h3 id="4-1-3-具有快表的地址变换机构"><a href="#4-1-3-具有快表的地址变换机构" class="headerlink" title="4.1.3 具有快表的地址变换机构"></a>4.1.3 具有快表的地址变换机构</h3><p>在上面的地址变换过程中，将所有页表存放在内存中，如果要存取数据或指令，则至少需要经过两次访存：第一次是访问页表，取出数据或指令的存放地址；第二次是根据地址取出数据或指令。</p>
<p>这样就比通常执行指令的速度满了一半。为此，在地址变换机构中增设一个具有并行查找能力的高速缓冲存储器——快表。又称<strong>相联存储器（TLB）</strong>，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，主存中的页表常称为慢表。具有快表的地址变换机构如图所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229145806007.png" alt="image-20211229145806007"></p>
<p>在具有快表的分页机制中，地址的变换过程如下：</p>
<ol>
<li>CPU给出逻辑地址后，由硬件进行地址转换，将页号送入高速缓存寄存器，并将此页号与快表中的所有页号进行比较。</li>
<li>若找到匹配的页号，说明所要访问的页表项在快表中，则直接从中取出该页对应的页框号，与页内偏移量拼接形成物理地址。这样，存取数据仅一次访存即可实现。</li>
<li>若未找到匹配的页号，则需要访问主存中的页表，在读出页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换。</li>
</ol>
<blockquote>
<p>注意：有些处理机设计为快表和慢表同时查找，若在快表中查找成功则终止慢表的查找。</p>
</blockquote>
<p>一般快表的命中率可达90%以上，这样分页带来的速度损失就可降低至10%一下。</p>
<h3 id="4-1-4-两级页表"><a href="#4-1-4-两级页表" class="headerlink" title="4.1.4 两级页表"></a>4.1.4 两级页表</h3><p>由于引入了分页管理，进程在执行时不需要将所有页调入内存页框，而只需将保存有映射关系的页表调入内存。但是，我们仍然需要考虑页表的大小。以32为逻辑地址空间、页面大小4KB、页表项大小4B为例。以一个40MB的进程为例，页表项共40KB（40MB / 4KB * 4B），若将所有页表项内容保存在内存中，则需要10个内存页框来保存整个页表，整个进程大小约为一万个页面。</p>
<p>为了压缩页表，我们进一步延伸页表映射的思想，就可得到二级分页。二级页表的逻辑地址空间格式如下：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229200300740.png" alt="image-20211229200300740"></p>
<p>二级页表实际上是在原有页表结构上再加上一层页表，示意结构如下：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229201658072.png" alt="image-20211229201658072"></p>
<p>建立多级页表的目的在于建立索引，以便不用浪费主存空间去存储无用的页表项，也不用盲目地顺序式查找页表项。</p>
<h2 id="4-2-基本分段存储管理方式"><a href="#4-2-基本分段存储管理方式" class="headerlink" title="4.2 基本分段存储管理方式"></a>4.2 基本分段存储管理方式</h2><p>分页管理方式是从计算机的角度考虑设计的，目的是为了提高内存的利用率。分页通过硬件机制实现，对用户完全透明。分段管理方式的提出则考虑了用户和程序员，以满足编程、信息保护和共享、动态增长和动态链接等多方面的需要。</p>
<h3 id="4-2-1-分段"><a href="#4-2-1-分段" class="headerlink" title="4.2.1 分段"></a>4.2.1 分段</h3><p>段式管理方式按照用户进程中的自然段划分逻辑空间。例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为5段，每段从0开始编址，并分配一段连续的地址空间（段内要求连续，段间不要求连续），其逻辑地址由段号S与段内偏移量W两部分组成。</p>
<p>如图，段号为16位，段内偏移量为16位，因此一个作业最多有2的16次方 = 65536段，最大段长为64KB。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229153510705.png" alt="image-20211229153510705"></p>
<h3 id="4-2-2-段表"><a href="#4-2-2-段表" class="headerlink" title="4.2.2 段表"></a>4.2.2 段表</h3><p>每个进程都有一张逻辑空间与内存空间映射的段表，其中每个段表项对应进程的一段，段表项记录该段在内存中的始址和长度。段表的内容如图所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229153735071.png" alt="image-20211229153735071"></p>
<p>配置段表后，执行中的进程可以通过查找段表，找到每段所对应的内存区。可见，段表用于实现从逻辑段到物理内存区的映射，如图所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229155523742.png" alt="image-20211229155523742"></p>
<h3 id="4-2-3-地址变换机构"><a href="#4-2-3-地址变换机构" class="headerlink" title="4.2.3 地址变换机构"></a>4.2.3 地址变换机构</h3><p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229203619342.png" alt="image-20211229203619342"></p>
<p>分段系统的地址变换过程如图所示。为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器，用于存放段表始址F和段表长度M。从逻辑地址A到物理地址E之间的地址变换过程如下：</p>
<ol>
<li>从逻辑地址A中取出前几位为段号S，后几位为段内偏移量W。</li>
<li>比较段号S和段表长度M，若S ≥ M，则产生越界中断，否则继续执行。</li>
<li>段表中段号S对应的段表项地址 = 段表始址F + 段号S * 段表项长度，取出该段表项的前几位得到段长C。若段内偏移量 ≥ C，则产生越界中断，否则继续执行。从这里我们可以知道，段表项实际上只有两部分，前几位是段长，后几位是始址。</li>
<li>取出段表项中该段的始址b，计算E = b + W，用得到的物理地址E去访问内存。</li>
</ol>
<h3 id="4-2-4-段的共享和保护"><a href="#4-2-4-段的共享和保护" class="headerlink" title="4.2.4 段的共享和保护"></a>4.2.4 段的共享和保护</h3><p>在分段系统中，段的共享是通过两个作业的段表中相应表项指向被共享的段的同一个物理副本来实现的。当一个作业正从共享段中读取数据时，必须防止另一个作业修改此共享段中的数据。不能修改的代码称为纯代码或可重入代码（不属于临界资源），这样的代码和不能修改的数据可以共享，而可修改的代码和数据不能共享。</p>
<h2 id="4-3-段页式管理方式"><a href="#4-3-段页式管理方式" class="headerlink" title="4.3 段页式管理方式"></a>4.3 段页式管理方式</h2><p>页式管理可以有效提高内存利用率，而分段管理能反映程序的逻辑结构并有利于段的共享。将这两种方式结合起来，便形成了段页式存储管理方式。</p>
<p>在段页式系统中，作业的地址空间首先被分成若干逻辑段，每段都有自己的段号，然后将每段分成若干大小固定的页。作业的逻辑地址分为三部分：段号、页号和页内偏移量，如图所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229203843529.png" alt="image-20211229203843529"></p>
<blockquote>
<p>注意：在一个进程中，段表只有一个，而页表可能有多个。</p>
</blockquote>
<p>在进行地址变换时，首先通过段表查到页表始址，然后通过页表找到页帧号，最后形成物理地址。如图，进行一次访问实际需要三次访问主存，这里同样可以使用快表来加快查找速度，其关键字由段号、页号组成，值是对应的页帧号和保护码。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229205235593.png" alt="image-20211229205235593"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/25/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/" data-id="ckzb6dz5a002lzwtw89653j9j" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-死锁预防" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2021/12/24/%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2/">死锁预防</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/12/24/%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2/" class="article-date">
  <time datetime="2021-12-23T19:41:46.000Z" itemprop="datePublished">2021-12-24</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
      <p>死锁避免从本质上来说是不可能的，因为它需要获知未来的请求，而这些请求是不可知的。</p>
<h1 id="1-破坏互斥条件"><a href="#1-破坏互斥条件" class="headerlink" title="1. 破坏互斥条件"></a>1. 破坏互斥条件</h1><p>如果资源不被一个进程所独占，那么死锁肯定不会产生。当然，允许两个进程同时使用打印机会造成混乱，通过采用假脱机打印机技术可以允许若干个进程同时产生输出。该模型中唯一真正请求使用物理打印机的进程是打印机守护进程，由于守护进程绝不会请求别的资源，所以不会因打印机而产生死锁。</p>
<p>假设守护进程被设计成在所有输出进入假脱机之前就开始打印。我们考虑这样一个情况，如果一个输出进程在头一轮打印之后决定等待几个小时，打印机就可能空闲。为了避免这一现象，一般将守护进程设计成在完整的输出文件就绪后才开始打印。</p>
<h1 id="2-破坏占有和等待条件"><a href="#2-破坏占有和等待条件" class="headerlink" title="2. 破坏占有和等待条件"></a>2. 破坏占有和等待条件</h1><p>只要禁止已持有资源的进程再等待其它资源便可以消除死锁。一种实现方法是规定所有进程在开始执行前请求所需的全部资源。如果所需的全部资源可用，那么就将它分配给这个进程，于是该进程肯定能够运行结束。反之，则不分配，进程等待。</p>
<p>这种方法的一个直接问题是很多进程直到运行时才知道它需要多少资源。实际上，如果进程能够知道它需要多少资源，就可以使用银行家算法了。另一个问题是这种方法的资源利用率不是最优的。例如，有一个进程先从输入磁带上读取数据，进行一小时的分析，最后会写到输出磁带上，同时会在绘图仪上绘出。如果所有资源都必须提前请求，这个进程就会把输出磁带机和绘图仪控制住一小时。</p>
<p>另一种破坏占有和等待条件的方案是，要求当一个进程请求资源时，先暂时释放当前占有的所有资源，然后再尝试一次获取所需的全部资源。</p>
<h1 id="3-破坏不可抢占条件"><a href="#3-破坏不可抢占条件" class="headerlink" title="3. 破坏不可抢占条件"></a>3. 破坏不可抢占条件</h1><p>假设一个进程已经分配到一台打印机，且正在进行打印输出，如果由于它需要的绘图仪无法获得而强制性把它占有的打印机抢占掉，就会引起一片混乱。但是，一些资源可以通过虚拟化的方式来避免发生这样的情况。</p>
<p>假脱机打印机向磁盘输出，并且只允许打印机守护进程访问真正的物理打印机，这种方式可以消除涉及打印机的死锁，然而却可能带来由磁盘空间导致的死锁。但是对于大容量磁盘，要消耗完所有的磁盘空间一般是不可能的。</p>
<p>但是，并不是所有的资源都可以进行类似的虚拟化。例如，数据库中的记录或者操作系统中的表都必须被锁定，因此存在出现死锁的可能。</p>
<h1 id="4-破坏环路等待条件"><a href="#4-破坏环路等待条件" class="headerlink" title="4. 破坏环路等待条件"></a>4. 破坏环路等待条件</h1><p>消除环路等待有几种方法。一种是保证每一个进程在任何时刻只能占用一个资源，如果要请求另外一个资源，它必须先释放第一个资源。</p>
<p>另一种是将所有资源统一编号，如图。现在的规则是：进程可以在任何时刻提出资源请求，但是所有请求必须按照资源编号顺序（升序）提出。进程可以先请求打印机后请求磁带机，但不可以先请求绘图仪再请求打印机。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211224065357041.png" alt="image-20211224065357041"></p>
<p>若按此规则，资源分配图中肯定不会出现环。右图所示，只有在A请求资源j且B请求i的情况下会产生死锁。假设i和j是不同资源，它们会具有不同编号。若i&gt;j，那么A不允许请求j，因为这个编号小于A已有资源的编号；反之，则B不允许请求i。不论哪种情况都不可能产生死锁。</p>
<p>对于多于两个进程的情况，同样的逻辑依然成立。<strong>在任何时刻，总有一个已分配的资源是编号最高的</strong>。占用该资源的进程不可能请求其它已分配的各种资源。它或者会执行完毕，或者最坏的情形是去请求编号更高的资源，而编号更高的资源肯定是可用的。最终，它会结束并释放所有资源，这是其它占有最高编号资源的进程也可以执行完。简言之，存在一种所有进程都可以执行完毕的场景，所以不会产生死锁。</p>
<p>该算法的一个变种是摈弃必须按升序请求资源的限制，而仅仅要求不允许进程请求比当前所独占资源编号低的资源。</p>
<p>尽管对资源编号的方法消除了死锁的问题，但几乎找不出一种使每个人都满意的编号次序。当资源包括进程表项、假脱机磁盘空间、加锁的数据库记录及其它抽象资源时，潜在的资源及各种不同用途的数目会变得很大，以至于使编号根本无法使用。</p>
<h1 id="5-死锁预防总结"><a href="#5-死锁预防总结" class="headerlink" title="5. 死锁预防总结"></a>5. 死锁预防总结</h1><table>
<thead>
<tr>
<th>条件</th>
<th>处理方式</th>
</tr>
</thead>
<tbody><tr>
<td>互斥</td>
<td>一切都是用假脱机技术</td>
</tr>
<tr>
<td>占有和等待</td>
<td>在开始就请求全部资源</td>
</tr>
<tr>
<td>不可抢占</td>
<td>抢占资源</td>
</tr>
<tr>
<td>环路等待</td>
<td>对资源按序编号</td>
</tr>
</tbody></table>
<h1 id="6-和死锁相关的问题"><a href="#6-和死锁相关的问题" class="headerlink" title="6. 和死锁相关的问题"></a>6. 和死锁相关的问题</h1><h2 id="6-1-两阶段加锁"><a href="#6-1-两阶段加锁" class="headerlink" title="6.1 两阶段加锁"></a>6.1 两阶段加锁</h2><p>虽然在一般情况下避免死锁和预防死锁并不是很有希望，但是在一些特殊的应用方面，有很多卓越的专用算法。例如，在很多数据库系统中，一个经常发生的操作是请求锁住一些记录，然后更新所有锁住的记录。当同时有多个进程运行时，就会有死锁的危险。</p>
<p>常用的方法是两阶段加锁。在第一阶段，进程试图对所有所需的记录进行加锁，一次锁一个记录。如果第一阶段加锁成功，就开始第二阶段，完成更新然后释放锁。在第一阶段并没有做实际的工作。</p>
<h2 id="6-2-通信死锁"><a href="#6-2-通信死锁" class="headerlink" title="6.2 通信死锁"></a>6.2 通信死锁</h2><h2 id="6-3-活锁"><a href="#6-3-活锁" class="headerlink" title="6.3 活锁"></a>6.3 活锁</h2><h2 id="6-4-饥饿"><a href="#6-4-饥饿" class="headerlink" title="6.4 饥饿"></a>6.4 饥饿</h2><p>与死锁和活锁非常相似的一个问题是饥饿（starvation）。在动态运行的系统中，在任何时刻都可能请求资源。这就需要一些策略来决定在什么时候谁获得什么资源。虽然这个策略表面上很有道理，但依然有可能使一些进程永远得不到服务，虽然它们并不是死锁进程。</p>
<p>饥饿可以通过先来先服务资源分配策略来避免。在这种机制下，等待最久的进程会是下一个被调度的进程。随着时间的推移，所有进程都会变成最“老”的，因而，最终能够获得资源而完成。</p>
<h1 id="7-死锁小结"><a href="#7-死锁小结" class="headerlink" title="7. 死锁小结"></a>7. 死锁小结</h1><p>死锁是任何OS的潜在问题。在一组进程中，每个进程都因等待由该组进程中的另一进程所占有的资源而导致阻塞，死锁就发生了。这种情况会使所有的进程都处于无限等待的状态。一般来讲，这是进程一直等待被其他进程占用的某些资源释放的事件。死锁的另外一种可能的情况是一组通信进程都在等待一个消息，而通信信道却是空的，并且也没有采用超时机制。</p>
<p>通过跟踪哪一个状态是安全状态，哪一个状态是不安全状态，可以避免死锁。安全状态就是这样一个状态：存在一个事件序列，保证所有的进程都能完成。不安全状态就不存在这样的保证。银行家算法可以通过拒绝可能引起不安全状态的请求来避免死锁。</p>
<p>也可以在设计系统时就不允许死锁发生，从而在系统结构上预防死锁的发生。例如，只允许进程在任何时刻最多占有一个资源，这就破坏了循环等待环路。也可以将所有资源编号，规定进程按严格的升序请求资源，这样也能预防死锁。</p>
<p>资源死锁并不是唯一的一种死锁。尽管我们可以通过设置适当的超时机制来解决通信死锁，但它依然是某些系统中潜在的问题。</p>
<p>活锁和死锁的问题有些相似，那就是它也可以停止所有的转发进程，但是二者在技术上不同，由于活锁包含了一些实际上并没有锁住的进程，因此可以通过先来先服务的分配策略来避免饥饿。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/24/%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2/" data-id="ckzb6dz4k0020zwtwc6wo111m" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/6/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/8/">Next</a>
  </nav>
  
</section>
</div>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-bar-chart"></i> <span id="busuanzi_value_site_pv"></span></li>
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>青稞 &copy; 2022</li>
      
        <li>ZHWANGART</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="青稞"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>






<script src="/js/ocean.js"></script>

</body>

</html>