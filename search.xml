<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>！！！！！</title>
    <url>/2021/12/06/%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81/</url>
    <content><![CDATA[<ol>
<li>图床使用的github，所以图片可能加载不会很顺利，多刷新就可以了。</li>
<li>如发现有任何争议，请联系作者进行修改。</li>
</ol>
<span id="more"></span>

<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211206083540542.png" alt="image-20211206083540542"></p>
]]></content>
  </entry>
  <entry>
    <title>Spring注解驱动开发【源码】——AOP原理——链式调用通知方法</title>
    <url>/2022/02/06/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E3%80%90%E6%BA%90%E7%A0%81%E3%80%91%E2%80%94%E2%80%94AOP%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E9%80%9A%E7%9F%A5%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Spring注解驱动开发【源码】——AOP原理——获取拦截器链</title>
    <url>/2022/02/06/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E3%80%90%E6%BA%90%E7%A0%81%E3%80%91%E2%80%94%E2%80%94AOP%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96%E6%8B%A6%E6%88%AA%E5%99%A8%E9%93%BE/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Spring注解驱动开发【源码】——AOP原理——创建AOP代理</title>
    <url>/2022/02/06/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E3%80%90%E6%BA%90%E7%A0%81%E3%80%91%E2%80%94%E2%80%94AOP%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%88%9B%E5%BB%BAAOP%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Spring注解驱动开发【源码】——AOP原理——AnnotationAwareAspectJAutoProxyCreator</title>
    <url>/2022/02/06/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E3%80%90%E6%BA%90%E7%A0%81%E3%80%91%E2%80%94%E2%80%94AOP%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94AnnotationAwareAspectJAutoProxyCreator/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Spring注解驱动开发【源码】——AOP原理——@EnableAspectJAutoProxy</title>
    <url>/2022/02/06/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E3%80%90%E6%BA%90%E7%A0%81%E3%80%91%E2%80%94%E2%80%94AOP%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94-EnableAspectJAutoProxy/</url>
    <content><![CDATA[<p>要实现注解版的AOP功能，最核心的注解就是@EnableAspectJAutoProxy了，有了它，AOP模式才生效。</p>
<h4 id="流程分析图"><a href="#流程分析图" class="headerlink" title="流程分析图"></a>流程分析图</h4><p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220206131851374.png" alt="image-20220206131851374"></p>
<p>可以看到，使用@EnableAspectJAutoProxy注解实际上就是使用@Import导入一个实现了ImportBeanDefinitionRegistrar的组件，也就是利用AspectJAutoProxyRegistrar实现registerBeanDefinitions方法及那个bean手动注册到容器中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register, escalate, and configure the AspectJ auto proxy creator based on the value</span></span><br><span class="line"><span class="comment"> * of the @&#123;<span class="doctag">@link</span> EnableAspectJAutoProxy#proxyTargetClass()&#125; attribute on the importing</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将AspectJAnnotationAutoProxyCreator注册到容器中如果需要的话</span></span><br><span class="line">    AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到EnableAspectJAutoProxy注解的信息</span></span><br><span class="line">    AnnotationAttributes enableAspectJAutoProxy =</span><br><span class="line">        AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line">    <span class="comment">// 判断是否包含proxyTargetClass属性</span></span><br><span class="line">    <span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;proxyTargetClass&quot;</span>)) &#123;</span><br><span class="line">        AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否包含exposeProxy属性</span></span><br><span class="line">    <span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;exposeProxy&quot;</span>)) &#123;</span><br><span class="line">        AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在registerBeanDefinitions方法中，通过AopConfigUtils中的方法将AspectJAnnotationAutoProxyCreator注册到容器中，如果需要的话。之后拿到EnableAspectJAutoProxy注解的信息，再对其进行判断“proxyTargetClass”和“exposeProxy”是否为true，如果为true，对其进行相应操作。</p>
<p>最终，registerAspectJAnnotationAutoProxyCreatorIfNecessary方法经过两层封装来到了registerOrEscalateApcAsRequired：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerOrEscalateApcAsRequired</span><span class="params">(Class&lt;?&gt; cls, BeanDefinitionRegistry registry, Object source)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(registry, <span class="string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);</span><br><span class="line">    <span class="comment">// 判断容器中是否已经有internalAutoProxyCreator，有则让internalAutoProxyCreator = AnnotationAwareAspectJAutoProxyCreator将AnnotationAwareAspectJAutoProxyCreator注册到容器中去</span></span><br><span class="line">    <span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">        BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">        <span class="keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line">            <span class="keyword">int</span> currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line">            <span class="keyword">int</span> requiredPriority = findPriorityForClass(cls);</span><br><span class="line">            <span class="keyword">if</span> (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">                apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有，新建一个关于AnnotationAwareAspectJAutoProxyCreator的bean的定义信息</span></span><br><span class="line">    RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(cls);</span><br><span class="line">    beanDefinition.setSource(source);</span><br><span class="line">    beanDefinition.getPropertyValues().add(<span class="string">&quot;order&quot;</span>, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">    beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    <span class="comment">// internalAutoProxyCreator = AnnotationAwareAspectJAutoProxyCreator注册到容器中</span></span><br><span class="line">    registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line">    <span class="keyword">return</span> beanDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法传了一个参数：AnnotationAwareAspectJAutoProxyCreator</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220206133626317.png" alt="image-20220206133626317"></p>
<p>然后，它判断容器中是否有internalAutoProxyCreator。</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220206133943067.png" alt="image-20220206133943067"></p>
<p>如果容器中有internalAutoProxyCreator，则会让传入的cls也就是AnnotationAwareAspectJAutoProxyCreator赋给internalAutoProxyCreator。</p>
<p>而我们这里并没有这个组件，因此它会创建一个AnnotationAwareAspectJAutoProxyCreator的RootBeanDefinition(new RootBeanDefinition()也就是创建一个bean的定义信息)。</p>
<p>最后，依然是通过internalAutoProxyCreator = AnnotationAwareAspectJAutoProxyCreator将AnnotationAwareAspectJAutoProxyCreator注册到容器中。</p>
<hr>
<p><strong>因此，@EnableAspectJAutoProxy注解的作用就是将我们的AnnotationAwareAspectJAutoProxyCreator注册到容器中。</strong></p>
<hr>
]]></content>
  </entry>
  <entry>
    <title>Spring注解驱动开发——AOP功能测试</title>
    <url>/2022/02/06/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94AOP%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<blockquote>
<p>Prev： </p>
<p><a href="https://atqingke.com/index.php/archives/272/">Spring-AOP(上)</a></p>
<p><a href="https://atqingke.com/index.php/archives/278/">Spring-AOP(中)</a></p>
<p><a href="https://atqingke.com/index.php/archives/292/">Spring-AOP(下)</a></p>
</blockquote>
<p>AOP【动态代理】：指在程序运行期间动态将某段代码切入到指定方法指定位置进行运行的变成方式。</p>
<h3 id="导入AOP模块"><a href="#导入AOP模块" class="headerlink" title="导入AOP模块"></a>导入AOP模块</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="定义一个业务逻辑类"><a href="#定义一个业务逻辑类" class="headerlink" title="定义一个业务逻辑类"></a>定义一个业务逻辑类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.aop;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/1/29 20:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathCalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MathCalculator.div被调用了&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> i / j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义一个日志切面类"><a href="#定义一个日志切面类" class="headerlink" title="定义一个日志切面类"></a>定义一个日志切面类</h3><h3 id="给切面类的目标方法标注何时何地运行"><a href="#给切面类的目标方法标注何时何地运行" class="headerlink" title="给切面类的目标方法标注何时何地运行"></a>给切面类的目标方法标注何时何地运行</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/1/29 20:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspects</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public int com.atqingke.aop.MathCalculator.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logStart</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot;开始运行。。。参数列表：&#123;&quot;</span> + Arrays.toString(joinPoint.getArgs()) + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logEnd</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot;运行结束。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;pointCut()&quot;, returning = &quot;result&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logReturn</span><span class="params">(JoinPoint joinPoint, Object result)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot;返回结果。。。返回结果：&#123;&quot;</span> + result + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;pointCut()&quot;, throwing = &quot;exception&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logException</span><span class="params">(JoinPoint joinPoint, Exception exception)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot;抛出异常。。。异常信息：&#123;&quot;</span> + exception + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将切面类和业务逻辑类加入到容器中"><a href="#将切面类和业务逻辑类加入到容器中" class="headerlink" title="将切面类和业务逻辑类加入到容器中"></a>将切面类和业务逻辑类加入到容器中</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atqingke.aop.LogAspects;</span><br><span class="line"><span class="keyword">import</span> com.atqingke.aop.MathCalculator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/1/29 20:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfAOP</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MathCalculator <span class="title">mathCalculator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MathCalculator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LogAspects <span class="title">logAspects</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LogAspects();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="告诉Spring哪个是切面类-Aspect"><a href="#告诉Spring哪个是切面类-Aspect" class="headerlink" title="告诉Spring哪个是切面类@Aspect"></a>告诉Spring哪个是切面类@Aspect</h3><p>LogAspects上标注@Aspect注解</p>
<h3 id="开启基于注解的aop模式"><a href="#开启基于注解的aop模式" class="headerlink" title="开启基于注解的aop模式"></a>开启基于注解的aop模式</h3><p>MainConfigOfAOP上标注@EnableAspectJAutoProxy注解</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atqingke.aop.MathCalculator;</span><br><span class="line"><span class="keyword">import</span> com.atqingke.config.MainConfigOfAOP;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/1/26 20:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOCTestAOP</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AnnotationConfigApplicationContext bean = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfigOfAOP.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MathCalculator calculator = <span class="keyword">this</span>.bean.getBean(MathCalculator.class);</span><br><span class="line">        calculator.div(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printBeans</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">        String[] beanDefinitionNames = context.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;</span><br><span class="line">            System.out.println(beanDefinitionName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220206115158673.png" alt="image-20220206115158673"></p>
<blockquote>
<p>Next：</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Redis——配置文件介绍</title>
    <url>/2022/02/05/Redis%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>来到我们的拷贝的配置文件/etc/redis/6379.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/redis/6379.conf</span><br><span class="line">:set nu # 开启行号</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220205212916027.png" alt="image-20220205212916027"></p>
<h2 id="Units单位"><a href="#Units单位" class="headerlink" title="Units单位"></a>Units单位</h2><p>配置大小单位，开头定义了一些基本的度量单位，只支持bytes，不支持bit，并且大小写不敏感。</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220205213040529.png" alt="image-20220205213040529"></p>
<h2 id="INCLUDES包含"><a href="#INCLUDES包含" class="headerlink" title="INCLUDES包含"></a>INCLUDES包含</h2><p>类似jsp中的include，多实例的情况可以把公用的配置文件提取出来</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220205213140870.png" alt="image-20220205213140870"></p>
]]></content>
  </entry>
  <entry>
    <title>Redis——常用数据类型</title>
    <url>/2022/02/05/Redis%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>Redis操作命令见：<a href="https://redis.io/commands">https://redis.io/commands</a></p>
</blockquote>
<p>在redis中，默认有16个数据库，类似数组下标从0开始，初始默认使用0号库，所有库统一密码管理。</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220205145355439.png" alt="image-20220205145355439"></p>
<h3 id="端口6379从何而来"><a href="#端口6379从何而来" class="headerlink" title="端口6379从何而来"></a>端口6379从何而来</h3><p>Alessia Merz中Merz四个字母在9键对应的就是6379。</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220205190949547.png" alt="image-20220205190949547"></p>
<h3 id="单线程-多路IO复用"><a href="#单线程-多路IO复用" class="headerlink" title="单线程 + 多路IO复用"></a>单线程 + 多路IO复用</h3><p>与Memcached的“多线程 + 锁”不同的是，Redis是使用“单线程 + 多路IO复用”技术实现的。所谓多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/1.gif"></p>
<p>与Memcached不同的是，Redis还支持多数据类型，并且支持持久化。</p>
<h2 id="key键操作"><a href="#key键操作" class="headerlink" title="key键操作"></a>key键操作</h2><p>我们先往0号库中插入一些实验数据：</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220205145859056.png" alt="image-20220205145859056"></p>
<ul>
<li>查看当前库中所有的key</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keys *</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220205150056533.png" alt="image-20220205150056533"></p>
<ul>
<li>判断某个key是否存在</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exists k1</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220205150132189.png" alt="image-20220205150132189"></p>
<p>存在返回1，不存在返回0。</p>
<blockquote>
<p>ps：在redis-cli中也可以使用tab键进行代码自动补全。</p>
</blockquote>
<ul>
<li>查看指定key的类型</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">type k1</span><br></pre></td></tr></table></figure>

<ul>
<li>删除指定key的数据</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">del k1</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220205150340730.png" alt="image-20220205150340730"></p>
<ul>
<li>根据value选择非阻塞删除（仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unlink k2</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220205150427503.png" alt="image-20220205150427503"></p>
<ul>
<li>查看指定key还有多久过期</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ttl k3</span><br></pre></td></tr></table></figure>

<p>-1表示永不过期（默认），-2表示已过期。</p>
<ul>
<li>给给定的key设置过期时间</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">expire k3 10</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220205150657103.png" alt="image-20220205150657103"></p>
<ul>
<li>切换数据库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">select 1</span><br></pre></td></tr></table></figure>

<ul>
<li>查看当前数据库中key的数量</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dbsize</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220205150753502.png" alt="image-20220205150753502"></p>
<ul>
<li>清空当前库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flushdb</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220205150853184.png" alt="image-20220205150853184"></p>
<ul>
<li>通杀全部库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flushall</span><br></pre></td></tr></table></figure>

<h2 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h2><p>String是Redis最基本的类型，一个key对应一个value。String类型是二进制安全的，意味着Redis中的String可以包含任何数据，比如jpg图片、序列化对象等等。</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li><p>set <key> <value> 添加键值对</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220205193146385.png" alt="image-20220205193146385"></p>
<ul>
<li>EX：key的超时秒数。    </li>
<li>PX：key的超时毫秒数，与EX互斥。</li>
<li>NX：当数据库中key不存在时，可以将key-value添加数据库。</li>
<li>XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥。</li>
</ul>
</li>
<li><p>get <key> 查询对应键值</p>
</li>
<li><p>append <key> <value> 将给定的value追加到原值的末尾</p>
</li>
<li><p>strlen <key> 获得指定key的值的长度</p>
</li>
<li><p>setnx <key> <value> 只有在key不存在时，设置key的值</p>
</li>
<li><p>incr <key> 将key中存储的数字值增1，只能对数字值操作，如果为空，新增值设为1</p>
</li>
<li><p>decr <key> 与incr相反，减一。</p>
</li>
</ul>
<blockquote>
<p>ps：</p>
<ul>
<li><p>Redis中因为没有64位整数数据类型，因此，你给定一个字符串形式的数值，它会解释成一个整数。</p>
</li>
<li><p>incr/decr等都具有原子性，是原子操作：</p>
</li>
</ul>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220205195316994.png" alt="image-20220205195316994"></p>
<p>所谓原子操作是指不会被线程调度机制打断的操作。这种操作一旦开始，就一直运行到结束，中间不会有任何context switch（切换到另一个线程）。</p>
<ol>
<li>在单线程中，能够在单条指令中完成的操作都可以认为是“原子操作”，因为中断只能发生于指令之间。</li>
<li>在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。</li>
</ol>
<p>Redis单命令的原子性主要得益于它的单线程。</p>
</blockquote>
<ul>
<li>incrby/decrby <key> &lt;步长&gt; 将key中存储的数字值增减自定义步长个单位</li>
<li>mset <key1> <value1> <key2> <value2> … 同时设置一个或多个key-value对</li>
<li>mget <key1><key2>… 同时获取一个或多个value</li>
<li>msetnx <key1> <value1> <key2> <value2> … 当且仅当所有给定key不存在，同时设置一个或多个key-value对</li>
</ul>
<blockquote>
<p>ps：这些同时获取或同时设置的操作也都是具有原子性的，有一个失败则都失败。</p>
</blockquote>
<ul>
<li>getrange <key> &lt;起始位置&gt; &lt;结束位置&gt; 获得值的范围，类似Java中的substring，并且在这里是“前包后包”的</li>
<li>setrange <key> &lt;起始位置&gt; <value> 用<value>覆写<key>所存储的字符串值，从&lt;起始位置&gt;开始（索引从0开始）</li>
<li>setex <key> &lt;过期时间&gt; <value> 设置键值的同时，设置过期时间，单位是秒</li>
<li>getset <key> <value> 以新换旧，设置了新值的同时获得旧值</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>String的数据结构为简单动态字符串（Simple Dynamic String，SDS），是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220205200240070.png" alt="image-20220205200240070"></p>
<p>如图所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有空间；如果超过1M，扩容时一次只会扩1M的空间。需要注意的是字符串最大长度为512M。</p>
<h2 id="列表-List"><a href="#列表-List" class="headerlink" title="列表(List)"></a>列表(List)</h2><p><strong>单键多值</strong></p>
<p>Redis列表是简单的字符串列表，安装插入顺序排列，你可以添加一个元素到列表的头部（左边）或者尾部（右边）。它的底层实际上就是一个双向链表，对两端的操作性能很高，通过索引下标的操作中间节点的性能会较差。</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220205204418180.png" alt="image-20220205204418180"></p>
<h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li>lpush/rpush <key><value1><value2>… 从左边/右边插入一个或多个值</li>
<li>lpop/rpop <key> 从左边/右边吐出一个值。<strong>值在键在，值光键亡</strong></li>
<li>rpoplpush <key1><key2> 从key1列表右边吐出一个值插到key2列表左边</li>
<li>lrange <key><start><stop> 按照索引下标获得元素（从左到右）</li>
<li>lindex <key><index> 按照索引下标获得元素（从左到右）</li>
<li>llen <key> 获得列表长度</li>
<li>linsert <key> before <value><newvalue> 在value的后面插入newvalue</li>
<li>lrem <key> <n> <value> 从左边删除n个value</li>
<li>lset <key> <index> <vlaue> 将列表key下标为index的值替换成value</li>
</ul>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，即压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p>
<p>当数据量比较多的时候才会改成quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220205205633337.png" alt="image-20220205205633337"></p>
<p>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p>
<h2 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合(Set"></a>集合(Set</h2><h2 id=""><a href="#" class="headerlink" title=")"></a>)</h2><p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p>
<p>Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的复杂度都是O(1)。一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变</p>
<h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li><p>sadd <key><value1><value2> ….. 将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</p>
</li>
<li><p>smembers <key> 取出该集合的所有值。</p>
</li>
<li><p>sismember <key><value> 判断集合<key>是否为含有该<value>值，有1，没有0</p>
</li>
<li><p>scard<key> 返回该集合的元素个数。</p>
</li>
<li><p>srem <key><value1><value2> …. 删除集合中的某个元素。</p>
</li>
<li><p>spop <key> <strong>随机从该集合中吐出一个值。</strong></p>
</li>
<li><p>srandmember <key><n> 随机从该集合中取出n个值。不会从集合中删除 。</p>
</li>
<li><p>smove <source><destination> value把集合中一个值从一个集合移动到另一个集合</p>
</li>
<li><p>sinter <key1><key2> 返回两个集合的交集元素。</p>
</li>
<li><p>sunion <key1><key2> 返回两个集合的并集元素。</p>
</li>
<li><p>sdiff <key1><key2> 返回两个集合的<strong>差集</strong>元素(key1中的，不包含key2中的)</p>
</li>
</ul>
<h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><p>Set数据结构是dict字典，字典是用哈希表实现的。</p>
<p>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p>
<h2 id="哈希-Hash"><a href="#哈希-Hash" class="headerlink" title="哈希(Hash)"></a>哈希(Hash)</h2><p>Redis hash 是一个键值对集合。</p>
<p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
<p>类似Java里面的Map&lt;String,Object&gt;</p>
<p>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储</p>
<p>主要有以下2种存储方式：</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220205212029272.png" alt="image-20220205212029272"></p>
<p><strong>通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题</strong></p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220205212045199.png" alt="image-20220205212045199"></p>
<h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li>hset <key><field><value> 给<key>集合中的 <field>键赋值<value></li>
<li>hget <key1><field>从<key1> 集合<field>取出 value </li>
<li>hmset <key1><field1><value1><field2><value2>… 批量设置hash的值</li>
<li>hexists<key1><field> 查看哈希表 key 中，给定域 field 是否存在。 </li>
<li>hkeys <key> 列出该hash集合的所有field</li>
<li>hvals <key> 列出该hash集合的所有value</li>
<li>hincrby <key><field><increment> 为哈希表 key 中的域 field 的值加上增量 1  -1</li>
<li>hsetnx <key><field><value> 将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在 .</li>
</ul>
<h3 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h3><p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p>
<h2 id="有序集合-Zset"><a href="#有序集合-Zset" class="headerlink" title="有序集合(Zset"></a>有序集合(Zset</h2><h2 id="-1"><a href="#-1" class="headerlink" title=")"></a>)</h2><p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。</p>
<p>不同之处是有序集合的每个成员都关联了一个评分（score）,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。</p>
<p>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。</p>
<p>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p>
<h3 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li>zadd <key><score1><value1><score2><value2>… 将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</li>
<li><strong>zrange <key><start><stop> [WITHSCORES]</strong>  返回有序集 key 中，下标在<start><stop>之间的元素，带WITHSCORES，可以让分数一起和值返回到结果集。</li>
<li>zrangebyscore key minmax [withscores] [limit offset count] 返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。 </li>
<li>zrevrangebyscore key maxmin [withscores] [limit offset count] 同上，改为从大到小排列。 </li>
<li>zincrby <key><increment><value> 为元素的score加上增量</li>
<li>zrem <key><value> 删除该集合下，指定值的元素</li>
<li>zcount <key><min><max> 统计该集合，分数区间内的元素个数 </li>
<li>zrank <key><value> 返回该值在集合中的排名，从0开始。</li>
</ul>
<h3 id="数据结构-4"><a href="#数据结构-4" class="headerlink" title="数据结构"></a>数据结构</h3><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p>
<p>zset底层使用了两个数据结构</p>
<p>（1）hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</p>
<p>（2）跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</p>
<h3 id="跳跃表-跳表"><a href="#跳跃表-跳表" class="headerlink" title="跳跃表(跳表)"></a>跳跃表(跳表)</h3><h4 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h4><p>  有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</p>
<h4 id="2、实例"><a href="#2、实例" class="headerlink" title="2、实例"></a>2、实例</h4><p>  对比有序链表和跳跃表，从链表中查询出51</p>
<p>（1）有序链表</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220205211835526.png" alt="image-20220205211835526">                       </p>
<p>要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</p>
<p>（2）跳跃表</p>
<p> <img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220205211855669.png" alt="image-20220205211855669"></p>
<ol>
<li>从第2层开始，1节点比51节点小，向后比较。</li>
<li>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层</li>
<li>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下</li>
<li>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</li>
</ol>
<p>从此可以看出跳跃表比有序链表效率要高</p>
]]></content>
  </entry>
  <entry>
    <title>Redis——配置后台启动</title>
    <url>/2022/02/04/Redis%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p>进入/usr/local/redis/redis-6.2.6/utils目录下执行脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/redis/redis-6.2.6/utils</span><br><span class="line">./install_server.sh</span><br></pre></td></tr></table></figure>

<p>执行脚本可能会报错：</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220204211320488.png" alt="image-20220204211320488"></p>
<p>我们使用vim，将install_server.sh脚本中如下代码注释即可：</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220204211042462.png" alt="image-20220204211042462"></p>
<p>安装成功，这里我全部都是enter选择默认配置：</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220204211632150.png" alt="image-20220204211632150"></p>
<p>后台启动并查看运行状态：</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220204211858740.png" alt="image-20220204211858740"></p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220204214557898.png" alt="image-20220204214557898"></p>
]]></content>
  </entry>
  <entry>
    <title>Redis——安装</title>
    <url>/2022/02/03/Redis%E2%80%94%E2%80%94%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>英文官网：<a href="https://redis.io/">https://redis.io/</a></li>
<li>中文官网：<a href="http://redis.cn/">http://redis.cn/</a></li>
</ul>
</blockquote>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220203145900071.png" alt="image-20220203145900071"></p>
<h2 id="Redis概述"><a href="#Redis概述" class="headerlink" title="Redis概述"></a>Redis概述</h2><ul>
<li>Redis是一个开源的key-value存储系统。</li>
<li>和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。</li>
<li>这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</li>
<li>在此基础上，Redis支持各种不同方式的排序。</li>
<li>与memcached一样，为了保证效率，数据都是缓存在内存中。</li>
<li>区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</li>
<li>并且在此基础上实现了master-slave(主从)同步。</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h4 id="配合关系型数据库做高速缓存"><a href="#配合关系型数据库做高速缓存" class="headerlink" title="配合关系型数据库做高速缓存"></a>配合关系型数据库做高速缓存</h4><p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220204201013137.png" alt="image-20220204201013137"></p>
<h4 id="多样的数据结构存储持久化数据"><a href="#多样的数据结构存储持久化数据" class="headerlink" title="多样的数据结构存储持久化数据"></a>多样的数据结构存储持久化数据</h4><p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220204200947400.png" alt="image-20220204200947400"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li>安装C语言环境（如果有，这一步可以跳过）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install centos-release-scl scl-utils-build</span><br><span class="line">yum install -y devtoolset-8-toolchain</span><br><span class="line">scl enable devtoolset-8 bash</span><br></pre></td></tr></table></figure>

<ul>
<li>/usr/local目录下创建redis文件夹</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">mkdir redis</span><br></pre></td></tr></table></figure>

<ul>
<li>将安装包解压到新建的redis目录中</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd redis</span><br><span class="line">tar zxvf /opt/software/redis-6.2.6.tar.gz -C ./</span><br></pre></td></tr></table></figure>

<p>解压完之后，在redis目录下会出现一个redis-6.2.6目录</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220204203944653.png" alt="image-20220204203944653"></p>
<ul>
<li>编译并安装</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd redis-6.2.6</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>安装成功</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220204204335967.png" alt="image-20220204204335967"></p>
<blockquote>
<p>ps：执行make的时候报错</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220204205112972.png" alt="image-20220204205112972"></p>
<p>解决方案：执行命令 <strong>make distclean</strong></p>
<p>执行完后，再执行一遍make &amp;&amp; make install</p>
</blockquote>
<h3 id="安装目录"><a href="#安装目录" class="headerlink" title="安装目录"></a>安装目录</h3><p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220204205517902.png" alt="image-20220204205517902"></p>
<h3 id="前台启动"><a href="#前台启动" class="headerlink" title="前台启动"></a>前台启动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220204210256753.png" alt="image-20220204210256753"></p>
<p>前台启动，命令行窗口不能关闭，否则服务器停止（一般不采用）。</p>
<h3 id="配置文件启动"><a href="#配置文件启动" class="headerlink" title="配置文件启动"></a>配置文件启动</h3><ul>
<li>将/usr/local/redis/redis-6.2.6/redis.conf复制备份</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc</span><br><span class="line">mkdir redis</span><br><span class="line">cp /usr/local/redis/redis-6.2.6/redis.conf /etc/redis/6379.conf</span><br></pre></td></tr></table></figure>

<ul>
<li>修改6379.conf以下几处</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 注释第76行，95行改成no，以便允许远程连接，否则只能本机连接</span><br><span class="line">76 #bind 127.0.0.1 -::1</span><br><span class="line">95 protected-mode no</span><br><span class="line"># 258行改为yes，允许后台启动</span><br><span class="line">258 daemonize yes</span><br></pre></td></tr></table></figure>

<ul>
<li>启动</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/bin/redis-server /usr/local/redis/redis-6.2.6/redis.conf</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220204223904012.png" alt="image-20220204223904012"></p>
<h3 id="系统后台启动"><a href="#系统后台启动" class="headerlink" title="系统后台启动"></a>系统后台启动</h3><ul>
<li>编辑redis.service</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/redis.service</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将下面内容写进去</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=Redis</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/var/run/redis_6379.pid</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里要注意换成你自己的目录</span></span><br><span class="line">ExecStart=/usr/local/bin/redis-server /etc/redis/6379.conf</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">ExecStop=/bin/kill -s QUIT $MAINPID</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<ul>
<li>让文件立即生效</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>

<ul>
<li>启动</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">systemctl start redis.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启</span></span><br><span class="line">systemctl restart redis.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭</span></span><br><span class="line">systemctl stop redis.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看状态</span></span><br><span class="line">systemctl status redis.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置开机自启</span></span><br><span class="line">systemctl enable redis.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止开机自启</span></span><br><span class="line">systemctl disable redis.service</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220204224633669.png" alt="image-20220204224633669"></p>
<h3 id="redis-cli客户端连接测试"><a href="#redis-cli客户端连接测试" class="headerlink" title="redis-cli客户端连接测试"></a>redis-cli客户端连接测试</h3><p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220204225423226.png" alt="image-20220204225423226"></p>
<h3 id="Redis-Desktop远程连接测试"><a href="#Redis-Desktop远程连接测试" class="headerlink" title="Redis Desktop远程连接测试"></a>Redis Desktop远程连接测试</h3><ul>
<li>建立连接</li>
</ul>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220204230650784.png" alt="image-20220204230650784"></p>
<ul>
<li>无法连接</li>
</ul>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220204225842776.png" alt="image-20220204225842776"></p>
<p>给redis设置一个密码即可，在/etc/redis/6379.conf文件下做如下修改：</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220204230327825.png" alt="image-20220204230327825"></p>
<p>requirepass后面就是你的redis密码。</p>
<ul>
<li>重新建立连接</li>
</ul>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220204230938826.png" alt="image-20220204230938826"></p>
<ul>
<li>测试成功</li>
</ul>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220204230608520.png" alt="image-20220204230608520"></p>
<p>此时，我们使用redis-cli连接也需要输入密码</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220205144625640.png" alt="image-20220205144625640"></p>
]]></content>
  </entry>
  <entry>
    <title>Redis——NoSQL数据库简介</title>
    <url>/2022/02/03/Redis%E2%80%94%E2%80%94NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="技术发展"><a href="#技术发展" class="headerlink" title="技术发展"></a>技术发展</h2><p>我们目前的技术分类有：</p>
<ul>
<li>解决功能性的问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN</li>
<li>解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis</li>
<li>解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</li>
</ul>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220203152632905.png" alt="image-20220203152632905"></p>
<p>在我们的Web1.0时代，数据量访问特别有限，我们使用一夫当关的高性能单节点服务器就足以满足绝大部分的业务场景了。</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220203160555989.png" alt="image-20220203160555989"></p>
<p>随着Web2.0的时代的到来，用户访问量大幅度提升，同时产生了大量的用户数据。加上后来的智能移动设备的普及，所有的互联网平台都面临了巨大的性能挑战。</p>
<p>而为了解决CPU和内存的压力，比如，session存在哪里？应运而生的有以下几种解决方案：</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220203161839755.png" alt="image-20220203161839755"></p>
<ul>
<li>存在cookie中，但是不安全，而且网络负担效率低。</li>
<li>存在文件服务器或者数据库中，造成严重的IO压力以及效率问题。</li>
<li>session复制，易造成session数据冗余，并且节点越多，浪费越大。</li>
<li>存在缓存数据库中，完全在内存中，速度快，数据结构简单。</li>
</ul>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220203162815759.png" alt="image-20220203162815759"></p>
<h2 id="NoSQL数据库"><a href="#NoSQL数据库" class="headerlink" title="NoSQL数据库"></a>NoSQL数据库</h2><p>所谓的NoSQL不是指没有SQL，而是指Not Only SQL，意指“不仅仅是SQL”，泛指“非关系型数据库”。NoSQL数据库不依赖于传统的业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。它有以下特点：</p>
<ul>
<li>不遵循SQL标准；</li>
<li>不支持ACID（注意不是不支持事务）；</li>
<li>远超于SQL的性能；</li>
<li>……</li>
</ul>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>对数据高并发的读写。</li>
<li>海量数据的读写。</li>
<li>对数据高可扩展性。</li>
</ul>
<h3 id="不适用场景"><a href="#不适用场景" class="headerlink" title="不适用场景"></a>不适用场景</h3><ul>
<li>需要事务支持。</li>
<li>基于sql的结构化查询存储，处理复杂的关系。</li>
<li><strong>用不着sql的和用来sql也不行的情况，请考虑用NoSQL。</strong></li>
</ul>
<h3 id="常见产品"><a href="#常见产品" class="headerlink" title="常见产品"></a>常见产品</h3><h4 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h4><ul>
<li>很早出现的NoSql数据库</li>
<li>数据都在内存中，一般不持久化</li>
<li>支持简单的key-value模式，支持类型单一</li>
<li>一般是作为缓存数据库辅助持久化的数据库</li>
</ul>
<h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><ul>
<li>几乎覆盖了Memcached的绝大部分功能</li>
<li>数据都在内存中，支持持久化，主要用作备份恢复</li>
<li>除了支持简单的key-value模式，还支持多种数据结构的存储，比如 list、set、hash、zset等。</li>
<li>一般是作为缓存数据库辅助持久化的数据库</li>
</ul>
<h4 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h4><ul>
<li>高性能、开源、模式自由(schema free)的<strong>文档型数据库</strong></li>
<li>数据都在内存中， 如果内存不足，把不常用的数据保存到硬盘</li>
<li>虽然是key-value模式，但是对value（尤其是<strong>json</strong>）提供了丰富的查询功能</li>
<li>支持二进制数据及大型对象</li>
<li>可以根据数据的特点替代RDBMS ，成为独立的数据库。或者配合RDBMS，存储特定的数据。</li>
</ul>
<h2 id="行式存储数据库（大数据时代）"><a href="#行式存储数据库（大数据时代）" class="headerlink" title="行式存储数据库（大数据时代）"></a>行式存储数据库（大数据时代）</h2><h3 id="行式数据库"><a href="#行式数据库" class="headerlink" title="行式数据库"></a>行式数据库</h3><p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220203164458163.png" alt="image-20220203164458163"></p>
<h3 id="列式数据库"><a href="#列式数据库" class="headerlink" title="列式数据库"></a>列式数据库</h3><p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220203164655935.png" alt="image-20220203164655935"></p>
<h3 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h3><p>HBase是<strong>Hadoop</strong>项目中的数据库。它用于需要对大量的数据进行随机、实时的读写操作的场景中。</p>
<p>HBase的目标就是处理数据量非常庞大的表，可以用普通的计算机处理超过10亿行数据，还可处理有数百万列元素的数据表。</p>
<h3 id="Cassandra"><a href="#Cassandra" class="headerlink" title="Cassandra"></a>Cassandra</h3><p>Apache Cassandra是一款免费的开源NoSQL数据库，其设计目的在于管理由大量商用服务器构建起来的庞大集群上的海量数据集(数据量通常达到PB级别)。在众多显著特性当中，Cassandra最为卓越的长处是对写入及读取操作进行规模调整，而且其不强调主集群的设计思路能够以相对直观的方式简化各集群的创建与扩展流程。</p>
<blockquote>
<p>ps：计算机存储单位</p>
<p>计算机存储单位一般用B，KB，MB，GB，TB，EB，ZB，YB，BB来表示，它们之间的关系是：</p>
<p>位 bit (比特)(Binary Digits)：存放一位二进制数，即 0 或 1，最小的存储单位。</p>
<p>字节 byte：8个二进制位为一个字节(B)，最常用的单位。</p>
<p>1KB (Kilobyte 千字节)=1024B，</p>
<p>1MB (Megabyte 兆字节 简称“兆”)=1024KB，</p>
<p>1GB (Gigabyte 吉字节 又称“千兆”)=1024MB，</p>
<p>1TB (Trillionbyte 万亿字节 太字节)=1024GB，其中1024=2^10 ( 2 的10次方)，</p>
<p>1PB（Petabyte 千万亿字节 拍字节）=1024TB，</p>
<p>1EB（Exabyte 百亿亿字节 艾字节）=1024PB，</p>
<p>1ZB (Zettabyte 十万亿亿字节 泽字节)= 1024 EB,</p>
<p>1YB (Jottabyte 一亿亿亿字节 尧字节)= 1024 ZB,</p>
<p>1BB (Brontobyte 一千亿亿亿字节)= 1024 YB.</p>
<p>注：“兆”为百万级数量单位。</p>
</blockquote>
<h2 id="图关系型数据库"><a href="#图关系型数据库" class="headerlink" title="图关系型数据库"></a>图关系型数据库</h2><p>主要应用：社会关系，公共交通网络，地图及网络拓谱(n*(n-1)/2)</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220203165033021.png" alt="image-20220203165033021"></p>
<h2 id="DB-Engines数据库排名"><a href="#DB-Engines数据库排名" class="headerlink" title="DB-Engines数据库排名"></a>DB-Engines数据库排名</h2><p><a href="http://db-engines.com/en/ranking"><strong>http://db-engines.com/en/ranking</strong></a></p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220203165235844.png" alt="image-20220203165235844"></p>
]]></content>
  </entry>
  <entry>
    <title>SpringBoot——自动配置</title>
    <url>/2022/02/02/SpringBoot%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h4 id="SpringBootApplication流程分析图："><a href="#SpringBootApplication流程分析图：" class="headerlink" title="@SpringBootApplication流程分析图："></a>@SpringBootApplication流程分析图：</h4><p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220203205314823.png" alt="image-20220203205314823"></p>
<p>从MainApplication上的@SpringBootApplication注解出发，在@SpringBootApplication里面有三个注解：</p>
<ul>
<li>其中@ComponentScan是用来包扫描的。</li>
<li>进入@SpringBootConfiguration里面发现它其实也就是对@Configuration进行了一层封装，所以我们的MainApplication其实也是一个配置类。</li>
<li>最后一个@EnableAutoConfiguration，在它里面有两个注解。其中@Import导入了AutoConfigurationImportSelector类，在这个类里面自定义了逻辑并返回需要导入的组件。</li>
</ul>
<h2 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h2><p>在@AutoConfigurationPackage里面，它又用@Import导入了一个Registrar。我们进入这个Registrar，给它打上断点之后debug运行。</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220203211331364.png" alt="image-20220203211331364"></p>
<p>我们计算一下 new PackageImports(metadata).getPackageNames() 的值发现，它就是 com.atqingke.boot 。也就是我们的启动类MainApplication所在的包。</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220203211426427.png" alt="image-20220203211426427"></p>
<p>也就是说，它利用Registrar将指定包下的一系列组件全部导进来，而这个指定的包就是我们的启动类所在的包。</p>
<h2 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import(AutoConfigurationImportSelector.class)"></a>@Import(AutoConfigurationImportSelector.class)</h2><h4 id="流程分析图："><a href="#流程分析图：" class="headerlink" title="流程分析图："></a>流程分析图：</h4><p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220204175821398.png" alt="image-20220204175821398"></p>
<p>在@EnableAutoConfiguration里面，除了有自动配置包，还使用@Import导入了一个ImportSelector。我们知道，@Import可以导入一个实现了ImportSelector接口的类，在这个类中自定义逻辑并且返回需要导入的组件。可以看到，它导入的AutoConfigurationImportSelector中实现了DeferredImportSelector中的selectImports方法。</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220204170452319.png" alt="image-20220204170452319"></p>
<p>可以看到，在这个方法中，首先判断传过来的标注了@Import注解的类的信息，即EnableAutoConfiguration，如果不需要导入组件，就返回空。</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220204170805074.png" alt="image-20220204170805074"></p>
<p>然后，它通过getAutoConfigurationEntry方法，获取要注册的组件。我们进入getAutoConfigurationEntry方法里面：</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220204172827988.png" alt="image-20220204172827988"></p>
<p>可以看到，它通过getCandidateConfigurations方法，来获取所有候选的配置，一共有127个。获取成功之后，再通过一系列操作（去重、排除某些不符合的……），最后将其封装为一个AutoConfigurationEntry返回。</p>
<h4 id="那么这个127是怎么来的呢？"><a href="#那么这个127是怎么来的呢？" class="headerlink" title="那么这个127是怎么来的呢？"></a>那么这个127是怎么来的呢？</h4><p>我们再进入getCandidateConfigurations方法里面，可以看到，它会通过一个Spring的工厂加载器：Map&lt;String, List<String>&gt; loadSpringFactories(@Nullable ClassLoader classLoader)，来得到所有组件。</p>
<p>进入loadSpringFactories里，看它是怎样利用工厂加载器来获取所有组件名字的</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220204174041053.png" alt="image-20220204174041053"></p>
<p>可以看到，类加载器是通过读取META-INF/spring.factories文件，来获取组件名字的。我们去我们引入的Maven依赖中找到这个文件：</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220204174405172.png" alt="image-20220204174405172"></p>
<p>可以看到，在它的这个文件中，已经把SpringBoot一启动要给容器中要加载的所有配置类给写死了。也可以看到，它的Auto Configure是从第21行直到148行共127个要给容器中注册的组件。</p>
<h3 id="按需开启自动配置项"><a href="#按需开启自动配置项" class="headerlink" title="按需开启自动配置项"></a>按需开启自动配置项</h3><p>通过上面我们可以知道，我们的127个场景的所有自动配置（也就是哪些xxxAutoConfiguration）会在启动的时候默认全部加载，但是，这些xxxAutoConfiguration它是会按照@Conditional来按需配置的。</p>
]]></content>
  </entry>
  <entry>
    <title>SpringBoot——底层注解</title>
    <url>/2022/02/02/SpringBoot%E2%80%94%E2%80%94%E5%BA%95%E5%B1%82%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://atqingke.com/index.php/archives/380/">Spring注解驱动开发——组件注册</a></p>
</blockquote>
<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br></pre></td></tr></table></figure>

<p>@Configuration注解里面有个属性proxyBeanMethods，它是用来指明代理bean的方法，分为两种模式：Full模式和Lite模式。</p>
<ul>
<li>proxyBeanMethods = true，即为Full模式，也就是说：SpringBoot会保证每个@Bean方法被调用多少次返回的组件都是单实例的。</li>
<li>proxyBeanMethods = false，即为Lite模式，也就是说：SpringBoot会保证每个@Bean方法被调用多少次返回的组件都是新创建的。</li>
</ul>
<p>关于这两种模式的使用，我们坚持以下规则：</p>
<ol>
<li>如果是配置类组件之间没有依赖关系，我们则使用Lite模式来加速容器启动过程，减少判断。</li>
<li>如果配置类组件之间有依赖关系，我们使用Full模式来让方法调用之前能得到之前的单实例组件。</li>
</ol>
<h2 id="Import、"><a href="#Import、" class="headerlink" title="@Import、"></a>@Import、</h2><h2 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h2><p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220203213003529.png" alt="image-20220203213003529"></p>
<p>参见<a href="https://atqingke.com/index.php/archives/380/">Spring注解驱动开发——组件注册</a></p>
<h2 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h2><p>如果我们要对使用Spring框架的项目进行迁移，我们就需要使用到我们的@ImportResource注解，用于原生配置文件的引入。例如，我们之前在Spring阶段写的配置文件需要导入到当前的SpringBoot项目，只需要在配置类上引入即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ImportResource(&quot;classpath:/beans.xml&quot;)</span></span><br></pre></td></tr></table></figure>

<h2 id="ConfigurationProperties自动绑定"><a href="#ConfigurationProperties自动绑定" class="headerlink" title="@ConfigurationProperties自动绑定"></a>@ConfigurationProperties自动绑定</h2><p>为了将properties文件中的内容读取并封装到我们的JavaBean中，我们可以使用Properties类来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">getProperties</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line">         Properties pps = <span class="keyword">new</span> Properties();</span><br><span class="line">         pps.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.properties&quot;</span>));</span><br><span class="line">         Enumeration enum1 = pps.propertyNames();<span class="comment">//得到配置文件的名字</span></span><br><span class="line">         <span class="keyword">while</span>(enum1.hasMoreElements()) &#123;</span><br><span class="line">             String strKey = (String) enum1.nextElement();</span><br><span class="line">             String strValue = pps.getProperty(strKey);</span><br><span class="line">             System.out.println(strKey + <span class="string">&quot;=&quot;</span> + strValue);</span><br><span class="line">             <span class="comment">//封装到JavaBean。</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>但在SpringBoot中，有更简单的解决方案。</p>
<h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><p>有一个JavaBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一个properties文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">myUser.name</span>=<span class="string">Tom</span></span><br><span class="line"><span class="meta">myUser.age</span>=<span class="string">23</span></span><br></pre></td></tr></table></figure>

<h3 id="方案一：-Component-ConfigurationProperties"><a href="#方案一：-Component-ConfigurationProperties" class="headerlink" title="方案一：@Component + @ConfigurationProperties"></a>方案一：@Component + @ConfigurationProperties</h3><p>首先，要将我们的User加到我们的容器中，使用@ConfigurationProperties注解才有效。</p>
<p>然后，在@ConfigurationProperties中有一个属性prefix，它就是用来指定你在properties文件中的属性前缀的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfgiurationProperties(prefix = &quot;myUser&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123; ...... &#125;</span><br></pre></td></tr></table></figure>

<h3 id="方案二：-EnableConfigurationProperties-ConfigurationProperties"><a href="#方案二：-EnableConfigurationProperties-ConfigurationProperties" class="headerlink" title="方案二：@EnableConfigurationProperties + @ConfigurationProperties"></a>方案二：@EnableConfigurationProperties + @ConfigurationProperties</h3><p>第二种方案是不需要我们显示的把JavaBean注入到容器中，我们在<strong>配置类</strong>里添加一个注解@EnableConfigurationProperties，它会帮我们做这件事。</p>
]]></content>
  </entry>
  <entry>
    <title>Hadoop集群搭建</title>
    <url>/2022/02/01/Hadoop%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>VMWare安装CentOS</title>
    <url>/2022/02/01/VMWare%E5%AE%89%E8%A3%85CentOS/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>nginx——原理及优化参数配置</title>
    <url>/2022/02/01/nginx%E2%80%94%E2%80%94%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>nginx简介</title>
    <url>/2022/02/01/nginx%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Gitee + PicGo实现博客图床</title>
    <url>/2022/01/31/Gitee-PicGo%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h2 id="前置准备："><a href="#前置准备：" class="headerlink" title="前置准备："></a>前置准备：</h2><ul>
<li>Gitee注册账号<a href="https://gitee.com/">Gitee - 基于 Git 的代码托管和研发协作平台</a></li>
<li>PicGo下载安装<a href="https://github.com/Molunerfinn/PicGo/releases">Releases · Molunerfinn/PicGo · GitHub</a></li>
<li>Typora下载安装<a href="https://typora.com.cn/">https://typora.com.cn/</a></li>
</ul>
<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><ul>
<li>Gitee<ol>
<li>新建一个仓库</li>
<li>在个人设置里面找到私人令牌</li>
<li>点击生成新令牌</li>
<li>勾选projects选项</li>
<li>生成令牌</li>
<li>输入账户密码</li>
<li>得到token（自行保存）</li>
</ol>
</li>
<li>PicGo<ol>
<li>安装插件</li>
<li>设置图床</li>
</ol>
</li>
<li>Typora<ol>
<li>修改偏好设置</li>
<li>验证上传</li>
<li>浏览器访问成功</li>
</ol>
</li>
</ul>
<h2 id="Gitee"><a href="#Gitee" class="headerlink" title="Gitee"></a>Gitee</h2><h3 id="1-创建一个仓库"><a href="#1-创建一个仓库" class="headerlink" title="1. 创建一个仓库"></a>1. 创建一个仓库</h3><p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220131175732693.png" alt="image-20220131175732693"></p>
<h3 id="2-获取token"><a href="#2-获取token" class="headerlink" title="2. 获取token"></a>2. 获取token</h3><h4 id="2-1-打开设置"><a href="#2-1-打开设置" class="headerlink" title="2.1 打开设置"></a>2.1 打开设置</h4><p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220131175859414.png" alt="image-20220131175859414"></p>
<h4 id="2-2-找到私人令牌"><a href="#2-2-找到私人令牌" class="headerlink" title="2.2 找到私人令牌"></a>2.2 找到私人令牌</h4><p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220131175934845.png" alt="image-20220131175934845"></p>
<h4 id="2-3-生成新令牌"><a href="#2-3-生成新令牌" class="headerlink" title="2.3 生成新令牌"></a>2.3 生成新令牌</h4><p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220131180002086.png" alt="image-20220131180002086"></p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220131180046401.png" alt="image-20220131180046401"></p>
<h4 id="2-4-输入密码"><a href="#2-4-输入密码" class="headerlink" title="2.4 输入密码"></a>2.4 输入密码</h4><p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220131180122654.png" alt="image-20220131180122654"></p>
<h4 id="2-5-获取到token并自行保存"><a href="#2-5-获取到token并自行保存" class="headerlink" title="2.5 获取到token并自行保存"></a>2.5 获取到token并自行保存</h4><p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220131180212546.png" alt="image-20220131180212546"></p>
<p>自此，Gitee操作完毕，要注意保存好自己的token，在页面上也提示了，当你确认并关闭之后，将获取不到了（如果丢失，重新生成即可）</p>
<h2 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h2><p>打开PicGo，在插件位置搜索gitee，将搜索出来的插件全部安装（如果安装失败，可以尝试安装node环境之后再安装）</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220131180707433.png" alt="image-20220131180707433"></p>
<p>配置图床</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220131181024413.png" alt="image-20220131181024413"></p>
<h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><p>ctrl + 逗号打开偏好设置</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220131181427100.png" alt="image-20220131181427100"></p>
<p>点击验证图片上传选项</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220131181309705.png" alt="image-20220131181309705"></p>
<p>将得到的url地址粘贴至浏览器访问。</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220201084206678.png" alt="image-20220201084206678"></p>
<p>大功告成！！！</p>
]]></content>
  </entry>
  <entry>
    <title>SpringBoot——HelloWorld</title>
    <url>/2022/01/31/SpringBoot%E2%80%94%E2%80%94HelloWorld/</url>
    <content><![CDATA[<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p>创建Maven工程SpringBootHelloWorld，导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atqingke<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SpringBootHelloWorld<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写控制器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.boot.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/1/31 15:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handle01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, Spring Boot 2!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写主启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.boot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/1/31 15:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置访问端口号：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8888</span></span><br></pre></td></tr></table></figure>

<p>运行MainApplication，访问<a href="http://localhost:8888/hello">http://localhost:8888/hello</a></p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220131155441556.png"></p>
<h2 id="依赖管理特性"><a href="#依赖管理特性" class="headerlink" title="依赖管理特性"></a>依赖管理特性</h2><ul>
<li><p><strong>父项目做依赖管理</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 我们引入的SpringBoot父工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在SpringBoot里面它的父工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在它的父工程里面几乎声明了所有开发中常用的依赖版本号，自动版本仲裁机制 --&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>无须关注版本号，自动版本仲裁</strong></p>
<ul>
<li>我们在自己的pom文件里引入依赖，默认可以不用写版本号。</li>
<li>当引入非版本仲裁的jar，才需要写版本号。</li>
</ul>
</li>
<li><p><strong>可以修改默认版本号</strong></p>
<p>如果你需要的依赖的版本已自动仲裁的版本号不对，可以在自己的pom文件里重新写配置。这里以mysql的依赖为例：</p>
<ol>
<li><p>首先查看spring-boot-dependencies里面规定当前依赖的版本时用的key。</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220131160616569.png"></p>
</li>
<li><p>在当前项目里重写配置。</p>
</li>
</ol>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220131160759918.png"></p>
</li>
<li><p><strong>开发导入starter场景启动器</strong></p>
<p>我们在我们的项目中引入的父工程spring-boot-starter-parent，类似于这种spring-boot-starter-*就代表某种场景，只要我们在pom文件里引入了starter，这个常见的所有常规需要的依赖都会自动导入。</p>
<p>SpringBoot所有支持的场景见它的官方文档：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters">https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters</a></p>
<p>而如果我们见到类似于*-spring-boot-starter就表示这是第三方为我们提供额简化开发的场景启动器，例如MyBatis-Plus的starter：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.baomidou/mybatis-plus-boot-starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>而所有的starter最底层都会依赖于我们的spring-boot-starter</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220131184949180.png" alt="image-20220131184949180"></p>
<h2 id="自动配置属性"><a href="#自动配置属性" class="headerlink" title="自动配置属性"></a>自动配置属性</h2><ol>
<li>自动配好Tocat<ul>
<li>引入Tomcat依赖</li>
<li>配置Tomcat</li>
</ul>
</li>
<li>自动配好SpringMVC<ul>
<li>引入SpringMVC全套组件</li>
<li>自动配好SpringMVC常用组件（功能）</li>
</ul>
</li>
<li>自动配好Web常见功能，如：字符编码问题<ul>
<li>SpringBoot帮我们配置好了所有Web开发的常见场景</li>
</ul>
</li>
<li>默认的包结构<ul>
<li>主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来</li>
<li>无需以前的包扫描配置</li>
<li>想要改变扫描路径，@SpringBootApplication(scanBasePackages=”com.atqingke”)<ul>
<li>或者@ComponentScan指定扫描路径</li>
</ul>
</li>
</ul>
</li>
<li>各种配置拥有默认值<ul>
<li>默认配置最终都是映射到某个类上，如：MultipartProperties</li>
<li>配置文件的值最终会绑定每个类上，这个类会在容器中创建对象</li>
</ul>
</li>
<li>按需加载所有自动配置项<ul>
<li>非常多的starter</li>
<li>引入了哪些场景这个场景的自动配置才会开启</li>
<li>SpringBoot所有的自动配置功能都在spring-boot-autoconfigure包里面</li>
</ul>
</li>
<li>…………</li>
</ol>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>【源码】Spring——AOP</title>
    <url>/2022/01/29/%E3%80%90%E6%BA%90%E7%A0%81%E3%80%91Spring%E2%80%94%E2%80%94AOP/</url>
    <content><![CDATA[<p>f</p>
]]></content>
  </entry>
  <entry>
    <title>MyBatis——MBG</title>
    <url>/2022/01/29/MyBatis%E2%80%94%E2%80%94MBG/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>SSM整合</title>
    <url>/2022/01/29/SSM%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>MyBatis——缓存</title>
    <url>/2022/01/29/MyBatis%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>MyBatis——动态SQL</title>
    <url>/2022/01/29/MyBatis%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81SQL/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>MyBatis——SQL映射文件</title>
    <url>/2022/01/29/MyBatis%E2%80%94%E2%80%94SQL%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>MyBatis——全局配置文件</title>
    <url>/2022/01/29/MyBatis%E2%80%94%E2%80%94%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>MyBatis——HelloWorld</title>
    <url>/2022/01/29/MyBatis%E2%80%94%E2%80%94HelloWorld/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Spring注解驱动开发——@Profile实现多环境配置</title>
    <url>/2022/01/29/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94-Profile%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>之前说过，使用@Conditional实现不同环境注册不同bean。那么，我们也可以通过@Profile注解来实现多环境配置。在这里，我们以多数据源为例，并结合了@Value、@PropertySource和EmbeddedValueResolverAware的使用。</p>
<p>首先，我们有三个业务环境：开发、测试、生产，它们分别需要的数据源是A、B、C。</p>
<p>我们将公共的数据源配置抽取到我们的dbConfig.properties中</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">db.user</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">db.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="meta">db.driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<p>然后，就可以在我们的配置类中对这三个环境进行配置了，我们假设，开发环境连向dev数据库、测试环境连向test数据库、生产环境连向product数据库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.EmbeddedValueResolverAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringValueResolver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.beans.PropertyVetoException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:/dbConfig.properties&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfProfile</span> <span class="keyword">implements</span> <span class="title">EmbeddedValueResolverAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;db.user&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String user;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringValueResolver stringValueResolver;</span><br><span class="line">    <span class="keyword">private</span> String driverClass;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Profile(&quot;dev&quot;)</span></span><br><span class="line">    <span class="meta">@Bean(&quot;devDataSource&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSourceDev</span><span class="params">(<span class="meta">@Value(&quot;$&#123;db.password&#125;&quot;)</span> String password)</span> <span class="keyword">throws</span> PropertyVetoException </span>&#123;</span><br><span class="line">        ComboPooledDataSource dataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">        dataSource.setUser(user);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        dataSource.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/dev&quot;</span>);</span><br><span class="line">        dataSource.setDriverClass(driverClass);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Profile(&quot;test&quot;)</span></span><br><span class="line">    <span class="meta">@Bean(&quot;testDataSource&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSourceTest</span><span class="params">(<span class="meta">@Value(&quot;$&#123;db.password&#125;&quot;)</span> String password)</span> <span class="keyword">throws</span> PropertyVetoException </span>&#123;</span><br><span class="line">        ComboPooledDataSource dataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">        dataSource.setUser(user);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        dataSource.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);</span><br><span class="line">        dataSource.setDriverClass(driverClass);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Profile(&quot;pro&quot;)</span></span><br><span class="line">    <span class="meta">@Bean(&quot;proDataSource&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSourcePro</span><span class="params">(<span class="meta">@Value(&quot;$&#123;db.password&#125;&quot;)</span> String password)</span> <span class="keyword">throws</span> PropertyVetoException </span>&#123;</span><br><span class="line">        ComboPooledDataSource dataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">        dataSource.setUser(user);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        dataSource.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/product&quot;</span>);</span><br><span class="line">        dataSource.setDriverClass(driverClass);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmbeddedValueResolver</span><span class="params">(StringValueResolver resolver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stringValueResolver = resolver;</span><br><span class="line">        driverClass = stringValueResolver.resolveStringValue(<span class="string">&quot;$&#123;db.driverClass&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的例子，我们简单总结一下@Profile的作用以及使用：</p>
<ul>
<li>@Profile：指定组件在哪个环境的情况下才能被注册到容器中，不指定，任何环境下都能注册这个组件。</li>
<li>加了环境标识的bean，只有这个环境被激活的时候才能注册到容器中。默认是default环境。</li>
<li>除了写在bean上，还可以写在类上，只有指定环境，整个配置类的所有配置才生效。</li>
<li>没有标注环境标识的bean，在任何环境都生效。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>why 0?</title>
    <url>/2022/01/26/why-0/</url>
    <content><![CDATA[<p>先看三段程序以及它们的运行结果：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220126191927466.png" alt="image-20220126191927466"></p>
<p>我们看到，只有int打印的是正确结果，float和double打印的都是0。Why？</p>
<p>我们知道，int和float都是占4个字节，而double占8个字节。那么，printf按%d输出，也就是将double按4个字节输出是有可能会是0，但为什么float打印的也是0？</p>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>浮点数在计算机的存储有它对应的标准，比如IEEE。IEEE标准规定了一个浮点数的形式应该为$(-1)^n * M * 2^E$  。其中n决定这个是正数还是负数，0表示正数，1表示负数；M叫尾数，一个二进制小数；E叫做阶码，它的所用是对浮点数进行加权，它可能为正也可能是一个负值。我们看一个具体例子，我们要printf的2.5如果转换成IEEE标准的浮点数形式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">十进制： 2.5 -----&gt; 2 * 10的0次方 + 5 * 10的-1次方</span><br><span class="line">二进制： 1.1 -----&gt; 1 * 2的1次方 + 0 * 2的0次方 + 1 * 2的-1次方</span><br><span class="line">得到2.5的二进制1.1，再转换成IEEE标准</span><br><span class="line">首先是正数，n = 0</span><br><span class="line">尾数M = 1.1</span><br><span class="line">阶码E = 1</span><br></pre></td></tr></table></figure>

<p>也就是$(-1)^0 * 1.1 * 2^1$。IEEE标准规定了单精度浮点数占32位，其中第31位是符号位，第30位到23位表示尾数，第22位到第0位表示阶码</p>
]]></content>
  </entry>
  <entry>
    <title>SpringMVC——@RequestMapping映射</title>
    <url>/2022/01/23/SpringMVC%E2%80%94%E2%80%94-RequestMapping%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.bind.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Mapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;</span><br><span class="line"></span><br><span class="line">   String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   RequestMethod[] method() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   String[] params() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   String[] headers() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   String[] consumes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   String[] produces() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RequestMapping映射请求注解"><a href="#RequestMapping映射请求注解" class="headerlink" title="@RequestMapping映射请求注解"></a>@RequestMapping映射请求注解</h2><p>SpringMVC使用@RequestMapping注解为控制器指定可以处理哪些URL请求，从源码中可以看到，在类上和方法定义处都可以标注。它的作用就是为了让DispatcherServlet截获请求后，就通过控制器上@RequestMapping提供的映射信息确定请求所对应的处理方法。</p>
<p>我们在index.jsp中编写我们的测试代码来看看</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;RequestMapping测试&lt;/h1&gt;&lt;br/&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;hello&quot;</span>&gt;写在方法上的RequestMapping&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;hello01&quot;</span>&gt;写在类上的RequestMapping&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">&lt;br/&gt;&lt;br/&gt;</span><br></pre></td></tr></table></figure>

<p>在我们的controller中，我们先不在类上标注@RequestMapping</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="comment">// @RequestMapping(&quot;/ha&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFirstController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">myFirstRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请求收到了...正在处理中&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们启动可以发现，点击访问的是：<a href="http://localhost:8080/SpringMVC_war_exploded/hello">http://localhost:8080/SpringMVC_war_exploded/hello</a></p>
<p><img src="C:/Users/pengbin007/AppData/Roaming/Typora/typora-user-images/image-20220130144836741.png" alt="image-20220130144836741"></p>
<p>而当我们在类上也标注@RequestMapping时会发现，当我们访问的是：<a href="http://localhost:8080/SpringMVC_war_exploded/ha/hello%E6%89%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E6%88%90%E5%8A%9F%EF%BC%8C%E8%80%8C%E7%BB%A7%E7%BB%AD%E8%AE%BF%E9%97%AEhttp://localhost:8080/SpringMVC_war_exploded/hello%E4%BC%9A%E6%8F%90%E7%A4%BA404%E3%80%82">http://localhost:8080/SpringMVC_war_exploded/ha/hello才能访问成功，而继续访问http://localhost:8080/SpringMVC_war_exploded/hello会提示404。</a></p>
<p>简而言之，我们在类上标注的@RequestMapping就相当于我们项目的根目录，而当我们没有在类上指定的时候，方法上的@RequestMapping就是请求的根目录。</p>
<h2 id="RequestMapping映射请求方式"><a href="#RequestMapping映射请求方式" class="headerlink" title="RequestMapping映射请求方式"></a>RequestMapping映射请求方式</h2><p>我们先看一个标准的HTTP请求报头</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220130145331634.png" alt="image-20220130145331634"></p>
<p>@RequestMapping除了可以使用请求URL映射请求外，还可以使用请求方法、请求参数以及请求头映射请求。在源码中我们可以看到，它有value、method、params、headers等属性，它们分别表示请求URL、请求方法、请求参数和请求头的映射条件。</p>
<p>其中，比较重要的是value和method属性，params和headers了解即可。value我们已经使用过了，我们来看method</p>
<h3 id="method"><a href="#method" class="headerlink" title="method"></a>method</h3><p>先在index.jsp中准备好测试页面：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;测试RequestMapping的属性&lt;/h1&gt;&lt;br/&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;ha/handle02&quot;</span>&gt;测试method属性&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;ha/handle03&quot;</span>&gt;测试params属性&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;ha/handle04&quot;</span>&gt;测试headers属性(只能谷歌浏览器打开)&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">&lt;br/&gt;&lt;br/&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/handle02&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handle02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在参数位置指明了method为POST，那么，只有POST请求才能进行访问。因此，当我们点击“测试method属性”的连接，会发现提示405，GET方式不允许。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220130150145762.png" alt="image-20220130150145762"></p>
<p>除了POST，在RequestMethod中还有其它请求方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RequestMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而有了这个请求方式之后，我们就可以实现Rest风格的请求方式了（详情参见）。</p>
<h3 id="params-amp-headers"><a href="#params-amp-headers" class="headerlink" title="params &amp; headers"></a>params &amp; headers</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/handle03&quot;, params=&quot;&#123;&quot;user=admin&quot;, &quot;password&quot;&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handle03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/handle04&quot;, headers=&#123;&quot;User-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handle04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>params：规定请求参数<ul>
<li><pre><code> params和headers都支持简单的表达式：
</code></pre>
</li>
<li><pre><code>     param1：表示请求中必须包含名为param1的请求参数，没带都会404
</code></pre>
</li>
<li><pre><code>     !param：表示请求不能包含名为param1的请求参数
</code></pre>
</li>
<li><pre><code>     param != value1：表示请求包含名为param1的请求参数，但其值不能为value1
</code></pre>
</li>
<li><pre><code>     &#123;&quot;param1 = value1&quot;, &quot;param2&quot;&#125;：请求必须包含param1和param2参数，且param1必须等于value1
</code></pre>
</li>
</ul>
</li>
<li>headers：规定请求头，同params</li>
<li>consumes：只接受内容类型是哪种的请求，规定请求头中的Content-Type</li>
<li>produce：告诉浏览器返回的内容类型是什么，给响应头中加上Content-Type</li>
</ul>
</blockquote>
<p>在我们上面的handle03中就规定了，访问路径中必须包含参数user和password，并且user必须等于admin才能访问成功。在handle04中headers规定了必须使用Chrome浏览器才能访问，而火狐等浏览器无法访问。</p>
<h2 id="RequestMapping支持Ant路径风格"><a href="#RequestMapping支持Ant路径风格" class="headerlink" title="RequestMapping支持Ant路径风格"></a>RequestMapping支持Ant路径风格</h2><p>所谓的RequestMapping支持Ant路径风格就是，我们可以在URL地址上写模糊的通配符，Ant风格资源地址支持3中通配符：</p>
<ol>
<li>?：匹配文件名中的一个字符</li>
<li>*：匹配文件名中任意字符</li>
<li>**：匹配多层路径</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/user/*/createUser</span><br><span class="line">匹配 /user/aaa/createUser、/user/bbb/createUser 等 URL</span><br><span class="line"></span><br><span class="line">/user/**/createUser</span><br><span class="line">匹配 /user/createUser、/user/aaa/bbb/createUser 等 URL</span><br><span class="line"></span><br><span class="line">/user/createUser??</span><br><span class="line">匹配 /user/createUseraa、/user/createUserbb 等 URL</span><br></pre></td></tr></table></figure>

<p>注意，？只匹配一个字符，0个多个都不行。并且，在模糊和精确同时成立的情况下，精确优先。</p>
<h2 id="占位符-PathVariable"><a href="#占位符-PathVariable" class="headerlink" title="占位符@PathVariable"></a>占位符@PathVariable</h2><p>通过使用@PathVariable注解，可以将URL中占位符参数绑定到控制器处理方法的入参中，即将URL中的{xxx}占位符通过@PathVariable(“xxx”)绑定到操作方法的入参中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">pathVariableTest</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;id = &quot;</span> + id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>SpringMVC——Spring整合</title>
    <url>/2022/01/22/SpringMVC%E2%80%94%E2%80%94Spring%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>SpringMVC——异常处理</title>
    <url>/2022/01/22/SpringMVC%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>SpringMVC——国际化</title>
    <url>/2022/01/22/SpringMVC%E2%80%94%E2%80%94%E5%9B%BD%E9%99%85%E5%8C%96/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>SpringMVC——拦截器</title>
    <url>/2022/01/22/SpringMVC%E2%80%94%E2%80%94%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>SpringMVC——数据绑定&amp;数据校验</title>
    <url>/2022/01/22/SpringMVC%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A-%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>SpringMVC——RestfulCRUD</title>
    <url>/2022/01/22/SpringMVC%E2%80%94%E2%80%94RestfulCRUD/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>SpringMVC——视图解析</title>
    <url>/2022/01/22/SpringMVC%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>【源码】SpringMVC——请求处理流程</title>
    <url>/2022/01/22/%E3%80%90%E6%BA%90%E7%A0%81%E3%80%91SpringMVC%E2%80%94%E2%80%94%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>SpringMVC——数据输出</title>
    <url>/2022/01/22/SpringMVC%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<p>f</p>
<p>传入Model、Map、ModelMap</p>
<p>三者关系</p>
<p>方法返回值为ModelAndView</p>
<p>SessionAttributes</p>
<p>全字段更新引发的问题</p>
<p>ModelAttribute解决问题</p>
<p>ModelAttribute原理</p>
]]></content>
  </entry>
  <entry>
    <title>SpringMVC——请求处理</title>
    <url>/2022/01/22/SpringMVC%E2%80%94%E2%80%94%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>f</p>
<p>@RequestParam</p>
<p>@RequestHeader</p>
<p>@CookieValue</p>
<p>传入POJO</p>
<p>传入原生API</p>
<p>乱码解决</p>
]]></content>
  </entry>
  <entry>
    <title>SpringMVC——Helloworld</title>
    <url>/2022/01/22/SpringMVC%E2%80%94%E2%80%94Helloworld/</url>
    <content><![CDATA[<h2 id="SpringMVC概述"><a href="#SpringMVC概述" class="headerlink" title="SpringMVC概述"></a>SpringMVC概述</h2><p>①   Spring 为展现层提供的基于 MVC 设计理念的优秀的 Web 框架，是目前最主流的 MVC 框架之一。</p>
<p>②   Spring3.0 后全面超越 Struts2，成为最优秀的 MVC 框架。</p>
<p>③   Spring MVC 通过一套 MVC 注解，让 POJO 成为处理请求的控制器，而无须实现任何接口。</p>
<p>④   支持 REST 风格的 URL 请求。</p>
<p>⑤   采用了松散耦合可插拔组件结构，比其他 MVC 框架更具扩展性和灵活性。</p>
<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p>新建JavaWeb工程</p>
<h3 id="1、导包"><a href="#1、导包" class="headerlink" title="1、导包"></a>1、导包</h3><p>在Spring的基础上多了一个web包和webmvc包</p>
<p><img src="C:/Users/pengbin007/AppData/Roaming/Typora/typora-user-images/image-20220122173743610.png" alt="image-20220122173743610"></p>
<h3 id="2、写配置"><a href="#2、写配置" class="headerlink" title="2、写配置"></a>2、写配置</h3><p>在web.xml中配置前端控制器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>SpringMVCSource<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 指定程序运行跳转首页 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 前端控制器，所有请求的要经过这里 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springDispatchServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- contextConfigLocation：指定SpringMVC配置文件位置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springDispatchServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>springmvc.xml（src目录下）中开启包扫描配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atqingke&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3、编写页面和controller"><a href="#3、编写页面和controller" class="headerlink" title="3、编写页面和controller"></a>3、编写页面和controller</h3><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: pengbin007</span><br><span class="line">  Date: <span class="number">2022</span>/<span class="number">1</span>/<span class="number">22</span></span><br><span class="line">  Time: <span class="number">17</span>:<span class="number">53</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">成功！！！</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/1/22 17:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/WEB-INF/pages/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、运行"><a href="#4、运行" class="headerlink" title="4、运行"></a>4、运行</h3><p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220122181407453.png" alt="image-20220122181407453"></p>
<p>点击跳转到success.jsp页面</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220122181436214.png" alt="image-20220122181436214"></p>
<h2 id="HelloWorld细节"><a href="#HelloWorld细节" class="headerlink" title="HelloWorld细节"></a>HelloWorld细节</h2><p>SpringMVC的基本思想是：通过一个前端控制器，来控制所有请求，并进行智能派发。这个控制器是一个servlet，我们在web.xml中对它进行配置。</p>
<p>hello请求流程图解：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220123151912197.png" alt="image-20220123151912197"></p>
<h3 id="1、运行流程"><a href="#1、运行流程" class="headerlink" title="1、运行流程"></a>1、运行流程</h3><p> ① 客户端点击链接会发送<a href="http://localhost:8080/SpringMVC_war_exploded/hello">http://localhost:8080/SpringMVC_war_exploded/hello</a></p>
<p> ② 来到Tomcat服务器</p>
<p> ③ SpringMVC的前端控制器收到所有请求</p>
<p> ④ 来看请求地址和@RequestMapping标注的哪个匹配，来找到到底使用哪个类的哪个方法</p>
<p> ⑤ 前端控制器找到了目标处理器类和目标方法，直接利用反射执行目标方法</p>
<p> ⑥ 方法执行完后会有一个返回值，SpringMVC认为这个返回值就是页面地址</p>
<p> ⑦ 拿到方法返回值以后，用视图解析器进行拼串得到完整的页面地址</p>
<p> ⑧ 拿到页面地址，前端控制器帮我们转发页面</p>
<h3 id="2、指定SpringMVC的配置文件位置"><a href="#2、指定SpringMVC的配置文件位置" class="headerlink" title="2、指定SpringMVC的配置文件位置"></a>2、指定SpringMVC的配置文件位置</h3><p>我们可以将我们的配置文件写在src目录下，但是这样需要我们手动的去对它配置，SpringMVC才能扫描到。具体做法是，在servlet标签里配置一个init-param标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- contextConfigLocation：指定SpringMVC配置文件位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果我们没有指定配置文件的位置，会报一个500的服务器错误</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220122181543151.png" alt="image-20220122181543151"></p>
<p>从上面的错误可以看到，它会去WEB-INF目录下找一个springDispatcherServlet-servlet.xml的配置文件，但是我们并没有提供这个文件。因此，如果我们不想在web.xml中指定SpringMVC配置文件位置，我们只需要在WEB-INF目录下新建我们的配置文件。而配置文件的名就是我们配置的前端控制器的name + “-servlet”即“springDispatcherServlet-servlet.xml”。</p>
<h3 id="3、-RequestMapping介绍"><a href="#3、-RequestMapping介绍" class="headerlink" title="3、@RequestMapping介绍"></a>3、@RequestMapping介绍</h3><p>@RequestMapping用于映射请求的名称，类似Structs2中action映射配置的action名称。我们使用@RequestMapping注解来映射请求的URL，而标注了的方法的返回值会通过视图解析器解析为实际的物理视图，对于InternalResourceViewResolver视图解析器，会做如下的解析：</p>
<ul>
<li><p>通过prefix + returnValue + suffix这样的方式得到实际的物理视图，然后做转发操作（/WEB-INF/pages/success.jsp）。</p>
</li>
<li><p>一般我们请求的映射路径和方法名一致，但实际上方法名是可以任意的。</p>
</li>
</ul>
<p>处理请求的方式有如下几种（位于RequestMethod枚举类中）：GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Mapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123; ...... &#125;</span><br></pre></td></tr></table></figure>

<p>而@RequestMapping除了可以标在方法上，还可以标注在类上。例如，如果我们在HelloController上标注@RequestMapping(“/helloController”)，那么我们的hello请求就变成了/helloController/hello。也就是说，请求的URL是由类上的映射 + 方法上的映射。</p>
<h3 id="4、简化controller的返回值"><a href="#4、简化controller的返回值" class="headerlink" title="4、简化controller的返回值"></a>4、简化controller的返回值</h3><p>按照目前的写法，每个请求如果都要返回success或其它页面的话，都需要写它的路径以及后缀名。因此，为了使它看起来更简便，我们可以在我们的配置文件springDispatcherServlet-servlet.xml中注册一个组件InternalResourceViewResolver</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/pages/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>prefix指定相对路径，suffix指定文件后缀名。</p>
<blockquote>
<p>ps：在配置的时候要注意，我们给prefix属性赋值的时候要带上最后的斜杠，否则，请求映射路径就变成了/WEB-INF/pagessuccess.jsp。而很明显，这是一个错误的路径。</p>
</blockquote>
<h3 id="5、url-pattern"><a href="#5、url-pattern" class="headerlink" title="5、url-pattern"></a>5、url-pattern</h3><p>我们在servlet-mapping标签里配置url-pattern来设置SpringMVC要拦截的请求。在这里，虽然我们写“/*”和“/”都是拦截所有请求。但我们并不使用“/ *”，因为“/ *”的范围更大，它还会把“ *.jsp”页面也给拦截掉，而处理“ *.jsp”页面是Tomcat的事情。</p>
]]></content>
  </entry>
  <entry>
    <title>CSS小结(尚硅谷-李立超课程)</title>
    <url>/2022/01/21/CSS%E5%B0%8F%E7%BB%93-%E5%B0%9A%E7%A1%85%E8%B0%B7-%E6%9D%8E%E7%AB%8B%E8%B6%85%E8%AF%BE%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="CSS简介"><a href="#CSS简介" class="headerlink" title="CSS简介"></a>CSS简介</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    第二种方式（内部样式表）</span></span><br><span class="line"><span class="comment">        将样式编写到head中的style标签里</span></span><br><span class="line"><span class="comment">          然后通过CSS的选择器来选中元素并为其设置各种样式</span></span><br><span class="line"><span class="comment">          可以同时为多个标签设置样式，并且修改时只需要修改一处即可全部应用</span></span><br><span class="line"><span class="comment">        内部样式表更加方便对样式进行复用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        问题</span></span><br><span class="line"><span class="comment">          只能对一个网页起作用，它里边的样式不能跨页面进行复用</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;style&gt;</span></span><br><span class="line"><span class="comment">    p &#123;</span></span><br><span class="line"><span class="comment">      color: green;</span></span><br><span class="line"><span class="comment">      font-size: 46px;</span></span><br><span class="line"><span class="comment">    &#125; </span></span><br><span class="line"><span class="comment">  &lt;/style&gt; --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    第三种方式（外部样式表）</span></span><br><span class="line"><span class="comment">      将CSS样式编写到一个外部的CSS文件中</span></span><br><span class="line"><span class="comment">        然后通过link标签来引入外部的CSS文件</span></span><br><span class="line"><span class="comment">      将样式编写到外部的CSS文件中，可以使用到浏览器的缓存机制</span></span><br><span class="line"><span class="comment">        从而加快网页的加载速度，提升用户体验</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./style.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>落霞与孤鹜齐飞，秋水共长天一色<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    网页分成三个部分：</span></span><br><span class="line"><span class="comment">        结构  HTML</span></span><br><span class="line"><span class="comment">        表现  CSS</span></span><br><span class="line"><span class="comment">        行为  JavaScript</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    CSS</span></span><br><span class="line"><span class="comment">        层叠样式表</span></span><br><span class="line"><span class="comment">        网页实际上是一个多层的结构，通过CSS分别为网页的每一个层来设置样式</span></span><br><span class="line"><span class="comment">          而最终我们能看到的只是网页的最上边一层</span></span><br><span class="line"><span class="comment">        总之一句话，CSS用来设置网页中元素的样式</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">      使用CSS来修改元素的样式</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      第一种方式(内联样式，行内样式)</span></span><br><span class="line"><span class="comment">        在标签内部通过style属性来设置元素的样式</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;p style=&quot;color: red; font-size: 60px&quot;&gt;少小离家老大回，乡音无改鬓毛衰&lt;/p&gt;</span></span><br><span class="line"><span class="comment">  &lt;p style=&quot;color: red; font-size: 60px&quot;&gt;今天天气真不错&lt;/p&gt;</span></span><br><span class="line"><span class="comment">  &lt;p style=&quot;color: red; font-size: 60px&quot;&gt;落霞与孤鹜齐飞，秋水共长天一色&lt;/p&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="CSS语法"><a href="#CSS语法" class="headerlink" title="CSS语法"></a>CSS语法</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="comment">/* </span></span></span><br><span class="line"><span class="comment"><span class="css">    CSS基本语法</span></span></span><br><span class="line"><span class="comment"><span class="css">      选择器 声明块</span></span></span><br><span class="line"><span class="comment"><span class="css">        通过选择器可以选中页面中的指定元素</span></span></span><br><span class="line"><span class="comment"><span class="css">          比如 p 的作用就是选中页面中的所有p元素</span></span></span><br><span class="line"><span class="comment"><span class="css">        通过声明块来指定要为元素设置的样式</span></span></span><br><span class="line"><span class="comment"><span class="css">          声明块由一个个的声明组成</span></span></span><br><span class="line"><span class="comment"><span class="css">          声明是一个名值对结构</span></span></span><br><span class="line"><span class="comment"><span class="css">            一个样式名对应一个样式只，名和值之间以 : 连接，以 ; 结尾</span></span></span><br><span class="line"><span class="comment"><span class="css">    */</span></span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-tag">h1</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="常用选择器"><a href="#常用选择器" class="headerlink" title="常用选择器"></a>常用选择器</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="css">        将所有的段落设置为红色</span></span></span><br><span class="line"><span class="comment"><span class="css"></span></span></span><br><span class="line"><span class="comment"><span class="css">        元素选择器</span></span></span><br><span class="line"><span class="comment"><span class="css">          作用：根据标签名来选中指定的元素</span></span></span><br><span class="line"><span class="comment"><span class="css">          语法：标签名&#123;&#125;</span></span></span><br><span class="line"><span class="comment"><span class="css">          例子：p&#123;&#125;、h1&#123;&#125;、div&#123;&#125;</span></span></span><br><span class="line"><span class="comment"><span class="css"></span></span></span><br><span class="line"><span class="comment"><span class="css">        id选择器</span></span></span><br><span class="line"><span class="comment"><span class="css">          作用：根据元素的id属性值选中一个元素</span></span></span><br><span class="line"><span class="comment"><span class="css">          语法：#id属性值&#123;&#125;</span></span></span><br><span class="line"><span class="comment"><span class="css">          例子：#red&#123;&#125;</span></span></span><br><span class="line"><span class="comment"><span class="css"></span></span></span><br><span class="line"><span class="comment"><span class="css">        class是一个标签的属性，它与id类似，不同的是class可以重复使用</span></span></span><br><span class="line"><span class="comment"><span class="css">          可以通过class属性来为属性分组</span></span></span><br><span class="line"><span class="comment"><span class="css">        类选择器</span></span></span><br><span class="line"><span class="comment"><span class="css">          作用：根据元素的class属性值选中一组元素</span></span></span><br><span class="line"><span class="comment"><span class="css">          语法：.class属性值</span></span></span><br><span class="line"><span class="comment"><span class="css"></span></span></span><br><span class="line"><span class="comment"><span class="css">        通配选择器</span></span></span><br><span class="line"><span class="comment"><span class="css">          作用：选中页面中的元素</span></span></span><br><span class="line"><span class="comment"><span class="css">          语法：*&#123;&#125;</span></span></span><br><span class="line"><span class="comment"><span class="css"></span></span></span><br><span class="line"><span class="comment"><span class="css"></span></span></span><br><span class="line"><span class="comment"><span class="css">      */</span></span></span><br><span class="line"><span class="css">      <span class="selector-id">#red</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.blue</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是h1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>111111111111<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;blue&quot;</span>&gt;</span>211111111111<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;blue&quot;</span>&gt;</span>311111111111<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;red&quot;</span>&gt;</span>411111111111<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;red&quot;</span>&gt;</span>511111111111<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>611111111111<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="css">        交集选择器</span></span></span><br><span class="line"><span class="comment"><span class="css">          作用：选中同时复合多个条件的元素</span></span></span><br><span class="line"><span class="comment"><span class="css">          语法：选择器1选择器2选择器n&#123;&#125;</span></span></span><br><span class="line"><span class="comment"><span class="css">          注意点：</span></span></span><br><span class="line"><span class="comment"><span class="css">            交集选择器中如果有元素选择器，必须使用元素选择器开头</span></span></span><br><span class="line"><span class="comment"><span class="css"></span></span></span><br><span class="line"><span class="comment"><span class="css">        选择器分组（并集选择器）</span></span></span><br><span class="line"><span class="comment"><span class="css">          作用：同时选择多个选择器对应的元素</span></span></span><br><span class="line"><span class="comment"><span class="css">          语法：选择器1,选择器2,选择器n&#123;&#125;</span></span></span><br><span class="line"><span class="comment"><span class="css">      */</span></span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.red</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-tag">div</span><span class="selector-class">.red</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">font-size</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span>divdivdiv<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span>pppppp<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="关系选择器"><a href="#关系选择器" class="headerlink" title="关系选择器"></a>关系选择器</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="comment">/* class为box的div的span子元素*/</span></span></span><br><span class="line"><span class="css">      <span class="selector-tag">div</span><span class="selector-class">.box</span> &gt; <span class="selector-tag">span</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="comment">/* div的所有span后代*/</span></span></span><br><span class="line"><span class="css">      <span class="selector-tag">div</span> <span class="selector-tag">span</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">font-size</span>: large;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="css">        选择下一个兄弟：</span></span></span><br><span class="line"><span class="comment"><span class="css">          语法：前一个 + 下一个</span></span></span><br><span class="line"><span class="comment"><span class="css">        选择下面的所有兄弟：</span></span></span><br><span class="line"><span class="comment"><span class="css">          语法：兄 ~ 弟</span></span></span><br><span class="line"><span class="comment"><span class="css">      */</span></span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    父元素：</span></span><br><span class="line"><span class="comment">    子元素：</span></span><br><span class="line"><span class="comment">    祖先元素：</span></span><br><span class="line"><span class="comment">    后代元素：</span></span><br><span class="line"><span class="comment">    兄弟元素：</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="css">      [属性名] 选择含有指定属性的元素</span></span></span><br><span class="line"><span class="comment"><span class="css">      [属性名=属性值]</span></span></span><br><span class="line"><span class="comment"><span class="css">      [属性名^=属性值] 选择属性值以指定值开头的元素</span></span></span><br><span class="line"><span class="comment"><span class="css">      [属性名$=属性值] 选择属性值以指定值结尾的元素</span></span></span><br><span class="line"><span class="comment"><span class="css">      [属性名*=属性值] 选择属性值中含有某值的元素</span></span></span><br><span class="line"><span class="comment"><span class="css">      */</span></span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="css">        伪类（不存在得类，特殊的类）</span></span></span><br><span class="line"><span class="comment"><span class="css">          伪类用来描述一个元素的特殊状态</span></span></span><br><span class="line"><span class="comment"><span class="css">            比如：第一个子元素、被点击的元素、鼠标移入的元素</span></span></span><br><span class="line"><span class="comment"><span class="css">          伪类一般情况下都是使用 : 开头</span></span></span><br><span class="line"><span class="comment"><span class="css">            :first-child  第一个子元素</span></span></span><br><span class="line"><span class="comment"><span class="css">            :last-child   最后一个子元素</span></span></span><br><span class="line"><span class="comment"><span class="css">            :nth-child(n)  选中第n个子元素</span></span></span><br><span class="line"><span class="comment"><span class="css">              特殊值：</span></span></span><br><span class="line"><span class="comment"><span class="css">                n   选中所有</span></span></span><br><span class="line"><span class="comment"><span class="css">                2n 或 even    选中偶数位</span></span></span><br><span class="line"><span class="comment"><span class="css">                2n+1 或 odd  选中奇数位</span></span></span><br><span class="line"><span class="comment"><span class="css">            以上这些伪类都是根据所有的子元素进行排序</span></span></span><br><span class="line"><span class="comment"><span class="css"></span></span></span><br><span class="line"><span class="comment"><span class="css">            :first-of-type</span></span></span><br><span class="line"><span class="comment"><span class="css">            :last-of-type</span></span></span><br><span class="line"><span class="comment"><span class="css">            :nth-of-type(n)</span></span></span><br><span class="line"><span class="comment"><span class="css">            这几个伪类的功能和上述的类似，不同点是他们是在同类型元素中进行排序</span></span></span><br><span class="line"><span class="comment"><span class="css"></span></span></span><br><span class="line"><span class="comment"><span class="css">            :not() 否定伪类</span></span></span><br><span class="line"><span class="comment"><span class="css">              将符合条件的元素从选择器中去除</span></span></span><br><span class="line"><span class="comment"><span class="css">      */</span></span></span><br><span class="line"><span class="css">      <span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>第三个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>第四个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>第五个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="a元素的伪类"><a href="#a元素的伪类" class="headerlink" title="a元素的伪类"></a>a元素的伪类</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="css">        由于隐私的原因，visited这个伪类只能修改链接的颜色</span></span></span><br><span class="line"><span class="comment"><span class="css">      */</span></span></span><br><span class="line"><span class="css">      <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: aquamarine;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="css">        :hover 用来表示鼠标移入的状态</span></span></span><br><span class="line"><span class="comment"><span class="css">        :active 用来表示鼠标点击</span></span></span><br><span class="line"><span class="comment"><span class="css">      */</span></span></span><br><span class="line"><span class="css">      <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: aqua;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: yellowgreen;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.atqingke.com&quot;</span>&gt;</span>访问过的链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.atqingke.com&quot;</span>&gt;</span>没有访问过的链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="css">        伪元素，表示页面中一些特殊的并不真实存在的元素（特殊的位置）</span></span></span><br><span class="line"><span class="comment"><span class="css">          伪元素使用 :: 开头</span></span></span><br><span class="line"><span class="comment"><span class="css"></span></span></span><br><span class="line"><span class="comment"><span class="css">          ::first-letter 表示第一个字母</span></span></span><br><span class="line"><span class="comment"><span class="css">          ::first-line 表示第一行</span></span></span><br><span class="line"><span class="comment"><span class="css">          ::selection 表示选中的内容</span></span></span><br><span class="line"><span class="comment"><span class="css">          ::before 元素的开始</span></span></span><br><span class="line"><span class="comment"><span class="css">          ::after 元素的结束</span></span></span><br><span class="line"><span class="comment"><span class="css">      */</span></span></span><br><span class="line"><span class="css">      <span class="selector-tag">p</span><span class="selector-pseudo">::first-letter</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="css">        <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: aqua;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-tag">p</span><span class="selector-pseudo">::selection</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: yellowgreen;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-tag">p</span><span class="selector-pseudo">::before</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">content</span>: <span class="string">&#x27;aaaa&#x27;</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: burlywood;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-tag">p</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">content</span>: <span class="string">&#x27;fsdddfs&#x27;</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: rebeccapurple;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      Lorem ipsum dolor sit amet, consectetur adipisicing elit. Sint mollitia</span><br><span class="line">      expedita aspernatur quis impedit ipsum quibusdam rerum magnam nam</span><br><span class="line">      perferendis officia culpa, quod nostrum, iure excepturi veritatis</span><br><span class="line">      explicabo! Corrupti, ex? Lorem ipsum dolor sit amet consectetur</span><br><span class="line">      adipisicing elit. Quam tempora velit ducimus molestias assumenda, rem</span><br><span class="line">      accusantium consequuntur praesentium natus adipisci! Doloremque quia</span><br><span class="line">      voluptatibus aliquam, ea officiis quidem explicabo sunt quis. Lorem ipsum</span><br><span class="line">      dolor sit amet consectetur adipisicing elit. Asperiores laudantium</span><br><span class="line">      perspiciatis dolores aliquid, nisi excepturi quas inventore fugiat optio</span><br><span class="line">      expedita et, fuga sed! Cupiditate voluptatem nam ut. Quis, unde rem? Lorem</span><br><span class="line">      ipsum dolor sit amet consectetur adipisicing elit. Ipsa, fugit, porro</span><br><span class="line">      dolor omnis ad quae asperiores molestias magni rem commodi numquam</span><br><span class="line">      perferendis repudiandae voluptas, a facere ducimus? Obcaecati, nulla quae.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="样式的继承"><a href="#样式的继承" class="headerlink" title="样式的继承"></a>样式的继承</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="css">        样式的继承：我们为一个元素设置的样式也会应用到它的后代元素上</span></span></span><br><span class="line"><span class="comment"><span class="css"></span></span></span><br><span class="line"><span class="comment"><span class="css">        继承是发生在祖先后代之间的</span></span></span><br><span class="line"><span class="comment"><span class="css"></span></span></span><br><span class="line"><span class="comment"><span class="css">        继承的设计是为了方便我们的开发，利用继承我们可以将一些通用的样式统一设置到共同的祖先元素上，我们只需设置一次即可让所有的元素都具有该样式</span></span></span><br><span class="line"><span class="comment"><span class="css"></span></span></span><br><span class="line"><span class="comment"><span class="css">        注意：并不是所有的样式都会被继承</span></span></span><br><span class="line"><span class="comment"><span class="css">          比如：背景相关的，布局相关的这些仰卧时就不会被继承</span></span></span><br><span class="line"><span class="comment"><span class="css">      */</span></span></span><br><span class="line"><span class="css">      <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      我是一个p元素</span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是p元素的span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是p元素外的span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="选择器的权重"><a href="#选择器的权重" class="headerlink" title="选择器的权重"></a>选择器的权重</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="css">        样式的冲突</span></span></span><br><span class="line"><span class="comment"><span class="css">          当我们通过不同的选择器，选中相同的元素，并且为相同的样式设置不同的值时，此时就发生了样式的冲突</span></span></span><br><span class="line"><span class="comment"><span class="css"></span></span></span><br><span class="line"><span class="comment"><span class="css">        发生样式冲突时，应用那个样式由选择器的权重（优先级）决定</span></span></span><br><span class="line"><span class="comment"><span class="css"></span></span></span><br><span class="line"><span class="comment"><span class="css">        选择器的权重</span></span></span><br><span class="line"><span class="comment"><span class="css">          内联样式        1000</span></span></span><br><span class="line"><span class="comment"><span class="css">          id选择器        100</span></span></span><br><span class="line"><span class="comment"><span class="css">          类和伪类选择器  10</span></span></span><br><span class="line"><span class="comment"><span class="css">          元素选择器      1</span></span></span><br><span class="line"><span class="comment"><span class="css">          通配选择器      0</span></span></span><br><span class="line"><span class="comment"><span class="css">          继承的样式      没有优先级</span></span></span><br><span class="line"><span class="comment"><span class="css">        </span></span></span><br><span class="line"><span class="comment"><span class="css">        比较优先级时，需要将所有的选择器的优先级进行相加计算，最后优先级越高，则越优先显示（分组选择器是单独计算的）</span></span></span><br><span class="line"><span class="comment"><span class="css">          选择器的累加不会超过其最大的数量级，类选择器再高也不会超过id选择器</span></span></span><br><span class="line"><span class="comment"><span class="css">          如果优先级计算后相同，此时则优先使用靠下的样式</span></span></span><br><span class="line"><span class="comment"><span class="css"></span></span></span><br><span class="line"><span class="comment"><span class="css">        可以在某一个样式的后边添加 !important 则此时该样式会获取到最高的优先级，甚至超过内联样式</span></span></span><br><span class="line"><span class="comment"><span class="css">          注意，在开发中要慎重使用！                                                                                                 </span></span></span><br><span class="line"><span class="comment"><span class="css">      */</span></span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-id">#box1</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: orange;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: yellow;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.red</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span>我是一个div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-tag">html</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">font-size</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="css">      长度单位</span></span></span><br><span class="line"><span class="comment"><span class="css">        像素</span></span></span><br><span class="line"><span class="comment"><span class="css">            屏幕实际上是由一个个的小点点构成的</span></span></span><br><span class="line"><span class="comment"><span class="css">            不同屏幕的像素大小是不同的，像素越小的屏幕显示的效果越清晰</span></span></span><br><span class="line"><span class="comment"><span class="css">            所以同样的200px在不同的设备下显示效果不一样</span></span></span><br><span class="line"><span class="comment"><span class="css"></span></span></span><br><span class="line"><span class="comment"><span class="css">        百分比</span></span></span><br><span class="line"><span class="comment"><span class="css">            也可以将属性值设置为相对于其父元素属性的百分比</span></span></span><br><span class="line"><span class="comment"><span class="css"></span></span></span><br><span class="line"><span class="comment"><span class="css">        em</span></span></span><br><span class="line"><span class="comment"><span class="css">            em是相对于元素的字体大小来计算的</span></span></span><br><span class="line"><span class="comment"><span class="css">            1em = 1font-size</span></span></span><br><span class="line"><span class="comment"><span class="css">            em会根据字体大小的改变而改变</span></span></span><br><span class="line"><span class="comment"><span class="css"></span></span></span><br><span class="line"><span class="comment"><span class="css">        rem</span></span></span><br><span class="line"><span class="comment"><span class="css">            rem是相对于根元素的字体大小来计算的</span></span></span><br><span class="line"><span class="comment"><span class="css">    */</span></span></span><br><span class="line"><span class="css">      <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: orange;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.box2</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: aqua;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.box3</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">font-size</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">10em</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">10em</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: greenyellow;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="css">        颜色单位</span></span></span><br><span class="line"><span class="comment"><span class="css">          在CSS中可以直接使用颜色名来设置各种颜色</span></span></span><br><span class="line"><span class="comment"><span class="css">            比如：red、blue、yellow......</span></span></span><br><span class="line"><span class="comment"><span class="css">            但是在CSS中直接使用颜色名是非常不方便的</span></span></span><br><span class="line"><span class="comment"><span class="css"></span></span></span><br><span class="line"><span class="comment"><span class="css">          RGB值</span></span></span><br><span class="line"><span class="comment"><span class="css">            RGB通过三种颜色的不同浓度来调配出不同的颜色</span></span></span><br><span class="line"><span class="comment"><span class="css">            每一种颜色的范围在0~255</span></span></span><br><span class="line"><span class="comment"><span class="css">            语法：RGB(红色，绿色，蓝色)</span></span></span><br><span class="line"><span class="comment"><span class="css"></span></span></span><br><span class="line"><span class="comment"><span class="css">          RGBA</span></span></span><br><span class="line"><span class="comment"><span class="css">            就是在rgb的基础上增加了一个a表示不透明度</span></span></span><br><span class="line"><span class="comment"><span class="css">            需要四个值，前三个和rgb一样，第四个表示不透明度</span></span></span><br><span class="line"><span class="comment"><span class="css">              1表示完全不透明，0表示完全透明，.5半透明</span></span></span><br><span class="line"><span class="comment"><span class="css"></span></span></span><br><span class="line"><span class="comment"><span class="css">          十六进制的RGB值</span></span></span><br><span class="line"><span class="comment"><span class="css">            语法：#红色绿色蓝色</span></span></span><br><span class="line"><span class="comment"><span class="css">            颜色浓度通过00~ff</span></span></span><br><span class="line"><span class="comment"><span class="css">            如果颜色两位两位重复可以进行简写  #aabbcc  #abc</span></span></span><br><span class="line"><span class="comment"><span class="css"></span></span></span><br><span class="line"><span class="comment"><span class="css">          HSL值 HSLA值</span></span></span><br><span class="line"><span class="comment"><span class="css">            H 色相（0~360）</span></span></span><br><span class="line"><span class="comment"><span class="css">            S 饱和度，颜色的浓度（0-100%）</span></span></span><br><span class="line"><span class="comment"><span class="css">            L 亮度有，颜色的亮度（0-100%）</span></span></span><br><span class="line"><span class="comment"><span class="css">      */</span></span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">123</span>, <span class="number">34</span>, <span class="number">145</span>);</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Spring注解驱动开发——属性赋值&amp;自动装配</title>
    <url>/2022/01/21/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</url>
    <content><![CDATA[<p>在Spring的XML配置文件中，我们可以通过property标签来实现对属性的赋值，那么，我们要如何通过注解给属性赋值呢？</p>
<h2 id="Value属性赋值"><a href="#Value属性赋值" class="headerlink" title="@Value属性赋值"></a>@Value属性赋值</h2><p>在我们的实体类的属性上，标注@Value即可为属性赋值，在@Value里面可以写以下三种类型的值：</p>
<ol>
<li>基本数值</li>
<li>SpEL表达式</li>
<li>${}</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;张三&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;#&#123;20-2&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;person.nickName&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String nickName;</span><br></pre></td></tr></table></figure>

<p>使用${}可以读取我们配置文件中的值，我们在资源目录下新建一个person.properties文件：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220129142046297.png" alt="image-20220129142046297"></p>
<p>然后在我们的配置类中结合@PropertySource注解指明我们要读取的配置文件位置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 使用@PropertySource读取外部配置文件中的k/v保存到运行的环境变量中;加载完外部的配置文件以后使用$&#123;&#125;取出配置文件中的值</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:/person.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfPropertyValue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在测试类中取出我们的person对象和person.nickName：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">this</span>.bean.getBean(Person.class);</span><br><span class="line">    System.out.println(person);</span><br><span class="line"></span><br><span class="line">    Environment environment = bean.getEnvironment();</span><br><span class="line">    String property = environment.getProperty(<span class="string">&quot;person.nickName&quot;</span>);</span><br><span class="line">    System.out.println(property);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220129142338233.png" alt="image-20220129142338233"></p>
<h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>我们知道，Spring利用依赖注入（DI），来完成对IOC容器中各个组件的依赖关系赋值，这就是Spring的自动装配。</p>
<h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p>我们要在controller里面调用service里的方法，又在service里面调用dao的逻辑，固然可以使用@Bean注解在配置类中配置，但不够简洁；也可以直接在controller里面声明一个service，但这获取的并不是容器中的组件。我们可以使用@Autowire注解在一个组件里获取另外的组件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookService bookService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired()</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;BookService&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;bookDao=&quot;</span> + bookDao +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用@Autowire注解可以让Spring通过DI实现对容器中的各个组件的依赖关系赋值，它默认会优先按照类型去容器中找对应的组件，如果找到了就直接赋值；如果容器中有多个这个类型的组件，就再将属性的名称作为组件的id去容器中查找。</p>
<h3 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h3><p>我们可以通过在自动注入的属性上添加一个@Qualifier注解来指定需要装配的组件的id，而不是使用默认的属性名自动装配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Qualifier(&quot;bookDao&quot;)</span></span><br><span class="line">    <span class="meta">@Autowired()</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们在配置类中也注入注入一个bookDao，并且给它的name属性赋值为bookDao2</span></span><br><span class="line"><span class="meta">@Bean(&quot;bookDao2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BookDao <span class="title">bookDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BookDao(<span class="string">&quot;label2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后，我们在测试类中通过BooDao这个类型去获取它的bean实例</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220129154303438.png" alt="image-20220129154303438"></p>
<p>可以看到，虽然我们在service里面BookDao的属性名是bookDao2，但我们使用了@Qualifier注解指定要获取的组件id是bookDao，因此我们获取到的是bookDao，而不是属性名中的bookDao2。</p>
<blockquote>
<p>ps：自动装配默认一定要将属性赋值好，如果没有赋值好，就会报错，但是我们可以通过使用@Autowired(required = false)来告诉Spring，这个组件可以不赋值。这样，如果自动装配能装上就装，如果装不上就赋为null，而不是报错。</p>
</blockquote>
<h3 id="Primary"><a href="#Primary" class="headerlink" title="@Primary"></a>@Primary</h3><p>除了使用@Qualifier来指定需要装配的组件id，也可以使用@Primary来指定Spring进行自动装配的时候，默认使用的首选的bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@Bean(&quot;bookDao2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BookDao <span class="title">bookDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BookDao(<span class="string">&quot;label2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Resource-amp-Inject"><a href="#Resource-amp-Inject" class="headerlink" title="@Resource &amp; @Inject"></a>@Resource &amp; @Inject</h3><p>除了@Autowired，Spring还支持Java规范的注解：@Resource(JSR250)、@Inject(JSR330)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="comment">// @Inject</span></span><br><span class="line"><span class="keyword">private</span> BookDao bookDao;</span><br></pre></td></tr></table></figure>

<p>这两者和Autowired的区别是：</p>
<ul>
<li>@Resource默认按照组件名称装配，而且不支持@Primary和@Autowired(required = false)的功能。</li>
<li>@Inject需要导入javax.inject的包，它和@Autowired功能一样，但是没有@Autowired(required = false)的功能。</li>
</ul>
<h2 id="Autowired位置"><a href="#Autowired位置" class="headerlink" title="@Autowired位置"></a>@Autowired位置</h2><p>目前为止，我们的@Autowired都是标在属性上的，其实除了属性上，还可以标在构造器、方法、方法参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    @Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boss</span><span class="params">(<span class="comment">/*@Autowired*/</span> Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">        System.out.println(<span class="string">&quot;boss的有参构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>构造器要用的组件，都是从容器中获取的（可以自行getBean获取对象进行比对测试）。</p>
<blockquote>
<p>ps：如果只有一个有参构造器，那么这个@Autowired可以省略不写，参数位置的组件还是可以自动从容器中获取的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.car = car;</span><br><span class="line">    System.out.println(<span class="string">&quot;boss的setter&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在Boss的setter上标注了@Autowired，那么，当Spring容器要创建一个boss对象时，就会调用这个setter，完成赋值。并且，我们在方法的参数位置传入了另外一个组件，这个组件它也会从IOC容器中获取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Color <span class="title">color</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Color(car);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以结合@Bean使用，在这里，即使我们没有给Car参数标注@Autowired(当然，也可以标上)，但是@Bean标注的方法创建对象的时候，方法的参数默认也是从IOC容器中获取的。</p>
<h2 id="自定义组件想要使用Spring容器底层的一些组件"><a href="#自定义组件想要使用Spring容器底层的一些组件" class="headerlink" title="自定义组件想要使用Spring容器底层的一些组件"></a>自定义组件想要使用Spring容器底层的一些组件</h2><p>当我们自定义的bean想要获取Spring底层的一些组件的时候，我们可以通过让它实现xxxAware接口的setXxx方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog constructor ......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog postConstruct .......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog preDestroy .....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义组件实现xxxAware，在创建对象的时候，会调用接口规定的方法相关注入组件，而xxxAware的功能都是通过xxxAwareProcessor处理的。</p>
<blockquote>
<p>ps：关于xxxAwareProcessor原理参见<a href="https://atqingke.com/index.php/archives/382/">Spring注解驱动开发——生命周期</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Spring注解驱动开发——生命周期</title>
    <url>/2022/01/21/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>所谓bean的生命周期，指的是bean的创建、初始化和销毁的过程。容器会帮我们管理bean的生命周期，但是我们也可以自定义初始化和销毁方法，容器在进行到当前生命周期的时候调用我们自定义的方法进行初始化和销毁。</p>
<blockquote>
<ul>
<li>构建（对象创建）<ul>
<li>单实例，在容器启动的时候创建对象</li>
<li>多实例，在每次获取的时候创建对象</li>
</ul>
</li>
<li>初始化<ul>
<li>对象创建完成，并赋值好，调用初始化方法</li>
</ul>
</li>
<li>销毁<ul>
<li>单实例，容器关闭的时候</li>
<li>多实例，容器不会管理这个bean，不会调用销毁方法</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="1-Bean注解上指定初始化和销毁方法"><a href="#1-Bean注解上指定初始化和销毁方法" class="headerlink" title="1. @Bean注解上指定初始化和销毁方法"></a>1. @Bean注解上指定初始化和销毁方法</h2><p>首先，我们在bean中准备好我们的初始化和销毁方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;car constructor .......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;car init .......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;car destroy .......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们在@Bean注解上分别指定它们</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atqingke&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfLifeCycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这样，就OK了！</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220126000239407.png" alt="image-20220126000239407"></p>
<h2 id="2-InitializingBean和DisposableBean"><a href="#2-InitializingBean和DisposableBean" class="headerlink" title="2. InitializingBean和DisposableBean"></a>2. InitializingBean和DisposableBean</h2><p>第二种方法是让我们的Bean去实现两个接口InitializingBean和DisposableBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat constructor ......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat destroy .......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat afterPropertiesSet .......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在InitializingBean中定义我们的初始化逻辑，在DisposableBean中定义我们的销毁逻辑。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220126000458484.png" alt="image-20220126000458484"></p>
<h2 id="3-PostConstruct和-PreDestroy"><a href="#3-PostConstruct和-PreDestroy" class="headerlink" title="3. @PostConstruct和@PreDestroy"></a>3. @PostConstruct和@PreDestroy</h2><p>第三种方法是使用JSR250提供的两个注解，也是在实体bean上进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog constructor ......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog postConstruct .......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog preDestroy .....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标注了@PostConstruct的方法会在bean创建完成并且属性赋值好后，来执行；标注了@PreDestroy的方法会在容器销毁bean之前执行。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220126001348449.png" alt="image-20220126001348449"></p>
<h2 id="4-BeanPostProcessor"><a href="#4-BeanPostProcessor" class="headerlink" title="4. BeanPostProcessor"></a>4. BeanPostProcessor</h2><p>第四种方法是自定义一个BeanPostProcessor，BeanPostProcessor也就是我们所说的后置处理器。首先它是一个interface，它会在bean初始化前后进行一些工作。postProcessBeforeInitialization是在初始化之前工作；postProcessAfterInitialization在初始化之后工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean 容器帮我们创建好的实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName bean在容器中的名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postProcessBeforeInitialization\t bean-----&gt;&quot;</span> + bean + <span class="string">&quot;, beanName-----&gt;&quot;</span> + beanName);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postProcessAfterInitialization\t bean-----&gt;&quot;</span> + bean + <span class="string">&quot;, beanName-----&gt;&quot;</span> + beanName);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220126002159246.png" alt="image-20220126002159246"></p>
<h2 id="5-BeanPostProcessor原理"><a href="#5-BeanPostProcessor原理" class="headerlink" title="5. BeanPostProcessor原理"></a>5. BeanPostProcessor原理</h2><p>首先，我们直接给我们的后置处理器中的方法打上断点：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220126004324514.png" alt="image-20220126004324514"></p>
<p>接着我们直接Resume Program跳到我们的postProcessBeforeInitialization断点里面，我们观察我们的调试窗口：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220126004552892.png" alt="image-20220126004552892"></p>
<p>从我们的test01方法开始，先来到AnnotationConfigApplicationContext，在经过一系列方法。可以看到，它首先尝试获取bean，然后再createBean，创建bean完了之后来到initializeBean。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220126005058676.png" alt="image-20220126005058676"></p>
<p>可以看到，在初始化bean里面，真正执行初始化之前会先执行applyBeanPostProcessorsBeforeInitialization，初始化之后再执行applyBeanPostProcessorsAfterInitialization。我们进到applyBeanPostProcessorsBeforeInitialization：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object result = existingBean;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">        result = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它会遍历得到容器中所有的BeanPostProcessor，然后挨个执行postProcessBeforeInitialization。而如果一旦执行结果为null，就跳出循环，不会再往下执行了。</p>
<p>我们再回到我们的initializeBean，你会发现，在执行初始化之前，还会执行一行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br></pre></td></tr></table></figure>

<p>点进这个方法你会发现，它其实就是在初始化之前通过bean的定义为我们的属性赋值。</p>
<p>总结就是：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">populateBean(beanName, mbd, instanceWrapper); <span class="comment">// 执行初始化之前先为属性赋值</span></span><br><span class="line">......;</span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);	 &#123;</span><br><span class="line">	......;	<span class="comment">// 在初始化里面，先执行BeanPostProcessor的BeforeInitialization</span></span><br><span class="line">	wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    ......;	<span class="comment">// 执行完了再执行初始化</span></span><br><span class="line">	invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">	......; <span class="comment">// 初始化之后，执行BeanPostProcessor的AfterInitialization</span></span><br><span class="line">	wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">	......;</span><br><span class="line">&#125;</span><br><span class="line">......;</span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="6-Spring底层对BeanPostProcessor的使用"><a href="#6-Spring底层对BeanPostProcessor的使用" class="headerlink" title="6. Spring底层对BeanPostProcessor的使用"></a>6. Spring底层对BeanPostProcessor的使用</h2><p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220126010653128.png" alt="image-20220126010653128"></p>
<h3 id="ApplicationContextAwareProcessor"><a href="#ApplicationContextAwareProcessor" class="headerlink" title="ApplicationContextAwareProcessor"></a>ApplicationContextAwareProcessor</h3><p>Spring实现了BeanPostProcessor的接口和类有非常多，我们看一个ApplicationContextAwareProcessor，它是Spring提供的供我们的组件获取IOC容器的。要让我们的组件获取IOC容器只要让它实现ApplicationContextAware接口中的setApplicationContext方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog constructor ......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog postConstruct .......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog preDestroy .....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进去ApplicationContextAwareProcessor查看它的实现原理：</p>
<p>1、首先判断我们的组件它是否实现了ApplicationContextAware等接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(<span class="keyword">final</span> Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    AccessControlContext acc = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先判断我们的组件它是否实现了ApplicationContextAware等接口</span></span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (bean <span class="keyword">instanceof</span> EnvironmentAware || bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware ||</span><br><span class="line">         bean <span class="keyword">instanceof</span> ResourceLoaderAware || bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware ||</span><br><span class="line">         bean <span class="keyword">instanceof</span> MessageSourceAware || bean <span class="keyword">instanceof</span> ApplicationContextAware)) &#123;</span><br><span class="line">        acc = <span class="keyword">this</span>.applicationContext.getBeanFactory().getAccessControlContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (acc != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                invokeAwareInterfaces(bean);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, acc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        invokeAwareInterfaces(bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、如果是实现了，调用invokeAwareInterfaces给里面注入值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断属于哪个Aware，再将其转成对应的Aware，最后调用set方法，把IOC容器注入进去，然后我们的组件中就可以收到这个IOC容器了</span></span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</span><br><span class="line">            ((EnvironmentAware) bean).setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</span><br><span class="line">            ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="keyword">this</span>.embeddedValueResolver);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</span><br><span class="line">            ((ResourceLoaderAware) bean).setResourceLoader(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</span><br><span class="line">            ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</span><br><span class="line">            ((MessageSourceAware) bean).setMessageSource(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">            ((ApplicationContextAware) bean).setApplicationContext(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BeanValidationPostProcessor"><a href="#BeanValidationPostProcessor" class="headerlink" title="BeanValidationPostProcessor"></a>BeanValidationPostProcessor</h3><p><img src="C:/Users/pengbin007/AppData/Roaming/Typora/typora-user-images/image-20220126011808802.png" alt="image-20220126011808802"></p>
<p>可以看到，BeanValidationPostProcessor也是利用BeanPostProcessor来实现在初始化前后调用doValidate进行校验。</p>
<h3 id="InitDestroyAnnotationBeanPostProcessor"><a href="#InitDestroyAnnotationBeanPostProcessor" class="headerlink" title="InitDestroyAnnotationBeanPostProcessor"></a>InitDestroyAnnotationBeanPostProcessor</h3><p>用来处理@PostConstruct和@PreDestroy的。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220126012149509.png" alt="image-20220126012149509"></p>
<p>总结，我们的bean赋值、注入其它组件、@Autowired、生命周期注解功能、@Async、xxx很多都是考BeanPostProcessor来完成的。</p>
]]></content>
  </entry>
  <entry>
    <title>Spring注解驱动开发——组件注册</title>
    <url>/2022/01/20/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>@Configuration：声明这是Spring的配置类</li>
<li>@Bean：给容器中注册组件</li>
<li>@ComponentScan：自动扫描配置</li>
<li>@Scope：设置组件作用域</li>
<li>@Lazy：bean懒加载</li>
<li>@Conditional：按照条件注册组件</li>
<li>@Import：给容器快速导入组件</li>
</ul>
</blockquote>
<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123; ...... &#125;</span><br></pre></td></tr></table></figure>

<p>这是注解只能标在类上，通过这个注解告诉Spring这是一个配置类，我们以前在XML配置文件中配置的东西，都可以在这标了这个注解的类里面进行相对应的配置。</p>
<h2 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;23&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这是我们之前在XML中要给容器中注册一个bean需要的配置，现在我们在配置类中通过@Bean注解也可以做到同样的效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">23</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过在一个返回值类型为要注册的组件类型的方法上标注@Bean，给容器中注册一个id为方法名，即”person“的组件。当然，我们也可以为@Bean的value属性赋值，显式的赋予一个bean的id。</p>
<p>我们要测试效果也很简单，以前我们通过ClassPathXmlApplicationContext方法来给容器中注册所有组件，现在我们是使用注解驱动开发，因此我们使用AnnotationConfigApplicationContext方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig.class);</span><br><span class="line">    Person bean = context.getBean(Person.class);</span><br><span class="line">    System.out.println(bean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Person&#123;name=&#x27;张三&#x27;, age=23&#125;</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<h2 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h2><p>我们可以通过ApplicationContext的getBeanDefinitionNames方法来查看所有在容器中注册的组件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig.class);</span><br><span class="line">    String[] definitionNames = context.getBeanDefinitionNames();</span><br><span class="line">    <span class="keyword">for</span> (String name : definitionNames) &#123;</span><br><span class="line">    	System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">一月 21, 2022 4:19:50 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh</span><br><span class="line">信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@6a38e57f: startup date [Fri Jan 21 16:19:50 CST 2022]; root of context hierarchy</span><br><span class="line">一月 21, 2022 4:19:50 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh</span><br><span class="line">信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@78b1cc93: startup date [Fri Jan 21 16:19:50 CST 2022]; root of context hierarchy</span><br><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalRequiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">mainConfig</span><br><span class="line">person</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>可以看到，除了我们在配置类中注册的person还有其它组件，甚至包括我们的配置类。那我们要通过怎样的配置来指定它的扫描规则呢？我们知道，以前通过XML是通过开启component-scan来指定扫描的包的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atqingke&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么，我们的@ComponentScan注解就是来解决这个问题的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Repeatable(ComponentScans.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ComponentScan &#123; ...... &#125;</span><br></pre></td></tr></table></figure>

<p>这个注解可以看到，也是只能标在类上。它有一些属性，其中value属性来配置要扫描的包配置、excludeFilters指定不扫描的包配置以及includeFilters指定要扫描的包配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &#123;&quot;com.atqingke&quot;&#125;,</span></span><br><span class="line"><span class="meta">        excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">            // 不扫描带有@Controller和@Service注解的类</span></span><br><span class="line"><span class="meta">            @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class, Service.class&#125;),</span></span><br><span class="line"><span class="meta">            // 不扫描BookService这个类</span></span><br><span class="line"><span class="meta">            @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes =&#123;BookService.class&#125;),</span></span><br><span class="line"><span class="meta">            // 不扫描符合MyTypeFilter中配置的自定义规则的类</span></span><br><span class="line"><span class="meta">            @ComponentScan.Filter(type = FilterType.CUSTOM, classes =&#123;MyTypeFilter.class&#125;) &#125;,</span></span><br><span class="line"><span class="meta">        includeFilters = &#123;</span></span><br><span class="line"><span class="meta">            // 要扫描带有@Repository注解的类</span></span><br><span class="line"><span class="meta">            @ComponentScan.Filter(type=FilterType.ANNOTATION, classes = &#123;Repository.class&#125;)</span></span><br><span class="line"><span class="meta">        &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig</span> </span>&#123; ...... &#125;</span><br></pre></td></tr></table></figure>

<p>excludeFilters和includeFilters都是需要传入一些Filter过滤规则，一共有五种规则，分别是ANNOTATION（按注解）、ASSIGNABLE_TYPE（按类型）、ASPECTJ（按aspectj）、REGEX（按正则）、CUSTOM（按自定义）。</p>
<p>我们通过自己写一个类MyTypeFilter去实现TypeFilter中的match方法来自定义我们的过滤规则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotationMetadata;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.ClassMetadata;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.classreading.MetadataReader;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.classreading.MetadataReaderFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.filter.TypeFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/1/18 23:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTypeFilter</span> <span class="keyword">implements</span> <span class="title">TypeFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metadataReader 读取到的当前正在扫描的类的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metadataReaderFactory 可以获取到其它任何类信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前类注解的信息</span></span><br><span class="line">        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();</span><br><span class="line">        <span class="comment">// 获取当前正在扫描的类的信息</span></span><br><span class="line">        ClassMetadata classMetadata = metadataReader.getClassMetadata();</span><br><span class="line">        <span class="comment">// 获取当前类资源（类的路径）</span></span><br><span class="line">        Resource resource = metadataReader.getResource();</span><br><span class="line">        String className = classMetadata.getClassName();</span><br><span class="line">        System.out.println(className);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> className.contains(<span class="string">&quot;er&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">com.atqingke.test.IOCTest</span><br><span class="line">com.atqingke.bean.Person</span><br><span class="line">com.atqingke.dao.BookDao	// 标了@Repository</span><br><span class="line">com.atqingke.filter.MyTypeFilter	// 包含er</span><br><span class="line">com.atqingke.service.BookService	// BookService</span><br><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalRequiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">mainConfig</span><br><span class="line">bookDao</span><br><span class="line">person</span><br></pre></td></tr></table></figure>

<h2 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h2><p>我们通过@Bean注解配置的bean默认都是单实例的，我们可以通过@Scope注解来改变组件的作用域：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    @see ConfigurableBeanFactory#SCOPE_PROTOTYPE</span></span><br><span class="line"><span class="comment">    @see ConfigurableBeanFactory#SCOPE_SINGLETON</span></span><br><span class="line"><span class="comment">    @see org.springframework.web.context.WebApplicationContext#SCOPE_REQUEST</span></span><br><span class="line"><span class="comment">    @see org.springframework.web.context.WebApplicationContext#SCOPE_SESSION</span></span><br><span class="line"><span class="comment">    prototype：多实例的</span></span><br><span class="line"><span class="comment">          IOC容器启动并不会去调用方法创建对象放到容器中，而是每次获取的时候才会调用方法创建对象</span></span><br><span class="line"><span class="comment">    singleton：单实例的</span></span><br><span class="line"><span class="comment">          IOC容器启动回调用方法创建对象放到IOC容器中，以后每次获取就是直接从容器(map.get())中拿</span></span><br><span class="line"><span class="comment">    request：同一次请求创建一个实例</span></span><br><span class="line"><span class="comment">	session：同一个session创建一个实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="meta">@Bean(&quot;person&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">&quot;liSi&quot;</span>, <span class="number">24</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lazy"><a href="#Lazy" class="headerlink" title="@Lazy"></a>@Lazy</h2><p>默认配置的bean都是单实例的，因此在容器已启动就会创建对象，我们可以通过@Lazy注解来实现懒加载效果。即容器启动的时候不创建对象，第一次使用（获取）的时候创建并初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="meta">@Bean(&quot;person&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">&quot;liSi&quot;</span>, <span class="number">24</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h2><p>考虑这样一个业务场景，有些组件我们需要在Linux操作系统下注册到容器中，而在Windows操作系统下不需要；反之，有些需要Windows环境而不需要Linux环境。那么要如何才能做到呢？</p>
<p>@Conditional注解就可以解决这个问题，它会按照一定的条件进行判断，满足条件的就给容器中注册bean。例如，我们现在有下面两个bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;bill&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">person01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">&quot;Bill Gates&quot;</span>, <span class="number">23</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(&quot;linus&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">person02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">&quot;linus&quot;</span>, <span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bill需要Windows环境、linus需要Linux环境，那么我们就可以分配在两个bean上加上各自的条件判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Conditional(&#123;WindowsCondition.class&#125;)</span></span><br><span class="line"><span class="meta">@Bean(&quot;bill&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">person01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">&quot;Bill Gates&quot;</span>, <span class="number">23</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Conditional(&#123;LinuxCondition.class&#125;)</span></span><br><span class="line"><span class="meta">@Bean(&quot;linus&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">person02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">&quot;linus&quot;</span>, <span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.condition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Condition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ConditionContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotatedTypeMetadata;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/1/20 14:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinuxCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 判断条件能使用的上下文（环境）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metadata 注释信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        // 能获取到IOC使用的beanFactory</span></span><br><span class="line"><span class="comment">//        ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span></span><br><span class="line"><span class="comment">//        // 获取类加载器</span></span><br><span class="line"><span class="comment">//        ClassLoader classLoader = context.getClassLoader();</span></span><br><span class="line">        <span class="comment">// 获取当前环境信息</span></span><br><span class="line">        Environment environment = context.getEnvironment();</span><br><span class="line"><span class="comment">//        // 获取到bean定义的注册类</span></span><br><span class="line"><span class="comment">//        BeanDefinitionRegistry registry = context.getRegistry();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前操作系统环境</span></span><br><span class="line">        String property = environment.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> property.contains(<span class="string">&quot;Linux&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.condition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Condition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ConditionContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotatedTypeMetadata;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/1/20 14:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowsCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        Environment environment = context.getEnvironment();</span><br><span class="line">        String property = environment.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> !<span class="string">&quot;Windows&quot;</span>.contains(property);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ps：@Conditional也可以标注在类上，这样就对整个配置类都生效。</p>
</blockquote>
<h2 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h2><p>现在，我们要给容器中注册组件有两种方式：</p>
<ul>
<li>包扫描 + 组件注解（局限于我们自己写的类）</li>
<li>@Bean（导入第三方包里面的组件）</li>
</ul>
<p>我们还可以通过@Import注解快速给容器中导入一个组件！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Import &#123; ...... &#125;</span><br></pre></td></tr></table></figure>

<p>这个注解也只能标在类上，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;Color.class, Red.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig2</span> </span>&#123; ...... &#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就给容器中快速导入了Color和Red两个组件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalRequiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">mainConfig2</span><br><span class="line">com.atqingke.bean.Color</span><br><span class="line">com.atqingke.bean.Red</span><br></pre></td></tr></table></figure>

<p>可以看到，注册的组件的id默认就是全类名。</p>
<p>我们也可以通过实现ImportSelector接口来自定义逻辑返回需要导入的组件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.condition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ImportSelector;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotationMetadata;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义逻辑返回需要导入的组件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/1/20 19:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> importingClassMetadata 当前标注<span class="doctag">@Import</span>注解的类的所有注解信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 要导入到容器中的组件全类名，可以返回空数组，但是不能返回null（高版本有优化，可以返回null）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;<span class="string">&quot;com.atqingke.bean.Blue&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;Color.class, Red.class, MyImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig2</span> </span>&#123; ...... &#125;</span><br></pre></td></tr></table></figure>

<p>还可以通过实现ImportBeanDefinitionRegistrar，手动注册bean到容器中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.condition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atqingke.bean.RainBow;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.RootBeanDefinition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ImportBeanDefinitionRegistrar;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotationMetadata;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/1/20 19:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> importingClassMetadata 当前类的注解信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry BeanDefinition注册类</span></span><br><span class="line"><span class="comment">     *                 把所有需要添加到容器中的bean，调用BeanDefinitionRegistry.registerBeanDefinition手动注册进来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> red = registry.containsBeanDefinition(<span class="string">&quot;com.atqingke.bean.Red&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> blue = registry.containsBeanDefinition(<span class="string">&quot;com.atqingke.bean.Blue&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (red &amp;&amp; blue) &#123;</span><br><span class="line">            <span class="comment">// 指定Bean定义信息（Bean类型、Bean作用域......）</span></span><br><span class="line">            RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(RainBow.class);</span><br><span class="line">            <span class="comment">// 注册一个Bean，指定名称</span></span><br><span class="line">            registry.registerBeanDefinition(<span class="string">&quot;rainBow&quot;</span>, beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;Color.class, Red.class, MyImportSelector.class, MyImportBeanDefinitionRegistrar.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig2</span> </span>&#123; ...... &#125;</span><br></pre></td></tr></table></figure>

<p>这是第三种方法使用@Import注解，还有第四种方法——使用Spring提供的FactoryBean（工厂bean）。我们创建一个自定义的FactoryBean，它实现了FactoryBean，泛型就是要注册的组件类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.FactoryBean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个Spring定义的FactoryBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/1/20 20:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Color</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Color对象，这个对象会添加到容器中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Color();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对象类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Color.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true，这个bean是单实例，在容器中保存一份；false，多实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再给配置类中注册上这个ColorFactoryBean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ColorFactoryBean <span class="title">colorFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ColorFactoryBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext bean = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig2.class);</span><br><span class="line">    Object colorFactoryBean = bean.getBean(<span class="string">&quot;colorFactoryBean&quot;</span>);</span><br><span class="line">    System.out.println(colorFactoryBean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">com.atqingke.bean.Color@5ef60048</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>可以看到默认获取到的是工厂bean调用getObject创建的对象，而如果我们要获取工厂bean本身，我们需要给id前面加一个&amp;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext bean = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig2.class);</span><br><span class="line">    <span class="comment">// 获取的是工厂bean帮我们创建的bean</span></span><br><span class="line">    Object colorFactoryBean = bean.getBean(<span class="string">&quot;colorFactoryBean&quot;</span>);</span><br><span class="line">    System.out.println(colorFactoryBean);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取工厂bean本身</span></span><br><span class="line">    Object factoryBean = <span class="keyword">this</span>.bean.getBean(<span class="string">&quot;&amp;colorFactoryBean&quot;</span>);</span><br><span class="line">    System.out.println(factoryBean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">com.atqingke.bean.Color@5ef60048</span><br><span class="line">com.atqingke.bean.ColorFactoryBean@1d548a08</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>HTML小结(尚硅谷-李立超课程)</title>
    <url>/2022/01/15/HTML%E5%B0%8F%E7%BB%93-%E5%B0%9A%E7%A1%85%E8%B0%B7-%E6%9D%8E%E7%AB%8B%E8%B6%85%E8%AF%BE%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><p>在HTML中，有些时候，我们不能直接书写一些特殊符号，比如：多个连续的空格、字母两侧的大于号和小于号。因此，如果我们需要在网页中书写这些特殊的符号，则需要使用HTML中的<strong>实体</strong>（转义字符）。</p>
<p>实体的语法：&amp;实体的名字</p>
<p>eg：&amp;nbsp、&amp;lt、&amp;gt、&amp;copy</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>今天<span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>天气不错！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>a<span class="symbol">&amp;lt;</span>b<span class="symbol">&amp;gt;</span>c<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="symbol">&amp;copy;</span>青稞<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h2><p>meta主要用于设置网页中的一些元数据，元数据不是给用户看的</p>
<ul>
<li>charset指定网页的字符集</li>
<li>name指定的数据的名称</li>
<li>content指定的数据的内容</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;pengbin&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- keywords 表示网站的关键字，可以同时指定多个关键字，关键字之间使用 , 隔开 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;HTML5,前端,CSS3&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- description 用于指定网站的描述,网站的描述会显示在搜索引擎的搜索结果中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;pengbin的网站&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 将页面重定向到另一个网站 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;3;url=https://atqingke.com&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- title标签的内容会作为搜索结果的超链接上的文字显示 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>meta标签<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    在网页中HTML专门用来负责网页的结构</span></span><br><span class="line"><span class="comment">    所以在使用html标签时，应该关注的是标签的语义，而不是它的样式</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    标题标签：</span></span><br><span class="line"><span class="comment">    h1 ~ h6一共有六级标题</span></span><br><span class="line"><span class="comment">    从h1 ~ h6重要性递减，h1最重要，h6最不重要</span></span><br><span class="line"><span class="comment">    h1在网页中的重要性仅次于title标签，一般情况下一个页面中只会有一个h1</span></span><br><span class="line"><span class="comment">    一般情况下标题标签只会使用到h1~h3，h4~h6很少用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    标题标签都是块元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在页面中独占一行的元素称为块元素（block element）</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>二级标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>三级标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>四级标题<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>五级标题<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>六级标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- hgroup标签用来为标题分组，可以将一组相关的标题同时放入到hgroup --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hgroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>回乡偶书二首<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>其一<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hgroup</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    p标签表示页面中的一个段落</span></span><br><span class="line"><span class="comment">    p也是一个块元素</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>在p标签中的内容就表示一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    em标签用于语音语调的一个加重</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在页面中不会独占一行的称为行内元素（inline element）</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">今天天气</span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>真<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">不错！</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- strong表示强调，重要内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">你今天必须要</span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>完成作业<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">！</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- blockquote表示一个长引用 --&gt;</span></span><br><span class="line">鲁迅说：</span><br><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span>这句话我是从来没有说过的<span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- q表示一个短引用 --&gt;</span></span><br><span class="line">子曰<span class="tag">&lt;<span class="name">q</span>&gt;</span>学而时习之，乐呵乐呵！<span class="tag">&lt;/<span class="name">q</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- br标签表示页面中的换行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">今天天气真不错</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>test b<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>test i<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">small</span>&gt;</span>test small<span class="tag">&lt;/<span class="name">small</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    块元素（block element）</span></span><br><span class="line"><span class="comment">    - 在网页中一般通过块元素来对页面进行布局</span></span><br><span class="line"><span class="comment">    行内元素（inline element）</span></span><br><span class="line"><span class="comment">    - 行内元素主要用来包裹文字</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    - 一般情况下会在块元素内放行内元素，而不会在行内元素中放块元素</span></span><br><span class="line"><span class="comment">    - 块元素中基本上什么都能放</span></span><br><span class="line"><span class="comment">    - p元素中不能放任何块元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    浏览器在解析网页时，会自动对网页中不符合规范的内容进行修正</span></span><br><span class="line"><span class="comment">    比如：</span></span><br><span class="line"><span class="comment">    标签写在了根元素的外部</span></span><br><span class="line"><span class="comment">    p元素中嵌套了块元素</span></span><br><span class="line"><span class="comment">    根元素中出现了除head和body以外的子元素</span></span><br><span class="line"><span class="comment">    ......</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 布局标签（结构化语义标签） --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    header  表示网页的头部</span></span><br><span class="line"><span class="comment">    main  表示网页的主体部分(一个页面中只会有一个main)</span></span><br><span class="line"><span class="comment">    footer  表示网页的底部hexohe</span></span><br><span class="line"><span class="comment">    nav 表示网页中的导航</span></span><br><span class="line"><span class="comment">    aside 和主体相关的其它内容（侧边栏）</span></span><br><span class="line"><span class="comment">    article 表示一个独立的文章</span></span><br><span class="line"><span class="comment">    section 表示一个独立的区块，上边的标签都不能表示时使用section</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    div 没有语义，就用来表示一个区块，目前来讲div还是我们主要的布局元素</span></span><br><span class="line"><span class="comment">    span 行内元素，没有任何语义，一般用于在网页中选中文字</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>aa<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span>aa<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span>aa<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span>aa<span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span>aa<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span>aa<span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span>aa<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>aa<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>aa<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    列表（list）</span></span><br><span class="line"><span class="comment">    在html中，列表一共有三种：</span></span><br><span class="line"><span class="comment">    1、有序列表</span></span><br><span class="line"><span class="comment">    2、无序列表</span></span><br><span class="line"><span class="comment">    3、定义列表</span></span><br><span class="line"><span class="comment">    无序列表，使用ul标签</span></span><br><span class="line"><span class="comment">    使用li表示列表项</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    有序列表，使用ol标签</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    定义列表，使用dl标签</span></span><br><span class="line"><span class="comment">    使用dt表示定义内容</span></span><br><span class="line"><span class="comment">    使用dd表示对内容进行解释说明</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    列表之间可以相互嵌套</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>结构<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>表现<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>行为<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>结构<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>表现<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>行为<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>结构<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>结构表示网页的结构，结构用来规定网页中哪里是标题，哪里是段落<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>结构表示网页的结构，结构用来规定网页中哪里是标题，哪里是段落<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>结构表示网页的结构，结构用来规定网页中哪里是标题，哪里是段落<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    超链接可以让我们从一个页面跳转到其它页面或者当前页面的其它位置</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    使用 a 标签来定义超链接</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    超链接是一个行内元素，在a标签中可以嵌套除它自身外的任何元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    属性：</span></span><br><span class="line"><span class="comment">    href：指定跳转的目录路径</span></span><br><span class="line"><span class="comment">    值可以是一个外部网站的地址</span></span><br><span class="line"><span class="comment">    也可以是一个内部页面的地址</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    target属性，用来指定超链接打开的位置</span></span><br><span class="line"><span class="comment">    可选值：</span></span><br><span class="line"><span class="comment">    _self 默认值，在当前页面中打开超链接</span></span><br><span class="line"><span class="comment">    _blank 在一个新的页面打开超链接</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    lorem 自动生成一段英文文字</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;./03.meta标签.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>超链接打开新页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#bottom&quot;</span>&gt;</span>去底部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Lorem ipsum dolor sit amet consectetur adipisicing elit. Tempora accusamus</span><br><span class="line">    nesciunt dolorum inventore veritatis architecto, aspernatur animi optio</span><br><span class="line">    eveniet, quaerat consequatur accusantium natus suscipit eum laborum veniam</span><br><span class="line">    corporis, facere impedit.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在开发中可以使用 # 作为路径的占位符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>这是一个新的超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 可以使用 javascript:; 来作为href的属性，此时点击这个超链接什么也不会发生 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span>&gt;</span>啥也不是<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    可以直接将超链接的href属性设置为#，这样点击超链接以后</span></span><br><span class="line"><span class="comment">    页面不会发生跳转，而是转到当前页面的顶部位置</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    可以跳转到页面的指定位置，只需将href属性设置 #目标元素的id属性值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    id属性（唯一不重复的）</span></span><br><span class="line"><span class="comment">    - 每一个标签都可以添加一个id属性</span></span><br><span class="line"><span class="comment">    - id属性就是元素的唯一标识，同一个页面中不能出现重复的id属性</span></span><br><span class="line"><span class="comment">    - 区分大小写，字母开头，不能数字开头</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;bottom&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>回到顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="图片标签-1"><a href="#图片标签-1" class="headerlink" title="图片标签"></a>图片标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    图片标签用于向当前页面中引入一个外部图片</span></span><br><span class="line"><span class="comment">    使用img标签来引入外部图片，img标签是一个自结束标签</span></span><br><span class="line"><span class="comment">    img这种元素属于替换元素（基于块内和行内元素之间，具有两种元素的特点）</span></span><br><span class="line"><span class="comment">    属性</span></span><br><span class="line"><span class="comment">    src 指定的是外部图片的路径（路径规则和超链接是一样的）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    alt 图片的描述，这个描述默认情况下不显示，有些浏览器会在图片无法加载时显示</span></span><br><span class="line"><span class="comment">    搜索引擎会根据alt中的内容来识别图片</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    width 图片的宽度（单位是像素）</span></span><br><span class="line"><span class="comment">    height 图片的高度</span></span><br><span class="line"><span class="comment">    - 宽度和高度如果只修改了一个，则另一个会等比例缩放</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    注意：</span></span><br><span class="line"><span class="comment">    一般情况在PC端，不建议修改图片的大小，需要多大的图片就裁多大</span></span><br><span class="line"><span class="comment">    但是在移动端，经常需要对图片进行缩放</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    图片的格式：</span></span><br><span class="line"><span class="comment">    jpeg(jpg)</span></span><br><span class="line"><span class="comment">    - 支持的颜色比较丰富，不支持透明效果，不支持动图</span></span><br><span class="line"><span class="comment">    - 一般用来显示照片</span></span><br><span class="line"><span class="comment">    gif</span></span><br><span class="line"><span class="comment">    - 支持的颜色比较少，支持简单透明，支持动图</span></span><br><span class="line"><span class="comment">    - 颜色单一的图片，动图</span></span><br><span class="line"><span class="comment">    png</span></span><br><span class="line"><span class="comment">    - 支持的颜色丰富，支持复杂透明，不支持动图</span></span><br><span class="line"><span class="comment">    - 颜色丰富，复杂透明（专为网页而生）</span></span><br><span class="line"><span class="comment">    webp</span></span><br><span class="line"><span class="comment">    - 这种格式是谷歌新推出的专门表示网页中的图片的一种格式</span></span><br><span class="line"><span class="comment">    - 它具备其它图片格式的所有优点，而且文件还特别小</span></span><br><span class="line"><span class="comment">    - 缺点，兼容性不好</span></span><br><span class="line"><span class="comment">    base64</span></span><br><span class="line"><span class="comment">    - 将图片使用base64进行编码，这样额可以将图片转换为字符，通过字符的形式来引入图片</span></span><br><span class="line"><span class="comment">    - 一般都是一些需要和网页一起加载的图片才会使用base64</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    效果一样，用小的</span></span><br><span class="line"><span class="comment">    效果不一样，用效果好的</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./img/img/1.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;松鼠&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">     <span class="attr">src</span>=<span class="string">&quot;data:image/jpeg;base64,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&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">alt</span>=<span class="string">&quot;钢铁侠&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">width</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">     /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="内联框架"><a href="#内联框架" class="headerlink" title="内联框架"></a>内联框架</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    内联框架，用于向当前页面中引入一个其它页面</span></span><br><span class="line"><span class="comment">    src 指定要引入的网页的路径</span></span><br><span class="line"><span class="comment">    frameborder 指定内联框架的边框</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">&quot;https://www.atqingke.com&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">width</span>=<span class="string">&quot;900&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">height</span>=<span class="string">&quot;600&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">        &gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="音视频"><a href="#音视频" class="headerlink" title="音视频"></a>音视频</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    audio 标签用来向页面中引入一个外部的音频文件的</span></span><br><span class="line"><span class="comment">    音视频文件引入时，默认不允许用户自己控制播放停止</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    controls 是否允许用户控制播放</span></span><br><span class="line"><span class="comment">    autoplay 音频文件是否自动播放</span></span><br><span class="line"><span class="comment">    - 如果设置了autoplay，则音乐在打开页面时自动播放</span></span><br><span class="line"><span class="comment">    - 但是目前来讲大部分浏览器都不会自动对音乐进行播放</span></span><br><span class="line"><span class="comment">    loop 音频是否循环播放</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;audio src=&quot;./source/audio.mp3&quot; controls autoplay&gt;&lt;/audio&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 对不起，您的浏览器不支持播放音频！请升级浏览器！ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;./source/audio.mp3&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;./source/audio.ogg&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">embed</span></span></span><br><span class="line"><span class="tag">           <span class="attr">src</span>=<span class="string">&quot;./source/audio.mp3&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">type</span>=<span class="string">&quot;audio/mp3&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">width</span>=<span class="string">&quot;500&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">height</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">           /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;./source/flower.webm&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;./source/flower.mp4&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">&quot;./source/flower.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Swagger</title>
    <url>/2022/01/14/Swagger/</url>
    <content><![CDATA[<h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><p>Swagger是一款RESTful接口的文档在线自动生成、功能测试功能框架。一个规范和完整的框架，用于生成、描述、调用和可视化RESTful风格的Web服务，加上swagger-ui，可以有很好的呈现。</p>
<p>当我们在后台的接口修改了后，swagger可以实现自动的更新，而不需要人为的维护这个接口进行测试。</p>
<ul>
<li>号称世界上最流行的Api框架</li>
<li>RestFul Api文档在线自动生成工具=&gt;Api文档与API定义同步更新</li>
<li>直接运行，可以在线测试API接口</li>
<li>支持多种语言</li>
</ul>
<p>官网：<a href="https://swagger.io/">https://swagger.io/</a></p>
<h1 id="SpringBoot集成Swagger"><a href="#SpringBoot集成Swagger" class="headerlink" title="SpringBoot集成Swagger"></a>SpringBoot集成Swagger</h1><p>新建一个SpringBoot项目</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220115150824442.png" alt="image-20220115150824442"></p>
<p>使用Swagger需要Web环境，我们勾选Spring Web</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220115151013167.png" alt="image-20220115151013167"></p>
<p>要把Swagger集成到我们的SpringBoot项目，还需要下面两个依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>springfox-swagger2依赖主要是一些核心配置以及功能模块，springfox-swagger-ui依赖主要用于前端页面视图显示。</p>
<p>下面我们在项目中进行最简单的Swagger配置，首先我们编写一个HelloWorld的controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.swagger.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/1/15 15:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello Swagger!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在进行Swagger的配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.swagger.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/1/15 15:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 开启Swagger功能</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ps：要注意的是，你选的SpringBoot版本要和Swagger版本要适配（否则启动报错），本例以SpringBoot-2.3.4.RELEASE和Swagger-2.9.2</p>
</blockquote>
<p>启动项目，就可以访问了。但是，如果我们以<a href="http://localhost:8080/%E5%8E%BB%E8%AE%BF%E9%97%AE%EF%BC%8C%E8%82%AF%E5%AE%9A%E6%98%AF404%E7%9A%84%E3%80%82%E5%9B%A0%E4%B8%BA%E6%88%91%E4%BB%AC%E4%B9%8B%E7%BC%96%E5%86%99%E4%BA%86%E4%B8%80%E4%B8%AAcontrolle%E5%92%8C%E4%B8%80%E4%B8%AASwagger%E9%85%8D%E7%BD%AE%E7%B1%BB%EF%BC%8C%E5%B9%B6%E6%B2%A1%E6%9C%89%E5%86%99%E8%B7%B3%E8%BD%AC%E9%A1%B5%E9%9D%A2%E3%80%82">http://localhost:8080/去访问，肯定是404的。因为我们之编写了一个controlle和一个Swagger配置类，并没有写跳转页面。</a></p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220115160210736.png" alt="image-20220115160210736"></p>
<p>之前引入依赖的时候讲了，Swagger它自己有一个前端视图依赖springfox-swagger-ui。我们打开这个依赖进行查看，发现在其资源根目录下一个swagger-ui.html页面：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220115160516036.png" alt="image-20220115160516036"></p>
<p>因此，我们可以试着访问一下<a href="http://localhost:8080/swagger-ui.html%EF%BC%8C%E9%82%A3%E4%B9%88%E6%88%91%E4%BB%AC%E6%9D%A5%E5%88%B0%E5%A6%82%E4%B8%8B%E9%A1%B5%E9%9D%A2%EF%BC%8C%E6%95%B4%E4%B8%AA%E9%A1%B5%E9%9D%A2%E5%88%86%E6%88%90%E5%9B%9B%E9%83%A8%E5%88%86%E3%80%82">http://localhost:8080/swagger-ui.html，那么我们来到如下页面，整个页面分成四部分。</a></p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220115160753036.png" alt="image-20220115160753036"></p>
<h1 id="配置Swagger信息"><a href="#配置Swagger信息" class="headerlink" title="配置Swagger信息"></a>配置Swagger信息</h1><p>Swagger实例bean是Docket，因此我们通过配置Docket来配置Swagger。在Docket里面，只有一个有参构造器，需要传入一个DocumentationType。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220115161634305.png" alt="image-20220115161634305"></p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220115161711456.png" alt="image-20220115161711456"></p>
<p>我们使用的Swagger2，因此传入DocumentationType.SWAGGER_2。</p>
<p>在Docket里面有一个方法apiInfo：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220115161808556.png" alt="image-20220115161808556"></p>
<p>它就是用来配置属性文档信息的，我们可以通过链式调用来使用它。</p>
<p>apiInfo方法需要传入一个ApiInfo对象，我们可以在配置类中编写一个方法返回一个ApiInfo对象（通用做法）。</p>
<p>查看ApiInfo源码</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220115162131918.png" alt="image-20220115162131918"></p>
<p>属性含义分别为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 版本</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String version;</span><br><span class="line"><span class="comment">// 标题</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String title;</span><br><span class="line"><span class="comment">// 描述</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String description;</span><br><span class="line"><span class="comment">// 组织链接</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String termsOfServiceUrl;</span><br><span class="line"><span class="comment">// 许可证</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String license;</span><br><span class="line"><span class="comment">// 许可链接</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String licenseUrl;</span><br><span class="line"><span class="comment">// 联系人信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Contact contact;</span><br><span class="line"><span class="comment">// 扩展</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;VendorExtension&gt; vendorExtensions;</span><br></pre></td></tr></table></figure>

<p>查看它的源码你会发现，它只有一个全参构造器，并且只有getter没有setter，因此我们在返回这个对象的时候需要把所有属性都附上值。其中比较特殊的是联系人信息，我们查看Contact源码，它只有三个属性name、url和email，并且它和ApiInfo一样，只有全参构造器和getter。</p>
<p>这是，我们的SwaggerConfig如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.swagger.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Contact;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/1/15 15:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">helloDocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).apiInfo(helloInfo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">helloInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Contact contact = <span class="keyword">new</span> Contact(<span class="string">&quot;pengbin&quot;</span>, <span class="string">&quot;https://www.atqingke.com&quot;</span>, <span class="string">&quot;pengbin2367@163.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfo(</span><br><span class="line">                <span class="string">&quot;Swagger学习&quot;</span>,</span><br><span class="line">                <span class="string">&quot;学习演示如何配置Swagger&quot;</span>,</span><br><span class="line">                <span class="string">&quot;v1.0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;https://www.atqingke.com&quot;</span>,</span><br><span class="line">                contact,</span><br><span class="line">                <span class="string">&quot;Apach 2.0 许可&quot;</span>,</span><br><span class="line">                <span class="string">&quot;http://www.apache.org/licenses/LICENSE-2.0&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> ArrayList&lt;&gt;()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是，我们重启项目，就看到下图效果了！</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220115163425802.png" alt="image-20220115163425802"></p>
<h1 id="配置扫描接口"><a href="#配置扫描接口" class="headerlink" title="配置扫描接口"></a>配置扫描接口</h1><p>在上面的效果图可以看到两个controller，但是我们只写了一个controller，另一个则是Swagger自带的controller。那么如何配置可以让它只显示我们想要的东西。在Docket里面有一个select方法，它就是Swagger提供的用来配置如何去扫描接口。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220115172528171.png" alt="image-20220115172528171"></p>
<p>select方法返回一个ApiSelectorBuilder，我们进入它的源码：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220115173145856.png" alt="image-20220115173145856"></p>
<h2 id="apis"><a href="#apis" class="headerlink" title="apis"></a>apis</h2><p>在这里，我们先使用我们apis方法，它需要传入一个RequestHandler，我们使用我们点上select，在点上apis，让它只扫描com.atqingke包下的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">helloDocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">        .apiInfo(helloInfo())</span><br><span class="line">        .select()</span><br><span class="line">        .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.atqingke&quot;</span>))</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220115174546701.png" alt="image-20220115174546701"></p>
<p>除了basePackage以外，RequestHandlerSelectors还有其它方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扫描所有</span></span><br><span class="line">any()</span><br><span class="line"><span class="comment">// 不扫描接口</span></span><br><span class="line">none()</span><br><span class="line"><span class="comment">// 通过方法上的注解扫描，如：只扫描get请求</span></span><br><span class="line">withMethodAnnotation(GetMapping.class)</span><br><span class="line"><span class="comment">// 通过类上的注解扫描，如：只扫描有@Controller的类</span></span><br><span class="line">withClassAnnotation(Controller.class)</span><br></pre></td></tr></table></figure>

<h2 id="paths"><a href="#paths" class="headerlink" title="paths"></a>paths</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">helloDocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">        .apiInfo(helloInfo())</span><br><span class="line">        .select()</span><br><span class="line">        .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.atqingke&quot;</span>))</span><br><span class="line">        <span class="comment">// 只扫描以 /hello 开头的请求</span></span><br><span class="line">        .paths(PathSelectors.ant(<span class="string">&quot;/hello/**&quot;</span>))</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通用的，除了ant也有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扫描所有</span></span><br><span class="line">any()</span><br><span class="line"><span class="comment">// 不扫描接口</span></span><br><span class="line">none()</span><br><span class="line"><span class="comment">// 通过正则表达式控制</span></span><br><span class="line">regex(<span class="keyword">final</span> String pathRegex)</span><br></pre></td></tr></table></figure>

<h1 id="配置Swagger开关"><a href="#配置Swagger开关" class="headerlink" title="配置Swagger开关"></a>配置Swagger开关</h1><p>我们可以通过Swagger提供的配置，来实现一键开关Swagger。当我们关掉之后，从浏览器中将访问不到了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">helloDocket</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到当前环境，如果是dev或者test环境，就启用Swagger</span></span><br><span class="line">    Profiles profiles = Profiles.of(<span class="string">&quot;dev&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">boolean</span> flag = environment.acceptsProfiles(profiles);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">        .apiInfo(helloInfo())</span><br><span class="line">        <span class="comment">// enable()是否开启Swagger</span></span><br><span class="line">        .enable(flag)</span><br><span class="line">        .select()</span><br><span class="line">        .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.atqingke&quot;</span>))</span><br><span class="line">        .paths(PathSelectors.ant(<span class="string">&quot;/hello/**&quot;</span>))</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Profiles会从我们在application.properties中读取：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure>

<p>当然，这只是一种方法，还可以通过在类上添加一个注解实现同样的效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name=&quot;swagger.enable&quot;, havingValue=&quot;true&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>这是就要在application.properties中这样配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">swagger.enable</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<h1 id="配置Swagger分组"><a href="#配置Swagger分组" class="headerlink" title="配置Swagger分组"></a>配置Swagger分组</h1><p>要配置多个分组，只需要有多个Docket即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">testDocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">        .groupName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">pengbinDocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">        .groupName(<span class="string">&quot;pengbin&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">helloDocket</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到当前环境，如果是dev或者test环境，就启用Swagger</span></span><br><span class="line">    Profiles profiles = Profiles.of(<span class="string">&quot;dev&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">boolean</span> flag = environment.acceptsProfiles(profiles);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">        .groupName(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">        .apiInfo(helloInfo())</span><br><span class="line">        .enable(flag)</span><br><span class="line">        .select()</span><br><span class="line">        .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.atqingke&quot;</span>))</span><br><span class="line">        .paths(PathSelectors.ant(<span class="string">&quot;/hello/**&quot;</span>))</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220115213014665.png" alt="image-20220115213014665"></p>
<p>在每个分组里面可以有各自的Swagger配置！</p>
<h1 id="Swagger常用注解"><a href="#Swagger常用注解" class="headerlink" title="Swagger常用注解"></a>Swagger常用注解</h1><table>
<thead>
<tr>
<th>作用范围</th>
<th>API</th>
<th>使用位置</th>
</tr>
</thead>
<tbody><tr>
<td>对象属性</td>
<td>@ApiModelProperty</td>
<td>用于出入参数对象的字段上</td>
</tr>
<tr>
<td>协议集描述</td>
<td>@Api</td>
<td>用于controller类上</td>
</tr>
<tr>
<td>协议描述</td>
<td>@ApiOperation</td>
<td>用于controller方法上</td>
</tr>
<tr>
<td>Response集</td>
<td>@ApiResponses</td>
<td>用于controller方法上</td>
</tr>
<tr>
<td>Response</td>
<td>@ApiResponse</td>
<td>用于@ApiResponse里面</td>
</tr>
<tr>
<td>非对象参数集</td>
<td>@ApiImplicitParams</td>
<td>用于controller方法上</td>
</tr>
<tr>
<td>非对象参数描述</td>
<td>@ApiImplicitParam</td>
<td>用于@ApiImplicitParams的方法里面</td>
</tr>
<tr>
<td>描述返回对象的含义</td>
<td>@ApiModel</td>
<td>用于返回对象类上</td>
</tr>
</tbody></table>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>给Swagger换件衣服。</p>
<h3 id="bootstrap-ui"><a href="#bootstrap-ui" class="headerlink" title="bootstrap-ui"></a>bootstrap-ui</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入swagger-bootstrap-ui包 /doc.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-bootstrap-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220115215331053.png" alt="image-20220115215331053"></p>
<h3 id="mg-ui"><a href="#mg-ui" class="headerlink" title="mg-ui"></a>mg-ui</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入swagger-mg-ui包 /document.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zyplayer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-mg-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220115215250711.png" alt="image-20220115215250711"></p>
]]></content>
  </entry>
  <entry>
    <title>爬虫下载网易云热歌</title>
    <url>/2022/01/13/%E7%88%AC%E8%99%AB%E4%B8%8B%E8%BD%BD%E7%BD%91%E6%98%93%E4%BA%91%E7%83%AD%E6%AD%8C/</url>
    <content><![CDATA[<blockquote>
<p>声明：本次示例仅作技术交流！！！</p>
<p>time：2022-1-12</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pip install requests</span></span><br><span class="line"><span class="comment"># 数据请求模块</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment"># 正则表达式</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment"># 操作系统</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;music\\&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果当前目录下有这个文件夹，就不创建；否则创建</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(filename):</span><br><span class="line">    os.mkdir(filename)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 网易云热歌榜url</span></span><br><span class="line">url = <span class="string">&quot;https://music.163.com/discover/toplist?id=3778678&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟浏览器向服务器发送请求，获取资源</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取服务器响应</span></span><br><span class="line">response = requests.get(url=url, headers=headers)</span><br><span class="line"><span class="comment"># print(response.text)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用正则匹配筛选获取到的资源</span></span><br><span class="line">html_data = re.findall(<span class="string">&#x27;&lt;li&gt;&lt;a href=&quot;/song\?id=(\d+)&quot;&gt;(.*?)&lt;/a&gt;&#x27;</span>, response.text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环遍历将每首歌下载</span></span><br><span class="line"><span class="keyword">for</span> num_id, title <span class="keyword">in</span> html_data:</span><br><span class="line">    music_url = <span class="string">f&#x27;http://music.163.com/song/media/outer/url?id=<span class="subst">&#123;num_id&#125;</span>.mp3&#x27;</span></span><br><span class="line">    music_content = requests.get(url=music_url, headers=headers).content</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename + title + <span class="string">&#x27;.mp3&#x27;</span>, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(music_content)</span><br><span class="line">    <span class="built_in">print</span>(num_id, title)</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>网络边缘</title>
    <url>/2022/01/07/%E7%BD%91%E7%BB%9C%E8%BE%B9%E7%BC%98/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>文件传输协议——FTP</title>
    <url>/2022/01/07/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E2%80%94%E2%80%94FTP/</url>
    <content><![CDATA[<p>在一个典型的FTP会话中，用户坐在一台主机前面，向一台远程主机传输文件。为使用户能访问它的远程账户，用户必须提供一个用户标识和口令。在提供了这种授权信息后，用户就能从本地文件系统向远程主机文件系统传送文件，反之亦然。</p>
<p>如图所示，用户通过一个FTP用户代理与FTP交互。该用户首先提供远程主机的主机名，使本地主机的FTP客户进程建立一个到远程主机FTP服务器进程的TCP连接。该用户接着提供用户标识和口令，作为FTP命令的一部分在该TCP连接上传送。一旦该服务器向该用户授权，用户可以将存放在本地文件系统中的一个或者多个文件复制到远程文件系统（反之亦然）。</p>
<p><img src="C:/Users/pengbin007/AppData/Roaming/Typora/typora-user-images/image-20220107170948054.png" alt="image-20220107170948054"></p>
<p>HTTP和FTP都是文件传输协议，并且有很多共同的特点，例如，它们都运行在TCP上。然而，这两个应用层协议也有一些重要的区别。其中最显著的就是FTP使用了两个并行的TCP连接来传输文件，一个是控制连接（control connection），一个是数据连接（data connection）。</p>
<p>控制连接用于在两主机之间传输控制信息，如用户标识、口令、改变远程目录的命令以及“存放（put）”和“获取（get）”文件的命令。数据连接用于实际发送一个文件。因为FTP协议使用了一个独立的控制连接，所以我们也称FTP的控制信息是带外（out-of-band）传送的。而HTTP协议是在传输文件的同一个TCP连接中发送请求和响应首部行的。因此，HTTP也可以说是带内（in-band）发送控制信息的。FTP协议控制连接和数据连接如图所示。</p>
<p><img src="C:/Users/pengbin007/AppData/Roaming/Typora/typora-user-images/image-20220107170217442.png" alt="image-20220107170217442"></p>
<p>在同一个会话期间，如果用户还需要传输另一个文件，FTP则打开另一个数据连接。因而对FTP传输而言，控制连接贯穿了整个用户会话期间，但是对会话中的每一次文件传输都需要建立一个新的数据连接（即数据连接是非持续的）。</p>
<p>FTP服务器必须在整个会话期间保留用户的状态（state）。特别是，服务器必须把特定的用户账户与控制连接联系起来，随着用户在远程目录树上徘徊，服务器必须追踪用户在远程目录树上的当前位置。对每个进行中的用户会话的状态信息进行追踪，大大限制了FTP同时维持的会话总数。而另一方面，前面讲过FTP是无状态的，即它不必对任何用户状态进行追踪。</p>
<h1 id="FTP命令和回答"><a href="#FTP命令和回答" class="headerlink" title="FTP命令和回答"></a>FTP命令和回答</h1><p>从客户到服务器的命令和从服务器到客户的回答，都是以7比特ASCII格式在控制连接上传送的。因此，与HTTP协议的命令类似，FTP协议的命令也是人可读的。为了区分连续的命令，每个命令后跟回车换行符。每个命令由4个大写字母ASCII字符组成，有些还具有可选参数。一些较为常见的命令如下：</p>
<ul>
<li>USER username：用户向服务器传送用户标识。</li>
<li>PASS password：用于向服务器发送用户口令。</li>
<li>LIST：用于请求服务器回送当前远程目录中的所有文件列表。该文件列表是通过一个数据连接传送的，而不是在控制TCP连接上传送。</li>
<li>RETR filename：用于从远程主机当前目录检索（即get）文件。该命令引起远程主机发起一个数据连接，并经该数据连接发送所请求的文件。</li>
<li>STOR filename：用于在远程主机的当前目录上存放（即put）文件。</li>
</ul>
<p>贯穿控制连接，在用户发出的命令和FTP发送的命令之间通常有一一对应关系。每个命令都对应这一个从服务器发向客户的回答。回答是一个3位的数字，后跟一个可选信息。这与HTTP响应报文状态行的状态码和状态信息的结构相同。一些典型的回答连同它们可能的报文如下所示：</p>
<ul>
<li>331 Username OK，Password required（用户名OK，需要口令）。</li>
<li>125 Data connection already open；transfer starting（数据连接已经打开，开始传送）。</li>
<li>425 Can’t open data connection（无法打开数据连接）。</li>
<li>452 Error writing file（写文件差错）。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>OS</title>
    <url>/2022/01/03/OS/</url>
    <content><![CDATA[<h1 id="1-操作系统概述"><a href="#1-操作系统概述" class="headerlink" title="1. 操作系统概述"></a>1. 操作系统概述</h1><ol>
<li>虚拟存储器是用“时间”来换取“空间”的。</li>
<li>设计实时操作系统必须首先考虑系统的可靠性。</li>
<li>一个作业第一次执行时用来5分钟，而第二次执行时用来6分钟，这说明了操作系统的不确定性特点。</li>
<li>分布式操作系统一定是由多台计算机组成的系统。</li>
<li>缓冲技术采用了以“空间”换“时间”的技术。</li>
<li>按照所起的作用和需要的运行环境，操作系统属于系统软件。</li>
<li>操作系统的主要功能是内存管理、设备管理、文件管理、用户接口和进程管理。</li>
<li>操作系统的最基本的两个特征是资源共享和程序的并发性。</li>
<li>采用多道程序设计技术可以提高CPU和外部设备的利用率。</li>
<li>在计算机系统中，操作系统是处于裸机之上的第一层软件。</li>
<li>操作系统是对计算机资源进行管理的软件。</li>
<li>从用户的观点，操作系统是扩充裸机功能的软件，是比裸机功能更强、使用更方便的虚拟机。</li>
<li>操作系统的基本类型是实时系统、分时系统和批处理系统。</li>
<li>使系统中的用户得到及时的响应，操作系统应该是实时系统。</li>
<li>如果分时系统的时间片一定，那么用户数越多会使响应时间越长。</li>
<li>分时系统允许一台主机上同时连接多台终端，多个用户可以通过多台终端同时交互地使用计算机。</li>
<li>批处理系统允许用户把多个作业同时提交给计算机，而无须与计算机进行交互。</li>
<li>在实时系统的控制下计算机系统能及时处理由过程控制反馈的数据并做出及时响应。</li>
<li>一个计算机系统采用多道程序设计技术后，使多道程序实现了宏观上并行。</li>
<li>用户程序要将一个字符送到显示器上显示，要使用操作系统提供的系统调用。</li>
<li>分布式系统相比于网络操作系统，具有的特点是多机合作、健壮性、透明性。</li>
<li>嵌入式系统的特点是需要专用开发工具和方法进行设计、是技术密集、资金密集、高度分散、不断创新的知识集成系统、通常由是向特定任务的，而不同于一般通用PC计算平台，是“专用”的计算机系统。</li>
<li>计算机系统是由硬件和软件两部分组成的。</li>
<li>采用多道程序设计技术能够充分发挥CPU和外设并行工作的能力。</li>
<li>多道程序环境下的各道程序，宏观上它们是在并行运行，微观上它们是在串行运行。</li>
<li>并发和共享是操作系统的两个最基本的特征，两者之间互为存在条件。</li>
<li>顺序执行的程序，具有顺行性、封闭性和可再现性。</li>
<li>操作系统功能包括进程管理、内存管理、文件管理、设备管理，除此之外，操作系统还为用户使用计算机提供了用户接口。</li>
<li>批处理系统按内存中同时存放的运行程序的数目可分为单道批处理系统和多道批处理系统。</li>
<li>分时系统的主要特征有多路性、独占性、交互性和及时性。</li>
<li>实时系统分为两种类型：实时信息处理系统和实时控制系统。</li>
<li>响应时间是衡量分时系统性能的一项重要指标。</li>
<li>批处理系统不允许用户干预自己的程序。</li>
<li>采用批处理系统，用户提交作业前必须使用作业控制语言编写作业说明书，以指出作业加工的步骤。</li>
<li>操作系统为程序员提供的是程序接口（系统调用），为一般用户提供的是命令接口。</li>
<li>在操作系统的发展过程中，多道和分时的出现，标志着操作系统的正式形成。</li>
<li>如果一个系统在用户提交作业后，不提供交互能力，则属于批处理系统；如果一个系统可靠性很强，时间响应及时且具有交互能力，则属于实时系统类型；如果一个系统具有很强的交互性，可同时供多个用户使用，时间响应比较及时，则属于分时系统。</li>
</ol>
<h1 id="2-进程与线程"><a href="#2-进程与线程" class="headerlink" title="2. 进程与线程"></a>2. 进程与线程</h1><ol>
<li>并发执行的程序具有间断性特征。</li>
<li>在OS中，要想读取文件中的数据，通过系统调用来实现。</li>
<li>计算机处于用户态时，不能执行特权指令。</li>
<li>单道程序执行时，具有顺序性、封闭性和可再现性的特点。</li>
<li>多道程序执行时，具有间断性，将失去封闭性和可再现性的特点。</li>
<li>进程具有动态性、并发性、独立性、异步性和结构特征。</li>
<li>进程的3种基本状态是阻塞状态、就绪状态和运行状态。</li>
<li>判断一个进程是否处于挂起状态，要看该进程是否在内存，挂起状态又分为阻塞挂起和就绪挂起。</li>
<li>进程映像通常由程序、数据、栈和PCB四部分组成。</li>
<li>通常将处理机的执行状态分为系统状态和用户状态。</li>
<li>根据线程的切换是否依赖于内核把线程分成用户级和内核级。</li>
<li>进程是一个动态的概念，而程序是一个静态的概念。</li>
</ol>
<h1 id="3-进程同步与通信"><a href="#3-进程同步与通信" class="headerlink" title="3. 进程同步与通信"></a>3. 进程同步与通信</h1><ol>
<li>在利用信号量实现互斥时，应将临界区置于PV操作之间。</li>
<li>在实现了用户级线程的系统中，CPU调度的对象是进程；在实现了内核级线程的系统中，CPU调度的对象是线程。</li>
<li>在一个单处理机系统中，若有6个用户进程，且假设当前时刻为用户态，则处于就绪队列的进程最多有5个，最少有0个。</li>
<li>有n个进程共享某一临界资源，如用信号量机制实现对临界资源的互斥访问，则信号量值得变化范围是 -(n - 1) ~ 1。</li>
<li>对信号量的操作，只能是PV操作，P操作相当于进程申请资源，V操作相当于进程释放资源。如果P操作使用不当，可能导致系统死锁。</li>
<li>在多道程序环境中，进程之间存在的相互制约关系可以分为两种，即同步和互斥。其中互斥是指进程之间使用共享资源时的相互约束关系，而同步是指进程之间的相互协作、相互配合关系。</li>
<li>如果信号量的初始值为3，则表示系统有3个共享资源；如果信号量当前值为-4，则表示在该信号量上有4个进程等待。</li>
<li>信号量的物理意义是：信号量的初始值大于0表示系统中共享资源的个数；信号量的初始值等于0表示系统中没有该类的共享资源；信号量的初始值小于0，其绝对值表示系统中等待该类共享资源的进程数。</li>
<li>使用临界区的4个准则是：空闲让进、忙则等待、有限等待和让权等待。</li>
<li>并发进程中涉及相同变量的程序段称为临界区，对这段程序要互斥执行。</li>
<li>为实现消息通信，应有发送和接收两条基本原语。</li>
<li>对信号量S的P操作定义中，使进程进入等待队列的条件是S &lt; 0；V操作定义中，唤醒进程的条件是S ≤ 0。</li>
<li>AND信号量的基本思想是，将进程在整个运行期间所需要的临界资源一次性地全部分配给进程，待该进程使用完后再一起释放。</li>
<li>管程由共享变量的定义、能使进程并发执行、对共享变量的初始化三部分组成。</li>
<li>高级通信机制可分为三大类：共享存储系统、消息通信系统和管道通信。</li>
</ol>
<h1 id="4-调度与死锁"><a href="#4-调度与死锁" class="headerlink" title="4. 调度与死锁"></a>4. 调度与死锁</h1><ol>
<li><p>产生死锁的原因是资源不足和进程推进顺序非法。</p>
</li>
<li><p>资源预先静态分配方法和资源有序分配方法分别破坏了产生死锁的请求和保持条件和环路等待条件。</p>
</li>
<li><p>解决死锁通常采用预防、避免、检测和解除等方法，其中银行家算法属于避免死锁的方法，资源的有序分配属于预防死锁的方法，剥夺资源属于解除死锁的方法。</p>
</li>
<li><p>作业调度是高级调度，内外存对换调度是中级调度，进程调度是低级调度。</p>
</li>
<li><p>在有n个进程的系统中，死锁进程个数k应满足的条件是2 ≤ k ≤ n。</p>
</li>
<li><p>产生死锁的4个必要条件是互斥、请求和保持、不可剥夺和环路等待条件。</p>
</li>
<li><p>在银行家算法中，当一个进程提出资源请求将导致系统从安全状态进入不安全状态时，系统就拒绝它的资源请求。</p>
</li>
<li><p>在先来先服务算法中，系统按照进程进入就绪队列的先后次序来分配CPU。</p>
</li>
<li><p>死锁是一个系统中多个进程无限期地等待永远不会发生的条件。</p>
</li>
<li><p>判断资源分配图是否可以简化是检测死锁的方法。</p>
</li>
</ol>
<h1 id="5-存储管理"><a href="#5-存储管理" class="headerlink" title="5. 存储管理"></a>5. 存储管理</h1><ol>
<li>将程序地址空间中的逻辑地址变换成物理地址的过程称为重定位。</li>
<li>在可变分区中采用首次适应算法时，应将空闲区按地址递增的次序排列。</li>
<li>在可变分区的分配算法中，倾向于优先使用低地址部分空闲区的是首次适应算法，能使内存空间的空闲分区分布得比较均匀的是下次适应算法，每次分配时，若内存中有和进程需要的分区的大小相等的空闲区，一定能分配给进程的是最佳适应算法。</li>
<li>静态重定位是在程序装入内存时运行，动态重定位是在程序运行时运行。</li>
<li>静态链接是在程序运行前时进行，动态链接是在程序运行时进行。</li>
<li>两个目标模块链接在一起时需要解决相对地址的修改和外部符号引用的变换问题。</li>
<li>在段式存储管理系统中，程序使用的最大段数和每段的最大长度是由逻辑地址结构解决的。</li>
<li>进程有8页，页的大小1KB，它被映射到共有64个存储块的物理地址空间中，则该进程的逻辑地址的有效位是13，物理地址的有效位是16。</li>
<li>在段页式系统中，先将程序分段，再将段分页。内存分配以页为单位，如果不考虑使用快表的情况下，每条访问内存的指令需要3次访存，其中第二次是查页表。</li>
<li>在段式存储管理系统中，如果一个进程有15段，每段的大小不超过2KB，则该进程的逻辑地址的大小是30KB，其逻辑地址用15个二进制位表示。</li>
</ol>
<h1 id="6-虚拟存储管理"><a href="#6-虚拟存储管理" class="headerlink" title="6. 虚拟存储管理"></a>6. 虚拟存储管理</h1><ol>
<li>在请求页式存储管理系统中，地址变换过程可能会因为地址越界、缺页和访问权限非法等原因产生中断。</li>
<li>交换技术获得的好处是以牺牲CPU时间为代价的。</li>
<li>在请求页式存储管理系统的页面置换算法中，最佳置换算法OPT选择淘汰不再使用的页或长时间不再使用的页；先进先出置换算法FIFO选择淘汰在内存驻留时间最长的页；最近最久未使用置换算法LRU选择淘汰最近一段时间内使用最少的页。</li>
<li>在段页式系统中，OS必须为每个进程建立一张段表，且每一段都对应一张页表。</li>
<li>页面置换算法是在内存中没有空闲块时被调用，它的目的是选出一个被淘汰块的页面，如果内存中有足够的空闲块存放所调入的页，则不必使用页面置换算法。</li>
<li>决定缺页中断所需时间的主要因素是中断处理时间、页面交换时间和重启进程时间。</li>
<li>过度增加多道程序的并行程序，在虚拟存储器系统中可能会引起抖动现象，反而会降低系统的吞吐量。理论和实践证明，在L = S，即使产生缺页的平均时间L等于系统处理缺页的平均时间S时，CPU利用率最好。</li>
<li>多道程序设计技术的引入给存储管理系统提出了新的课题，需要考虑的3个问题是内存分配、内存保护和地址重定位。</li>
<li>设一个计算机系统的CPU地址长度为32位，内存的大小是32MB，则该计算机的物理地址空间的大小位32MB，逻辑地址的大小为4GB。</li>
<li>请求页式系统比起页式系统，页表中增加了状态位、修改位、访问字段和外存地址。</li>
<li>可以实现虚拟存储技术的管理方案有页式、段式和段页式，其中段页式方案实现起来最复杂。</li>
<li>在虚拟存储管理系统中，要求硬件必须提供Cache，以保证地址变化变换的速度。</li>
<li>虚拟存储器的四大特征是离散性、多次性、对换性和虚拟性。</li>
<li>时钟置换算法是LRU算法的近似算法，它要求页表中的访问字段只需一位即可。</li>
<li>在请求页式存储管理的页表中，状态位的作用是判断是否缺页，修改位的作用是判断某页是否要写回外存，访问字段是用于页面置换。</li>
</ol>
<h1 id="7-设备管理"><a href="#7-设备管理" class="headerlink" title="7. 设备管理"></a>7. 设备管理</h1><ol>
<li>在现代OS中，几乎所有的I/O设备与CPU交换数据时，都使用了缓冲区。</li>
<li>读/写磁盘时，一般把磁盘的访问时间分成三部分寻道时间、旋转时间和数据传输时间。</li>
<li>设备分配程序在分配设备时，先分配设备，再分配控制器，最后分配通道。</li>
<li>虚拟设备是通过SPOOLing技术把独占设备变为能为若干用户共享的设备。</li>
<li>为实现CPU和设备之间的并行工作，系统引入了通道和中断硬件机制。</li>
<li>常用的I/O控制方式有程序直接控制方式、中断控制方式、DMA控制方式和通道方式。</li>
<li>通道是一个独立于CPU而专门负责I/O的处理机，它控制外部设备与内存之间的信息交换。</li>
<li>按设备固有属性，一般把设备分为独占设备、共享设备和虚拟设备。</li>
<li>设备分配时所需要的数据结构有设备控制表、控制器控制表、通道控制表和系统设备表。</li>
<li>使用逻辑设备表（LUT）有两个好处，一是增加了设备分配的灵活性，二是易于实现I/O重定向。</li>
<li>打印机是独占设备，磁盘是共享设备。</li>
<li>在存储设备中，磁带是一种顺序存取设备，它适合顺序存取；磁盘是一种直接存取设备，它适合随机存取。</li>
<li>在RAID技术中，仅仅提供并行交叉访问的是RAID0，提供磁盘镜像的是RAID1，从RAID5开始把校验条带分布在所有的磁盘中.</li>
<li>缓冲区的组织可分为单缓冲、双缓冲、循环缓冲和缓冲池。</li>
<li>设备分配程序要保证设备有高的利用率，并防止死锁问题的产生。</li>
<li>在计算机系统中，CPU输出数据的速度远远高于打印机的打印速度，为了解决这一矛盾，可以采用缓冲技术。</li>
<li>缓冲技术的缓冲池在内存中。</li>
<li>最短寻道时间优先算法选择与当前磁头所在磁道距离最近的请求作为下一次服务的对象。</li>
</ol>
<h1 id="8-文件管理"><a href="#8-文件管理" class="headerlink" title="8. 文件管理"></a>8. 文件管理</h1><ol>
<li>使用文件之前必须先打开文件，使用完毕之后需要关闭文件。</li>
<li>文件目录中至少应包含文件名和文件物理地址。</li>
<li>逻辑文件结构有流式文件和记录式文件两种。</li>
<li>文件的物理组织结构有连续文件、链接文件和索引文件。</li>
<li>文件共享是指运行多个用户共同使用同一个文件。</li>
<li>文件的转储方法有全量转储和增量转储。</li>
<li>在文件系统中，要求物理块必须连续的文件物理组织方式是顺序文件。</li>
<li>文件目录的作用是实现文件名到文件物理地址的转换。</li>
<li>文件结构就是文件的组织方式，从用户观点出发看到的文件组织形式称为文件的逻辑结构，从实现观点出发看到的文件在外存上的存放组织形式称为文件的物理结构。</li>
<li>文件系统中若文件的物理结构采用连续分配方式，则文件控制块中关于文件的物理位置应包括起始块号和块数。</li>
<li>位示图在文件系统中的作用是管理文件系统中的空闲物理块。</li>
<li>主目录在树形目录结构中，作为树的根节点，称为根目录；数据文件作为树的叶子节点，其它子目录作为树的分支节点。</li>
<li>在OS中，每个索引文件都必须有一张索引表，其中每个登记项用来指出一个逻辑记录的存放位置和指针。</li>
<li>按用户对文件的存取权限将用户分为若干组，同时规定每一组用户对文件的访问权限，这样，所有用户组存取权限的集合称为该文件的访问控制表。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>一探Spring源码——bean的创建</title>
    <url>/2022/01/02/%E3%80%90%E6%BA%90%E7%A0%81%E3%80%91Spring%E2%80%94%E2%80%94bean%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<p>w我们知道，IOC是一个容器，在这个容器启动的时候会创建所有单实例对象，我们可以直接从容器中获取到这个对象。在这里，我们将解决以下问题：</p>
<ul>
<li>IOC容器的启动过程？启动期间都做了什么（什么时候创建所有单实例bean）？</li>
<li>IOC是如何创建这些单实例bean，并如何管理的？到底保存在了哪里？</li>
</ul>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>新建普通Java工程，引入jar包：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220111103132395.png" alt="image-20220111103132395"></p>
<p>创建JavaBean，Person：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/1/3 15:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>xml注入bean，application.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atqingke&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;21&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person02&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;李四&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;22&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person03&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;王五&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;23&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写测试类，SourceTest：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atqingke.bean.Person;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/1/3 15:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;application.xml&quot;</span>);</span><br><span class="line">        Person person01 = context.getBean(<span class="string">&quot;person01&quot;</span>, Person.class);</span><br><span class="line">        System.out.println(person01);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>从最简单的HelloWorld开始，单步调试。</p>
<p>首先我们从第一行代码开始，Step Into进入</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220103221340624.png" alt="image-20220103221340624"></p>
<p>接下来我们来到AbstractApplicationContext：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220103221608551.png" alt="image-20220103221608551"></p>
<p>这里的注释告诉我们：如果没有提供工厂中ApplicationEventMulticaster的bean的名称，则使用默认的名称，也就是这个“applicationEventMulticaster”。这里不是我们关注的重点，我们Step Over跳过这里！发现它又回到了我们的main方法，这时候我们再Step Over的话，可以看到，我们在配置文件中注入的bean对象，就已经创建好了。所以我们当我们回到main方法的时候，需要再次Step Into进入new ClassPathXmlApplicationContext。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220103222233024.png" alt="image-20220103222233024"></p>
<p>可以发现，这次我们来到的是ClassPathXmlApplicationContext。也就是说，程序从开始运行到现在，有两次进入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;application.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>第一次是进入ApplicationContext，第二次进入ClassPathXmlApplicationContext。而目的也很显然，就是创建一个ClassPathXmlApplicationContext对象，加载我们给定的XML配置文件。</p>
<p>这时候如果我们Step Over跳过这个构造器方法的话，肯定又是回到了main函数，然后结束bean的创建。因此我们继续Step Into查看它是如何创建bean的(也可以在refresh方法上打上断点，再F9 Resume Program，使程序运行到这个断点)。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220103223116959.png" alt="image-20220103223116959"></p>
<p>我们可以看到，构造器的注释中告诉我们refresh就是“<strong>loading all bean definitions and creating all singletons</strong>”。因此我们进入一路Step Over来到refresh并Step Into进入里面。我们来详细看一下refresh方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        StartupStep contextRefresh = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是Spring解析xml配置文件，将要创建的所有bean的配置信息保存起来，所以想要看Spring对xml的解析可以Step Into里面</span></span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            StartupStep beanPostProcess = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.beans.post-process&quot;</span>);</span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line">            beanPostProcess.end();</span><br><span class="line">            </span><br><span class="line"><span class="comment">// 支持国际化功能的</span></span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line">            </span><br><span class="line"><span class="comment">// 空方法，留给子类使用的</span></span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            registerListeners();</span><br><span class="line">            </span><br><span class="line"><span class="comment">// 从名字就可以知道，这里是初始化所有单实例bean的地方</span></span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁已经创建的单例bean</span></span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">            contextRefresh.end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行到finishBeanFactoryInitialization方法的时候，就结束了bean的初始化。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220111103916936.png" alt="image-20220111103916936"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Finish the initialization of this context&#x27;s bean factory,</span></span><br><span class="line"><span class="comment">	 * initializing all remaining singleton beans.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动类型转换，不用管</span></span><br><span class="line">    <span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">        beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">        beanFactory.setConversionService(</span><br><span class="line">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理前置处理器</span></span><br><span class="line">    <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">    <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">    <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">        beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Autowired相关</span></span><br><span class="line">    <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">        getBean(weaverAwareName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">    beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line"><span class="comment">// bean初始化</span></span><br><span class="line">    <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Step Into进入preInstantiateSingletons方法：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220111105120658.png" alt="image-20220111105120658"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">    <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">    List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bean实例真正初始化的地方</span></span><br><span class="line">    <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 根据bean的id获取到bean的定义信息</span></span><br><span class="line">        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 如果这个bean不是抽象并且是单例的，也不是懒加载的，我们就在容器中注册这个bean</span></span><br><span class="line">        <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">            </span><br><span class="line"><span class="comment">// 是否是一个实现了FactoryBean接口的bean</span></span><br><span class="line">            <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">                Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">                <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">                    <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">                    <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">                    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                        isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">                                                                    ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                                                                    getAccessControlContext());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                                       ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                        getBean(beanName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"><span class="comment">// 否则，根据beanName直接获取</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bean初始化之后的回调函数</span></span><br><span class="line">    <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        Object singletonInstance = getSingleton(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">            <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                    smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Step Into进入getBean方法：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220111105740064.png" alt="image-20220111105740064"></p>
<p>再Step Into进入doGetBean方法：通过方法上的注释可以知道，这个方法会返回一个bean实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> requiredType the required type of the bean to retrieve</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span></span><br><span class="line"><span class="comment">	 * (only applied when creating a new instance as opposed to retrieving an existing one)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> typeCheckOnly whether the instance is obtained for a type check,</span></span><br><span class="line"><span class="comment">	 * not for actual use</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">    Object sharedInstance = getSingleton(beanName);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// context.getBean(&quot;person01&quot;, Person.class)的执行流程</span></span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                             <span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line">        <span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先检查bean准备初始化的bean实例是否已经存在了</span></span><br><span class="line">        <span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">        BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要初始化的bean实例没有父类bean并且不在已经初始化的bean队列中</span></span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">            String nameToLookup = originalBeanName(name);</span><br><span class="line">            <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">                    nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记这个bean已经被创建了，用于多线程使用</span></span><br><span class="line">        <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">            markBeanAsCreated(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿到创建当前bean需要提前创建的bean，dependsOn属性：如果有，就循环创建</span></span><br><span class="line">            <span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">            String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                                        <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    registerDependentBean(dep, beanName);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        getBean(dep);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                                        <span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单实例bean真正初始化的地方</span></span><br><span class="line">            <span class="comment">// Create bean instance.</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                        <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">                        <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">                        <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">                        destroySingleton(beanName);</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">                <span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">                Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforePrototypeCreation(beanName);</span><br><span class="line">                    prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterPrototypeCreation(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                String scopeName = mbd.getScope();</span><br><span class="line">                <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">                <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">                        beforePrototypeCreation(beanName);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">finally</span> &#123;</span><br><span class="line">                            afterPrototypeCreation(beanName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                                                    <span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line">                                                    <span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">                                                    ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">            <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> convertedBean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">                             ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 返回已经初始化好的单实例bean</span></span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220111110623595.png" alt="image-20220111110623595"></p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220111110701303.png" alt="image-20220111110701303"></p>
<p>如此，循环执行doGetBean方法将所有的bean进行初始化</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220111110804538.png" alt="image-20220111110804538"></p>
<hr>
<p>下面来看创建好的bean实例保存在哪里？？？</p>
<p>在preInstantiateSingletons里面有一个回调函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    Object singletonInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">        <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们进入getSingleton方法，它是获取bean实例的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the (raw) singleton object registered under the given name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Checks already instantiated singletons and also allows for an early</span></span><br><span class="line"><span class="comment">	 * reference to a currently created singleton (resolving a circular reference).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean to look for</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> allowEarlyReference whether early references should be created or not</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the registered singleton object, or &#123;<span class="doctag">@code</span> null&#125; if none found</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    </span><br><span class="line"><span class="comment">// 创建bean</span></span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在getSingleton方法里面，可以看到，先从一个地方获取到bean。我们按住Ctrl再鼠标左键点击11行的singletonObjects跳转到它的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到这是一个Map集合，集合的Map就是bean实例的id，value就是bean实例的属性值。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220111114114235.png" alt="image-20220111114114235"></p>
<p>因此，通过这里，我们可以知道：创建好的bean实例就保存在这个map集合当中（DefaultSingletonBeanRegistry—-&gt;singletonObjects）！</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>打断点的几处地方：</strong></p>
<blockquote>
<ul>
<li><p>```java<br>ApplicationContext context = new ClassPathXmlApplicationContext(“application.xml”);    // SourTest.java    14行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  refresh();		// ClassPathXmlApplicationContext	144行</span><br></pre></td></tr></table></figure></li>
<li><p>```java<br>finishBeanFactoryInitialization(beanFactory);    // AbstractApplicationContext    550行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  beanFactory.preInstantiateSingletons();		// AbstractApplicationContext	878行</span><br></pre></td></tr></table></figure></li>
<li><p>```java<br>getBean(beanName);    // DefaultListableBeanFactory    895行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  final String beanName = transformedBeanName(name);	// AbstractBeanFactory	245行</span><br></pre></td></tr></table></figure></li>
<li><pre><code class="java">Object singletonInstance = getSingleton(beanName);    // DefaultListableBeanFactory    902行
</code></pre>
</li>
</ul>
</blockquote>
<p><strong>关于BeanFactory和ApplicationContext的区别：</strong></p>
<blockquote>
<ul>
<li><p>ApplicationContext是BeanFactory的子接口</p>
<ul>
<li><p>BeanFactory：bean工厂接口，负责创建bean实例；容器里面保存的所有单例bean其实是一个map；也是Spring最底层的接口。</p>
</li>
<li><p>ApplicationContext：是容器接口，更多的是负责容器功能的实现（可以基于BeanFactory创建好的对象之上完成强大的容器）。</p>
<p>容器可以从map获取这个bean，并且AOP、DI在ApplicationContext接口下的这些类里面。</p>
<p>ApplicationContext是留给程序员使用的IOC容器接口。</p>
</li>
</ul>
</li>
<li><p>Spring里面最大的模式就是工厂模式。</p>
</li>
</ul>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>虚拟内存管理</title>
    <url>/2022/01/01/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>为什么要引入虚拟内存？</p>
<p>虚拟内存空间的大小由什么因素决定？</p>
<p>虚拟内存是怎么解决问题的？会带来什么问题？</p>
</blockquote>
<h1 id="1-虚拟内存的基本概念"><a href="#1-虚拟内存的基本概念" class="headerlink" title="1. 虚拟内存的基本概念"></a>1. 虚拟内存的基本概念</h1><h2 id="1-1-传统存储管理方式的特征"><a href="#1-1-传统存储管理方式的特征" class="headerlink" title="1.1 传统存储管理方式的特征"></a>1.1 传统存储管理方式的特征</h2><p>在传统的内存管理策略都是为了同时将多个进程保存在内存中，以便允许进行多道程序设计。它们都具有以下两个共同的特征：</p>
<ul>
<li><strong>一次性</strong>。作业必须一次性全部装入内存后，才能开始运行。这会导致两种情况：<ol>
<li>单个作业很大而不能全部装入内存中，作业无法运行。</li>
<li>大量作业要求运行，而内存却不足以容纳所有，只能少数先行，导致多道程序度下降。</li>
</ol>
</li>
<li><strong>驻留性</strong>。作业被装入内存后，就一直驻留在内存中，其任何部分都不会被换出，直至作业运行结束。运行中的进程会因等待I/O而被阻塞，可能处于长期等待状态。</li>
</ul>
<p>也就是说：<strong>许多在程序运行中不用或暂时不用的程序（数据）占据了大量的内存空间，而一些需要运行的作业又无法装入运行</strong>，显然浪费了宝贵的内存资源。</p>
<h2 id="1-2-局部性原理"><a href="#1-2-局部性原理" class="headerlink" title="1.2 局部性原理"></a>1.2 局部性原理</h2><p>Bill Joy（SUN公司CEO）说过：“在研究所时，我经常开玩笑地说高速缓存是计算机科学中唯一重要的思想。事实上，高速缓存技术确实极大地影响了计算机系统的设计。”快表、页高速缓存及虚拟内存技术从广义上讲，都属于<strong>高速缓存技术</strong>。这个技术所依赖的原理就是<strong>局部性原理</strong>。局部性原理既适用于程序结构，又适用于数据结构。</p>
<p>局部性原理表现在以下两个方面：</p>
<ul>
<li><strong>时间局部性</strong>。程序中的某条指令一旦执行，不久后该指令可能再次执行；某数据被访问过，不久后该数据可能再次被访问。产生时间局部性的典型原因是<strong>程序中存在着大量的循环操作</strong>。</li>
<li><strong>空间局部性</strong>。一旦程序访问了某个存储单元，在不久后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围内，因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li>
</ul>
<p>时间局部性通过将最近使用的指令和数据保存到高速缓冲存储器中，并使用高速缓存的层次结构实现。</p>
<p>空间局部性通常使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。</p>
<p><strong>虚拟内存技术实际上建立了“内存——外存”的两级存储器结构，利用局部性原理实现高速缓存</strong>。</p>
<h2 id="1-3-虚拟存储器的定义和特征"><a href="#1-3-虚拟存储器的定义和特征" class="headerlink" title="1.3 虚拟存储器的定义和特征"></a>1.3 虚拟存储器的定义和特征</h2><p>基于局部性原理，在程序装入时，将程序的一部分装入内存，而将剩余部分留在外存，就可以启动程序执行。当执行过程中，发现所访问的信息不再内存中，再通过OS将所需资源调入内存。如果有资源暂时不使用，OS将其换出到外存中。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为<strong>虚拟存储器</strong>。</p>
<p>这个存储器实际是不存在的，只是由于系统提供了部分装入、请求调入和置换功能后（对用户完全透明），给用户的感觉是好像存在一个比实际物理内存大得多的存储器。虚拟存储器的大小由计算机的地址结构决定，并不是内存和外存的简单相加。它具有以下三个主要特征：</p>
<ul>
<li><strong>多次性</strong>。作业无须一次装入。</li>
<li><strong>对换性</strong>。作业无须常驻内存。</li>
<li><strong>虚拟性</strong>。从逻辑上扩充内存容量。</li>
</ul>
<h2 id="1-4-虚拟内存技术的实现"><a href="#1-4-虚拟内存技术的实现" class="headerlink" title="1.4 虚拟内存技术的实现"></a>1.4 虚拟内存技术的实现</h2><p>因为具有多次行的特征，所以作业肯定不是连续分配的，而是离散分配。虚拟内存的实现有以下三种方式：</p>
<ul>
<li>请求分页存储管理。</li>
<li>请求分段存储管理。</li>
<li>请求段页式存储管理。</li>
</ul>
<p>不管使用哪种方式，都需要一定的硬件支持，一般需要的支持有以下几个方面：</p>
<ul>
<li>一定容量的内存和外存。</li>
<li>页表机制（或段表机制），作为主要的数据结构。</li>
<li>中断机构，当用户程序要访问的部分尚未调入内存时，则产生中断。</li>
<li>地址变换机构，逻辑地址到物理地址的转换。</li>
</ul>
<h1 id="2-请求分页管理方式"><a href="#2-请求分页管理方式" class="headerlink" title="2. 请求分页管理方式"></a>2. 请求分页管理方式</h1><p>请求分页系统建立在基本分页系统基础之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。这也是目前最常用的一种实现虚拟存储器的方法。</p>
<h2 id="2-1-页表机制"><a href="#2-1-页表机制" class="headerlink" title="2.1 页表机制"></a>2.1 页表机制</h2><p>因为一个作业运行之前不要求全部装入内存，那么在作业的运行过程中，必然会出现要访问的页面不在内存中的情况，如何发现和处理这种情况是请求分页系统必须解决的两个基本问题。为此，在请求页表项中增加了4个字段，如图所示：</p>
<ul>
<li><strong>状态为P</strong>。用于指示该页是否已调入内存，供程序访问时参考。</li>
<li><strong>访问字段A</strong>。用于记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问，供置换算法换出页面时参考。</li>
<li><strong>修改位M</strong>。标识该页在调入内存后是否被修改过。</li>
<li><strong>外存地址</strong>。用于指出该页在外存上的地址，通常是物理块号，供调入该页时参考。</li>
</ul>
<h2 id="2-2-缺页中断机构"><a href="#2-2-缺页中断机构" class="headerlink" title="2.2 缺页中断机构"></a>2.2 缺页中断机构</h2><p>每当所要访问的页面不在内存中时，便产生一个缺页中断，请求OS将所缺的页调入内存。此时应将缺页的进程阻塞（调页完成后唤醒），若内存中有空闲块，则分配一个块，将要调入的页装入，并修改页表中对应的页表项；若没有空闲块，则淘汰某页（淘汰也如果被修改过，则要将其写回外存）；</p>
<p>缺页中断作为中断，同样要经历诸如保护CPU环境、分析中断原因、转入缺页中断处理程序、恢复CPU环境等几个步骤。但与一般的中断相比。它有以下两个明显的区别：</p>
<ul>
<li>在指令执行期间而非一条指令执行完后产生和处理中断信号，属于内部中断。</li>
<li>一条指令在执行期间，可能产生多次缺页中断。</li>
</ul>
<h2 id="2-3-地址变换机构"><a href="#2-3-地址变换机构" class="headerlink" title="2.3 地址变换机构"></a>2.3 地址变换机构</h2><p>在进行地址变换时，先检索快表：</p>
<ul>
<li>若找到要访问的页，则修改页表项中的访问位（写指令还需要重置修改位），然后利用页表项中给出的物理块号和页内地址形成物理地址。</li>
<li>没有找到，则到内存中去查找页表，再对比页表项中的状态为P，看该页是否已调入内存，未调入则产生缺页中断，请求从外存调入该页。</li>
</ul>
<h1 id="3-页面置换算法"><a href="#3-页面置换算法" class="headerlink" title="3. 页面置换算法"></a>3. 页面置换算法</h1><p>参见 <a href="https://atqingke.com/index.php/archives/76/">https://atqingke.com/index.php/archives/76/</a></p>
<h1 id="4-页面分配策略"><a href="#4-页面分配策略" class="headerlink" title="4. 页面分配策略"></a>4. 页面分配策略</h1><h2 id="4-1-驻留集大小"><a href="#4-1-驻留集大小" class="headerlink" title="4.1 驻留集大小"></a>4.1 驻留集大小</h2><p>给一个进程分配的物理页框的集合就是这个进程的驻留集。需要考虑以下几点：</p>
<ul>
<li>分配给一个进程的存储量越小，任何时候驻留在内存中的进程数就越多，从而可以提高处理机的时间利用效率。</li>
<li>若一个进程在主存中的页数过少，则尽管有局部性原理，页错误率仍然会相对较高。</li>
<li>若页数过多，则由于局部性原理，给特定的进程分配更多的主存空间对该进程的错误率没有明显的影响。</li>
</ul>
<p>基于这些因素，现代OS通常采用三种策略：</p>
<ol>
<li><strong>固定分配局部置换</strong>。它为每一个进程分配一定数目的物理块，然后在整个运行期间都不改变。如果缺页，再进行换入换出。实现这种策略，分配的物理块太少会频繁出现缺页中断，太多又会使CPU和其它资源利用率下降。</li>
<li><strong>可变分配全局置换</strong>。最易于实现的物理块分配和置换策略，它在为系统的每个进程分配一定数量的物理块时，OS自身也保持一个空闲物理块队列。当发生缺页时，动态的增加进程的物理块，但也存在弊端，如它会盲目给进程增加物理块，从而导致系统多道程序的并发能力下降。</li>
<li><strong>可变分配局部置换</strong>。它为每个进程分配一定数目的物理块，当某个进程发生缺页时，只允许从该进程在内存的页面中选出一页换出，因此不会影响其它进程运行。如果进程频繁缺页，则系统再为该进程分配若干物理块，直到该进程的缺页率趋于适当程度；反之，缺页率很低，则适当减少物理块的分配。相比前两种策略，它需要更复杂的实现，也需要更大的开销，但对比频繁地换入/换出所浪费的计算机资源，这种牺牲是值得的。</li>
</ol>
<h2 id="4-2-调入页面的时机"><a href="#4-2-调入页面的时机" class="headerlink" title="4.2 调入页面的时机"></a>4.2 调入页面的时机</h2><p>为确定系统将进程运行时所缺的页面调入内存的时机，可采取以下两种调页策略：</p>
<ul>
<li><strong>预调页策略</strong>。根据局部性原理，采用以预测为基础的预调页策略，将预计在不久之后便会被访问的页面预先调入内存。但目前预调页的成功了只有约50%。因此这种策略主要用于进程的首次调入，由程序员指出应先调入哪些页。</li>
<li><strong>请求调页策略</strong>。进程在运行中需要访问的页面不在内存而提出请求，由系统将所需页面调入内存。这个缺点是每次只能调入一页，调入/调出页面多时会花费过多的I/O开销。</li>
</ul>
<p>预调入实际上就是运行前的调入，请求调页实际上就是运行期间调入。一般情况下，两种调页策略会同时使用。</p>
<h2 id="4-3-从何处调入页面"><a href="#4-3-从何处调入页面" class="headerlink" title="4.3 从何处调入页面"></a>4.3 从何处调入页面</h2><p>请求分页系统中的外存分为两部分：用于存放文件的文件区和用于存放对换页面的对换区。对换区通常采用连续分配方式，而文件区采用离散分配方式，因此对换区的磁盘I/O速度比文件区的更快。这样，从何处调入页面就存在三种情况：</p>
<ul>
<li>系统拥有足够的对换区空间</li>
<li>系统缺少足够的对换区空间</li>
<li></li>
</ul>
<h1 id="5-抖动"><a href="#5-抖动" class="headerlink" title="5. 抖动"></a>5. 抖动</h1><h1 id="6-工作集"><a href="#6-工作集" class="headerlink" title="6. 工作集"></a>6. 工作集</h1><h1 id="7-地址翻译"><a href="#7-地址翻译" class="headerlink" title="7. 地址翻译"></a>7. 地址翻译</h1>]]></content>
  </entry>
  <entry>
    <title>磁盘组织与管理</title>
    <url>/2022/01/01/%E7%A3%81%E7%9B%98%E7%BB%84%E7%BB%87%E4%B8%8E%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>在磁盘上进行一次读写操作需要哪几部分时间？其中哪部分时间最长？</p>
<p>存储一个文件时，当一个磁道存储不下时，剩下部分时存在同一个盘面的不同磁道好，还是存在同一个柱面上的不同盘面好？</p>
</blockquote>
<h1 id="1-磁盘的结构"><a href="#1-磁盘的结构" class="headerlink" title="1. 磁盘的结构"></a>1. 磁盘的结构</h1><h1 id="2-磁盘调度算法"><a href="#2-磁盘调度算法" class="headerlink" title="2. 磁盘调度算法"></a>2. 磁盘调度算法</h1><h1 id="3-磁盘的管理"><a href="#3-磁盘的管理" class="headerlink" title="3. 磁盘的管理"></a>3. 磁盘的管理</h1><h2 id="3-1-磁盘初始化"><a href="#3-1-磁盘初始化" class="headerlink" title="3.1 磁盘初始化"></a>3.1 磁盘初始化</h2><h2 id="3-2-引导块"><a href="#3-2-引导块" class="headerlink" title="3.2 引导块"></a>3.2 引导块</h2><h2 id="3-3-环块"><a href="#3-3-环块" class="headerlink" title="3.3 环块"></a>3.3 环块</h2>]]></content>
  </entry>
  <entry>
    <title>文件系统基础</title>
    <url>/2022/01/01/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<blockquote>
<p>什么是文件？什么是文件系统？</p>
<p>文件系统要完成哪些功能？</p>
</blockquote>
<h1 id="1-文件的概念"><a href="#1-文件的概念" class="headerlink" title="1. 文件的概念"></a>1. 文件的概念</h1><h2 id="1-1-文件的定义"><a href="#1-1-文件的定义" class="headerlink" title="1.1 文件的定义"></a>1.1 文件的定义</h2><h2 id="1-2-文件的属性"><a href="#1-2-文件的属性" class="headerlink" title="1.2 文件的属性"></a>1.2 文件的属性</h2><h2 id="1-3-文件的基本操作"><a href="#1-3-文件的基本操作" class="headerlink" title="1.3 文件的基本操作"></a>1.3 文件的基本操作</h2><h2 id="1-4-文件的打开与关闭"><a href="#1-4-文件的打开与关闭" class="headerlink" title="1.4 文件的打开与关闭"></a>1.4 文件的打开与关闭</h2><h1 id="2-文件的逻辑结构"><a href="#2-文件的逻辑结构" class="headerlink" title="2. 文件的逻辑结构"></a>2. 文件的逻辑结构</h1><h2 id="2-1-无结构文件（流式文件）"><a href="#2-1-无结构文件（流式文件）" class="headerlink" title="2.1 无结构文件（流式文件）"></a>2.1 无结构文件（流式文件）</h2><h2 id="2-2-有结构文件（记录式文件）"><a href="#2-2-有结构文件（记录式文件）" class="headerlink" title="2.2 有结构文件（记录式文件）"></a>2.2 有结构文件（记录式文件）</h2><h3 id="2-2-1-顺序文件"><a href="#2-2-1-顺序文件" class="headerlink" title="2.2.1 顺序文件"></a>2.2.1 顺序文件</h3><h3 id="2-2-2-索引文件"><a href="#2-2-2-索引文件" class="headerlink" title="2.2.2 索引文件"></a>2.2.2 索引文件</h3><h3 id="2-2-3-索引顺序问价"><a href="#2-2-3-索引顺序问价" class="headerlink" title="2.2.3 索引顺序问价"></a>2.2.3 索引顺序问价</h3><h3 id="2-2-4-直接文件或散列文件（Hash-File）"><a href="#2-2-4-直接文件或散列文件（Hash-File）" class="headerlink" title="2.2.4 直接文件或散列文件（Hash File）"></a>2.2.4 直接文件或散列文件（Hash File）</h3><h1 id="3-目录结构"><a href="#3-目录结构" class="headerlink" title="3. 目录结构"></a>3. 目录结构</h1><h2 id="3-1-文件控制块和索引结点"><a href="#3-1-文件控制块和索引结点" class="headerlink" title="3.1 文件控制块和索引结点"></a>3.1 文件控制块和索引结点</h2><h2 id="3-2-目录结构"><a href="#3-2-目录结构" class="headerlink" title="3.2 目录结构"></a>3.2 目录结构</h2><h3 id="3-2-1-单级目录结构"><a href="#3-2-1-单级目录结构" class="headerlink" title="3.2.1 单级目录结构"></a>3.2.1 单级目录结构</h3><h3 id="3-2-2-两级目录结构"><a href="#3-2-2-两级目录结构" class="headerlink" title="3.2.2 两级目录结构"></a>3.2.2 两级目录结构</h3><h3 id="3-2-3-多级目录结构（树形目录结构）"><a href="#3-2-3-多级目录结构（树形目录结构）" class="headerlink" title="3.2.3 多级目录结构（树形目录结构）"></a>3.2.3 多级目录结构（树形目录结构）</h3><h3 id="3-2-4-无环图目录结构"><a href="#3-2-4-无环图目录结构" class="headerlink" title="3.2.4 无环图目录结构"></a>3.2.4 无环图目录结构</h3>]]></content>
  </entry>
  <entry>
    <title>Spring-JdbcTemplate</title>
    <url>/2022/01/01/Spring-JdbcTemplate/</url>
    <content><![CDATA[<p>了解即可！！！！！！！！！！！！</p>
<p>sql文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">SQLyog Ultimate v10.00 Beta1</span><br><span class="line">MySQL - 5.7.32 : Database - jdbc_template</span><br><span class="line">*********************************************************************</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*!40101 SET NAMES utf8 */;</span><br><span class="line"></span><br><span class="line">/*!40101 SET SQL_MODE=&#x27;&#x27;*/;</span><br><span class="line"></span><br><span class="line">/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;</span><br><span class="line">/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#x27;NO_AUTO_VALUE_ON_ZERO&#x27; */;</span><br><span class="line">/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;</span><br><span class="line">CREATE DATABASE /*!32312 IF NOT EXISTS*/`jdbc_template` /*!40100 DEFAULT CHARACTER SET gb2312 */;</span><br><span class="line"></span><br><span class="line">USE `jdbc_template`;</span><br><span class="line"></span><br><span class="line">/*Table structure for table `employee` */</span><br><span class="line"></span><br><span class="line">CREATE TABLE `employee` (</span><br><span class="line">  `emp_id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `emp_name` char(100) DEFAULT NULL,</span><br><span class="line">  `salary` double DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`emp_id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=gb2312;</span><br><span class="line"></span><br><span class="line">/*Data for the table `employee` */</span><br><span class="line"></span><br><span class="line">insert  into `employee`(`emp_id`,`emp_name`,`salary`) values (1,&#x27;Susan&#x27;,5000.23);</span><br><span class="line">insert  into `employee`(`emp_id`,`emp_name`,`salary`) values (2,&#x27;Julian&#x27;,4234.77);</span><br><span class="line">insert  into `employee`(`emp_id`,`emp_name`,`salary`) values (3,&#x27;Papu&#x27;,9034.51);</span><br><span class="line">insert  into `employee`(`emp_id`,`emp_name`,`salary`) values (4,&#x27;Babala&#x27;,8054.33);</span><br><span class="line">insert  into `employee`(`emp_id`,`emp_name`,`salary`) values (5,&#x27;Kasier&#x27;,1300);</span><br><span class="line">insert  into `employee`(`emp_id`,`emp_name`,`salary`) values (6,&#x27;Owen&#x27;,7714.11);</span><br><span class="line">insert  into `employee`(`emp_id`,`emp_name`,`salary`) values (7,&#x27;zhangsan&#x27;,9999.99);</span><br><span class="line">insert  into `employee`(`emp_id`,`emp_name`,`salary`) values (8,&#x27;lisi&#x27;,8999.99);</span><br><span class="line">insert  into `employee`(`emp_id`,`emp_name`,`salary`) values (9,&#x27;wangwu&#x27;,7999.99);</span><br><span class="line">insert  into `employee`(`emp_id`,`emp_name`,`salary`) values (10,&#x27;zhaoliu&#x27;,6999.99);</span><br><span class="line">insert  into `employee`(`emp_id`,`emp_name`,`salary`) values (11,&#x27;田七&#x27;,8848.88);</span><br><span class="line">insert  into `employee`(`emp_id`,`emp_name`,`salary`) values (12,&#x27;哈哈&#x27;,5555.55);</span><br><span class="line">insert  into `employee`(`emp_id`,`emp_name`,`salary`) values (13,&#x27;哈哈2&#x27;,5555.55);</span><br><span class="line"></span><br><span class="line">/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;</span><br><span class="line">/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;</span><br><span class="line">/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;</span><br></pre></td></tr></table></figure>

<p>applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:dbConfig.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atqingke&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验9：创建BookDao，自动装配JdbcTemplate对象--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--实验8：重复实验7，以SqlParameterSource形式传入参数值--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--实验7：使用带有具名参数的SQL语句插入一条员工记录，并以Map形式传入参数值--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置一个具有具名参数功能的jdbcTemplate--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;namedParameterJdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用构造器方式注入一个数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验6：查询最大salary--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--实验5：查询salary&gt;4000的数据库记录，封装为List集合返回--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--实验4：查询emp_id=5的数据库记录，封装为一个Java对象返回--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--实验3：批量插入--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--实验2：将emp_id=5的记录的salary字段更新为1300.00--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Spring提供了一个类JdbcTemplate，我们用它来操作数据库--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验1：测试数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.user&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.jdbcUrl&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClass&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>dbConfig.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">jdbc.user</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="meta">jdbc.jdbcUrl</span>=<span class="string">jdbc:mysql://localhost:3306/jdbc_template</span></span><br><span class="line"><span class="meta">jdbc.driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<p>Employee</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/1/1 20:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer empId;</span><br><span class="line">    <span class="keyword">private</span> String empName;</span><br><span class="line">    <span class="keyword">private</span> Double Salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(Integer empId, String empName, Double salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.empId = empId;</span><br><span class="line">        <span class="keyword">this</span>.empName = empName;</span><br><span class="line">        Salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getEmpId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> empId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmpId</span><span class="params">(Integer empId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.empId = empId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmpName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> empName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmpName</span><span class="params">(String empName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.empName = empName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(Double salary)</span> </span>&#123;</span><br><span class="line">        Salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Employee&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;empId=&quot;</span> + empId +</span><br><span class="line">                <span class="string">&quot;, empName=&#x27;&quot;</span> + empName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, Salary=&quot;</span> + Salary +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EmployeeDao</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atqingke.bean.Employee;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/1/1 20:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveEmployee</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;INSERT INTO employee(emp_name, salary) VALUES(?, ?)&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql, employee.getEmpName(), employee.getSalary());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TxTest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atqingke.bean.Employee;</span><br><span class="line"><span class="keyword">import</span> com.atqingke.dao.EmployeeDao;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.dao.DataAccessException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/1/1 20:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TxTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ApplicationContext ioc = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    JdbcTemplate jdbcTemplate = ioc.getBean(JdbcTemplate.class);</span><br><span class="line">    NamedParameterJdbcTemplate namedJdbcTemplate = ioc.getBean(NamedParameterJdbcTemplate.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建EmployeeDao，自动装配JdbcTemplate对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test09</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EmployeeDao employeeDao = ioc.getBean(EmployeeDao.class);</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee.setEmpName(<span class="string">&quot;哈哈2&quot;</span>);</span><br><span class="line">        employee.setSalary(<span class="number">5555.55</span>);</span><br><span class="line">        employeeDao.saveEmployee(employee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实验8：重复实验7，以SqlParameterSource形式传入参数值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test08</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;INSERT INTO employee(emp_name, salary) VALUES(:empName, :salary)&quot;</span>;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee.setEmpName(<span class="string">&quot;哈哈&quot;</span>);</span><br><span class="line">        employee.setSalary(<span class="number">5555.55</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> update = namedJdbcTemplate.update(sql, <span class="keyword">new</span> BeanPropertySqlParameterSource(employee));</span><br><span class="line">        System.out.println(update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实验7：使用带有具名参数的SQL语句插入一条员工记录，并以Map形式传入参数值</span></span><br><span class="line"><span class="comment">     * 具名参数：具有名字的参数，参数不是占位符了，而是一个变量名</span></span><br><span class="line"><span class="comment">     *      语法格式：   :参数名</span></span><br><span class="line"><span class="comment">     * Spring有一个支持具名参数功能的JdbcTemplate</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 占位符参数：?的顺序千万不能乱，传参的时候一定注意</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test07</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;INSERT INTO employee(emp_name, salary) VALUES(:empName, :salary)&quot;</span>;</span><br><span class="line">        Map&lt;String, Object&gt; paramMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 将所有具名参数的值都放在map中</span></span><br><span class="line">        paramMap.put(<span class="string">&quot;empName&quot;</span>, <span class="string">&quot;田七&quot;</span>);</span><br><span class="line">        paramMap.put(<span class="string">&quot;salary&quot;</span>, <span class="number">8848.88</span>);</span><br><span class="line">        <span class="keyword">int</span> update = namedJdbcTemplate.update(sql, paramMap);</span><br><span class="line">        System.out.println(update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实验6：查询最大salary</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;SELECT MAX(salary) FROM employee&quot;</span>;</span><br><span class="line">        <span class="comment">// 无论是返回单个数据还是单个对象，都是调用queryForObject</span></span><br><span class="line">        Double aDouble = jdbcTemplate.queryForObject(sql, Double.class);</span><br><span class="line">        System.out.println(aDouble);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实验5：查询salary&gt;4000的数据库记录，封装为List集合返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;SELECT emp_id empId, emp_name empName, salary FROM employee WHERE salary &gt; ?&quot;</span>;</span><br><span class="line">        <span class="comment">// 封装List</span></span><br><span class="line">        List&lt;Employee&gt; employees = jdbcTemplate.query(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Employee.class), <span class="number">4000</span>);</span><br><span class="line">        <span class="keyword">for</span>(Employee employee : employees) &#123;</span><br><span class="line">            System.out.println(employee);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实验4：查询emp_id=5的数据库记录，封装为一个Java对象返回</span></span><br><span class="line"><span class="comment">     * JavaBean需要和数据库中字段名一致，否则无法完成封装</span></span><br><span class="line"><span class="comment">     * jdbcTemplate在方法级别进行了区分</span></span><br><span class="line"><span class="comment">     * 查询结合：jdbcTemplate.query()</span></span><br><span class="line"><span class="comment">     * 查询单个对象：jdbcTemplate.queryForObject()</span></span><br><span class="line"><span class="comment">     *      如果查询没结果就报错</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;SELECT emp_id empId, emp_name empName, salary FROM employee WHERE emp_id = ?&quot;</span>;</span><br><span class="line">        <span class="comment">// 中间这个参数为每一行记录和JavaBean的属性如何映射</span></span><br><span class="line">        Employee employee = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            employee = jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Employee.class), <span class="number">5</span>);</span><br><span class="line">            System.out.println(employee);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DataAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实验3：批量插入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;INSERT INTO employee(emp_name, salary) VALUES(?, ?)&quot;</span>;</span><br><span class="line">        <span class="comment">// List的长度就是sql语句要执行的次数</span></span><br><span class="line">        <span class="comment">// Object[]：每次执行要用的参数</span></span><br><span class="line">        List&lt;Object[]&gt; batchArgs = <span class="keyword">new</span> ArrayList&lt;Object[]&gt;();</span><br><span class="line">        batchArgs.add(<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;zhangsan&quot;</span>, <span class="number">9999.99</span>&#125;);</span><br><span class="line">        batchArgs.add(<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;lisi&quot;</span>, <span class="number">8999.99</span>&#125;);</span><br><span class="line">        batchArgs.add(<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;wangwu&quot;</span>, <span class="number">7999.99</span>&#125;);</span><br><span class="line">        batchArgs.add(<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;zhaoliu&quot;</span>, <span class="number">6999.99</span>&#125;);</span><br><span class="line">        <span class="keyword">int</span>[] batchUpdate = jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> update : batchUpdate) &#123;</span><br><span class="line">            System.out.println(update);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实验2：将emp_id=5的记录的salary字段更新为1300.00</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;UPDATE employee SET salary = ? WHERE emp_id = ?&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> update = jdbcTemplate.update(sql, <span class="number">1300.00</span>, <span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;更新员工：&quot;</span> + update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实验1：测试数据源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        DataSource dataSource = ioc.getBean(DataSource.class);</span><br><span class="line">        Connection connection = dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Spring-AOP(下)</title>
    <url>/2022/01/01/Spring-AOP-%E4%B8%8B/</url>
    <content><![CDATA[<p>书接上回</p>
<h1 id="细节七：抽取可重用的切入点表达式"><a href="#细节七：抽取可重用的切入点表达式" class="headerlink" title="细节七：抽取可重用的切入点表达式"></a>细节七：抽取可重用的切入点表达式</h1><p>我们现在已经了解了四个注解@Before、@After、@AfterReturning和@AfterThrowing。现在我们考虑一个需求，我们的切入点修改了，不是在MyMathCalculator的所有方法下切入，而是MyMathCalculator的add方法中进行切入。我们当然可以对每个注解中的切入点表达式进行修改，但这样过于麻烦。</p>
<p>我们有一个注解@Pointcut，就是专门用来解决这类业务场景的。要使用@Pointcut，首先需要一个空方法，这个方法没有实现，也没有返回值。然后在方法上添加上@Pointcut注解，将切入点表达式写入注解的属性中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(public int com..MyMathCalculator.*(int, int))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myPoint</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们就有了一个可以重复使用的切入点表达式，我们可以将其它注解中的切入点表达式换成我们写的这个公共的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;myPoint()&quot;)</span></span><br><span class="line"><span class="meta">@AfterReturning(value = &quot;myPoint()&quot;, returning=&quot;result&quot;)</span></span><br><span class="line"><span class="meta">@AfterThrowing(value = &quot;myPoint()&quot;, throwing=&quot;exception&quot;)</span></span><br><span class="line"><span class="meta">@After(&quot;myPoint()&quot;)</span></span><br></pre></td></tr></table></figure>

<p>使用这个可重用的切入点表达式就如上面所示的那样简单，只要将切入点表达式换成我们标注有@Pointcut注解的方法名即可。这下，我们要实现这个业务需求就只需要在@Pointcut中修改即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(public int com..MyMathCalculator.add(int, int))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myPoint</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="细节八：环绕通知"><a href="#细节八：环绕通知" class="headerlink" title="细节八：环绕通知"></a>细节八：环绕通知</h1><p>经过前面的介绍，我们就只剩下最后一个注解@Around，顾名思义，这表示的就是环绕通知，我们先来看一下如何使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;myPoint()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">myAround</span><span class="params">(ProceedingJoinPoint pjp)</span> </span>&#123;</span><br><span class="line">    Object[] args = pjp.getArgs();</span><br><span class="line">    String name = pjp.getSignature().getName();</span><br><span class="line">    Object proceed = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 就是利用反射调用目标方法即可</span></span><br><span class="line">        <span class="comment">// @Before</span></span><br><span class="line">        System.out.println(<span class="string">&quot;【环绕通知】&quot;</span> + name + <span class="string">&quot;方法开始&quot;</span>);</span><br><span class="line">        proceed = pjp.proceed(args);</span><br><span class="line">        <span class="comment">// @AfterReturning</span></span><br><span class="line">        System.out.println(<span class="string">&quot;【环绕通知】&quot;</span> + name + <span class="string">&quot;方法返回，返回值&quot;</span> + proceed);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        <span class="comment">// @AfterThrowing</span></span><br><span class="line">        System.out.println(<span class="string">&quot;【环绕通知】&quot;</span> + name + <span class="string">&quot;方法出现异常，异常信息&quot;</span> + throwable);</span><br><span class="line">        <span class="comment">// 为了让普通通知接收到这个异常，我们需要抛出去；否则，普通通知得到的是没有异常的结果</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// @After</span></span><br><span class="line">        System.out.println(<span class="string">&quot;【环绕通知】&quot;</span> + name + <span class="string">&quot;方法结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反射调用后的返回值也一定返回出去</span></span><br><span class="line">    <span class="keyword">return</span> proceed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，环绕通知就和我们一开始写的动态代理类似。ProceedingJoinPoint继承了JoinPoint，proceed方法传参利用反射去调用目标方法，反射调用完后会有返回值，这个返回值一定要返回会出去。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220101162422234.png" alt="image-20220101162422234"></p>
<p>可以看到，如果没有返回出去，普通通知获取不到正确的目标方法返回值。</p>
<p>在这里，我们要注意的是：如果我们在使用环绕通知的同时也开启了普通通知，且发生了异常，为了让普通通知接收到异常信息，我们在环绕通知里需要把这个异常信息抛出去，否则，普通通知得到的是没有异常的结果。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220101161603373.png" alt="image-20220101161603373"></p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220101161754808.png" alt="image-20220101161754808"></p>
<h1 id="细节九：环绕通知的执行顺序"><a href="#细节九：环绕通知的执行顺序" class="headerlink" title="细节九：环绕通知的执行顺序"></a>细节九：环绕通知的执行顺序</h1><p>加入了环绕通知之后的执行顺序，通过上面的例子也可以看到：</p>
<blockquote>
<p>环绕前置、普通前置 —-&gt; 目标方法运行 —-&gt; 环绕正常返回/异常 —-&gt; 环绕后置 —-&gt; 普通后置 —-&gt; 普通正常返回/异常</p>
</blockquote>
<h1 id="细节十：多切面运行顺序"><a href="#细节十：多切面运行顺序" class="headerlink" title="细节十：多切面运行顺序"></a>细节十：多切面运行顺序</h1><p>我们现在只有一个切面类，假设我们有另外一个切面类ValidateAspect。它跟LogUtils拥有一样的功能，只是类名不一样，那么这些通知的执行顺序会是什么样的呢？</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220101163845847.png" alt="image-20220101163845847"></p>
<p>为什么是这样的顺序呢？我们来看一张图就明白了！</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220101164313019.png" alt="image-20220101164313019"></p>
<p>程序首先运行到LogUtils，LogUtils的前置通知开始工作；再到达ValidateAspect，ValidateAspect的前置通知开始工作；然后运行目标方法；目标方法运行完后，又到达ValidateAspect，ValidateAspect开始工作；最后来到LogUtils。</p>
<p>那为什么是先到达LogUtils，再经过ValidateAspect呢？你可以简单认为就是字母L排在V前面。</p>
<p>那如果这个顺序并不是我们想要的，我们想让ValidateAspect先运行要怎么做呢？我们可以在切面类上加一个@Order注解，它就是用来控制切面类的执行顺序。@Order注解中属性的值越小，越有执行优先权。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220101164858386.png" alt="image-20220101164858386"></p>
<h1 id="关于环绕通知和普通通知的一些补充"><a href="#关于环绕通知和普通通知的一些补充" class="headerlink" title="关于环绕通知和普通通知的一些补充"></a>关于环绕通知和普通通知的一些补充</h1><p>通过上面的介绍，我们知道，环绕通知其实就是一个动态代理，它的 pjp.proceed(args); 就和一开始的动态代理中的 method.invoke(calculator, args); 作用一样。因此，环绕通知是可以影响目标方法的运行的。例如，在调用proceed之前，将传入的参数进行修改。而普通通知我们可以看成最初的在方法前后加输出语句，它只是在目标方法运行前后切入一段代码，但是这段代码并不会影响目标方法的运行。所以，如果我们只是做一些简单的日志记录，使用普通通知就够了；而如果我们想要对目标方法做一些干预，就选择环绕通知。</p>
<h1 id="AOP的应用"><a href="#AOP的应用" class="headerlink" title="AOP的应用"></a>AOP的应用</h1><p>到这里，关于SpringAOP就差不多介绍完了。那么AOP可以在哪里使用呢？就像我们一开始的业务场景需求，AOP可以用于以下几个方面：</p>
<ul>
<li>加日志保存到数据库；</li>
<li>做权限验证；</li>
<li>做安全检查；</li>
<li>做事务控制。</li>
</ul>
<h1 id="基于配置文件的AOP"><a href="#基于配置文件的AOP" class="headerlink" title="基于配置文件的AOP"></a>基于配置文件的AOP</h1><p>配合基于注解方式理解食用，这里不做详细解释了！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myCalculator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.impl.MyMathCalculator&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;logUtils&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.utils.LogUtils&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;validateAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.utils.ValidateAspect&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">&quot;execution(public int com..MyMathCalculator.*(int, int))&quot;</span> <span class="attr">id</span>=<span class="string">&quot;globalPoint&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;logUtils&quot;</span> <span class="attr">order</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">&quot;execution(public int com..MyMathCalculator.*(int, int))&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myPoint&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;logStart&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(public int com..MyMathCalculator.*(int, int))&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;logReturn&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPoint&quot;</span> <span class="attr">returning</span>=<span class="string">&quot;result&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;logException&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPoint&quot;</span> <span class="attr">throwing</span>=<span class="string">&quot;exception&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;logEnd&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPoint&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;myAround&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;globalPoint&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;validateAspect&quot;</span> <span class="attr">order</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">&quot;execution(public int com..MyMathCalculator.*(int, int))&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myPoint&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;logStart&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(public int com..MyMathCalculator.*(int, int))&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;logReturn&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPoint&quot;</span> <span class="attr">returning</span>=<span class="string">&quot;result&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;logException&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPoint&quot;</span> <span class="attr">throwing</span>=<span class="string">&quot;exception&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;logEnd&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPoint&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;myAround&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;globalPoint&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="基于注解的AOP步骤"><a href="#基于注解的AOP步骤" class="headerlink" title="基于注解的AOP步骤"></a>基于注解的AOP步骤</h1><ol>
<li>将目标类和切面类都加入到IOC容器中，@Component</li>
<li>告诉Spring哪个是切面类@Aspect</li>
<li>在切面类中使用五个通知注解来配置切面中的这些通知方法都何时何地运行</li>
<li>开启基于注解的AOP功能，<a href="aop:aspectj-autoproxy/">aop:aspectj-autoproxy/</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Spring-AOP(中)</title>
    <url>/2022/01/01/Spring-AOP-%E4%B8%AD/</url>
    <content><![CDATA[<p>下面我们来讨论一些AOP的细节问题！</p>
<h1 id="细节一：IOC容器中保存的是组件的代理对象"><a href="#细节一：IOC容器中保存的是组件的代理对象" class="headerlink" title="细节一：IOC容器中保存的是组件的代理对象"></a>细节一：IOC容器中保存的是组件的代理对象</h1><p>在上一节中如果注意到最后的测试会发现，我们获取的组件是Calculator接口类型的，而不是具体的实现类MyMathCalculator。我们可以在测试中取出这个代理对象来看一下：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220101141637841.png" alt="image-20220101141637841"></p>
<p>可以看到AOP的底层就是动态代理，容器中保存的组件是它的代理对象$Proxy16，而不是本类的类型。</p>
<p>那之前说过，AOP可以解决没有接口实现这个问题。我们来看一下，将接口实现取消，获取MyMathCalculator组件能否运行。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220101141912362.png" alt="image-20220101141912362"></p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220101142021797.png" alt="image-20220101142021797"></p>
<p>可以看到，没有接口实现的时候，就是本类类型，并且cglib帮我们创建好了代理对象。</p>
<h1 id="细节二：切入点表达式写法"><a href="#细节二：切入点表达式写法" class="headerlink" title="细节二：切入点表达式写法"></a>细节二：切入点表达式写法</h1><p>切入点表达式的固定格式是：execution(权限修饰符 返回类型 方法全类名(方法参数))</p>
<p>这这里也有通配符，常用的有两种，一种是“*”号，一种是“.”号。下面我们通过几个具体例子来了解这两种通配符在这里的用法。</p>
<ul>
<li>匹配一个或多个字符：匹配以MyMath开头r结尾的类的所有方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(<span class="keyword">public</span> <span class="keyword">int</span> com.atqingke.impl.MyMath*r.*(<span class="keyword">int</span>, <span class="keyword">int</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li>匹配任意一个参数：匹配两个参数，第一个int类型，第二个任意类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(<span class="keyword">public</span> <span class="keyword">int</span> com.atqingke.impl.MyMath*r.*(<span class="keyword">int</span>, *))</span><br></pre></td></tr></table></figure>

<ul>
<li>*号在路径中，只能匹配一层路径</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(<span class="keyword">public</span> <span class="keyword">int</span> com.*.impl.MyMathCalculator.*(<span class="keyword">int</span>, <span class="keyword">int</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li><p>权限位置不能使用*；权限位置不写就行；public【可选的】</p>
</li>
<li><p>匹配任意多个、任意类型参数</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(<span class="keyword">public</span> <span class="keyword">int</span> com.atqingke.impl.MyMathCalculator.*(..))</span><br></pre></td></tr></table></figure>

<ul>
<li>匹配任意多层路径</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(<span class="keyword">public</span> <span class="keyword">int</span> com..impl.MyMathCalculator.*(<span class="keyword">int</span>, <span class="keyword">int</span>))</span><br></pre></td></tr></table></figure>

<p>在这里我们记住两种就行：</p>
<p>最精确的：execution(public int com.atqingke.impl.MyMathCalculator.add(int, int))</p>
<p>最模糊的：execution(* *(..))：千万别写</p>
<p>当然，还有一些其它的通配符，比如：&amp;&amp;、||、!</p>
<ul>
<li>&amp;&amp;：我们要切入的位置满足这两个表达式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(<span class="keyword">public</span> <span class="keyword">int</span> com.atqingke.impl.MyMathCalculator.*(<span class="keyword">int</span>, <span class="keyword">int</span>)) </span><br><span class="line">&amp;&amp; </span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">int</span> com.atqingke.impl.MyMathCalculator.*(<span class="keyword">int</span>, *))</span><br></pre></td></tr></table></figure>

<ul>
<li>||：满足任意一个表达式即可</li>
<li>!：不满足即可</li>
</ul>
<h1 id="细节三：通知方法的执行顺序"><a href="#细节三：通知方法的执行顺序" class="headerlink" title="细节三：通知方法的执行顺序"></a>细节三：通知方法的执行顺序</h1><p>从前面的例子中我们也可以发现一些关于通知方法的执行顺序，这些通知方法相当于一开始我们写的动态代理的位置如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="meta">@Before</span></span><br><span class="line">     method.invoke(obj, args);</span><br><span class="line">     <span class="meta">@AfterReturning</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">     <span class="meta">@AfterThrowing</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="meta">@After</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当横切关注点正常执行的时候，通知方法的执行顺序为：正常执行：@Before —–&gt; @After —–&gt; @AfterReturning</p>
<p>而如果出现异常执行：@Before —–&gt; @After —–&gt; @AfterThrowing</p>
<h1 id="细节四：JoinPoint获取目标方法的信息"><a href="#细节四：JoinPoint获取目标方法的信息" class="headerlink" title="细节四：JoinPoint获取目标方法的信息"></a>细节四：JoinPoint获取目标方法的信息</h1><p>现在的通知方法打印的日志跟我们最初想要的效果还差一点东西——打印的日志中没有目标方法名、目标方法参数、目标方法返回值以及出现异常时的异常信息。我们都是用“xxx”来代替这些信息的，下面我们就来说一下如何获取这些信息。</p>
<p>在org.aspectj.lang包下有一个类JoinPoint，它就是AOP提供给我的用来获取目标方法执行时候的相关信息。其中有一个getArgs()方法，用来<strong>获取目标方法运行时使用的参数</strong>；getSignature()方法用来获取目标方法的签名，通过获取到的签名signature，我们可以通过signature.getName()<strong>获取目标方法名</strong>。关于JoinPoint以及Signature的更多方法，大家可以查看它们的源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(public int com..MyMathCalculator.*(int, int))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">logStart</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取到目标方法运行的时候使用的参数</span></span><br><span class="line">    Object[] args = joinPoint.getArgs();        </span><br><span class="line">    Object aThis = joinPoint.getThis();        </span><br><span class="line">    Object target = joinPoint.getTarget();        </span><br><span class="line">    SourceLocation sourceLocation = joinPoint.getSourceLocation();     </span><br><span class="line">    String kind = joinPoint.getKind();</span><br><span class="line">    System.out.println(<span class="string">&quot;joinPoint.getThis() = &quot;</span> + aThis + <span class="string">&quot;\njoinPoint.getTarget() = &quot;</span> + target + <span class="string">&quot;\njoinPoint.getSourceLocation() = &quot;</span> + sourceLocation + <span class="string">&quot;\njoinPoint.getKind() = &quot;</span> + kind);</span><br><span class="line">    <span class="comment">// 获取到方法签名</span></span><br><span class="line">    Signature signature = joinPoint.getSignature();</span><br><span class="line">    <span class="comment">// 获取方法名</span></span><br><span class="line">    String name = signature.getName();</span><br><span class="line">    <span class="keyword">int</span> modifiers = signature.getModifiers();</span><br><span class="line">    Class declaringType = signature.getDeclaringType();</span><br><span class="line">    String declaringTypeName = signature.getDeclaringTypeName();</span><br><span class="line">    System.out.println(<span class="string">&quot;【&quot;</span> + name + <span class="string">&quot;】方法开始了，它使用的参数是【&quot;</span> + Arrays.toString(args) + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;signature.getName() = &quot;</span> + name + <span class="string">&quot;\nsignature.getModifiers() = &quot;</span> + modifiers + <span class="string">&quot;\nsignature.getDeclaringType() = &quot;</span> + declaringType + <span class="string">&quot;\nsignature.getDeclaringTypeName() = &quot;</span> + declaringTypeName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220101153721043.png" alt="image-20220101153721043"></p>
<h1 id="细节五：throwing-amp-returning"><a href="#细节五：throwing-amp-returning" class="headerlink" title="细节五：throwing &amp; returning"></a>细节五：throwing &amp; returning</h1><p>既然可以在通知方法上加参数，那么我们是不是也可以多加两个参数表示返回值和异常信息？答案是肯定的，只不过我们需要<strong>告诉Spring这是目标方法的返回值和异常信息</strong>，这就通过在注解中添加returning和throwing属性来解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(value = &quot;execution(public int com..MyMathCalculator.*(int, int))&quot;, returning=&quot;result&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">logReturn</span><span class="params">(JoinPoint joinPoint, Object result)</span> </span>&#123;</span><br><span class="line">    Signature signature = joinPoint.getSignature();</span><br><span class="line">    String name = signature.getName();</span><br><span class="line">    System.out.println(<span class="string">&quot;【&quot;</span> + name + <span class="string">&quot;】方法执行完成，计算结果是：&quot;</span> + result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterThrowing(value = &quot;execution(public int com..MyMathCalculator.*(int, int))&quot;, throwing=&quot;exception&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">logException</span><span class="params">(JoinPoint joinPoint, Exception exception)</span> </span>&#123;</span><br><span class="line">    Signature signature = joinPoint.getSignature();</span><br><span class="line">    String name = signature.getName();</span><br><span class="line">    System.out.println(<span class="string">&quot;【&quot;</span> + name + <span class="string">&quot;】方法执行出现异常了，异常信息是：&quot;</span> + exception + <span class="string">&quot;；这个异常已经通知测试小组进行排查！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="细节六：Spring对通知方法的约束"><a href="#细节六：Spring对通知方法的约束" class="headerlink" title="细节六：Spring对通知方法的约束"></a>细节六：Spring对通知方法的约束</h1><p>Spring对通知方法的要求并不是很严格，唯一要求的就是方法的参数列表一定不能乱写。通知方法是Spring利用反射调用的，每次都用都需要先确定这个方法的参数的值。也就是说，我们的告诉Spring每一个参数是什么意思。</p>
<p>前面我们使用的joinPoint我们没有在注解的属性中说明，是因为JoinPoint是Spring自己认识的。而我们写的result和exception，Spring并不认识，因此，我们必须在注解的属性中显式的说明。</p>
]]></content>
  </entry>
  <entry>
    <title>Spring-AOP(上)</title>
    <url>/2021/12/31/Spring-AOP-%E4%B8%8A/</url>
    <content><![CDATA[<p>我们都知道，Java是一种OOP语言，也就是Object Oriented Programming，面向对象编程。而Spring中的AOP，则是Aspect Oriented Programming，面向切面编程——基于OOP的新的编程思想。那么什么是面向切面编程呢？我们用一句话来说就是：<strong>指在程序运行期间，将某段代码动态的切入到指定方法的指定位置进行运行的这种编程方式</strong>，就是面向切面编程。</p>
<p>下面我们通过一个具体的业务场景来认识它！</p>
<p>假设我们有一个计算器类MyMathCalculator，它继承于Calculator接口。MyMathCalculator实现了Calculator中的4个方法add、sub、mul和div。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220101000232218.png" alt="image-20220101000232218"></p>
<p>现在我们想要在每个方法运行之前打印一条日志记录，日志内容为“【什么方法】开始运行了，参数为：”。在每个方法运行结束之前打印一条日志记录，日志内容为“【什么方法】结束运行了，运算结果是：”。</p>
<p>要实现这个业务功能也很简单，我们可以简单的在这四个实现方法中的开始和结束分别加上一条System输出语句。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220101000905342.png" alt="image-20220101000905342"></p>
<p>但是如果这是我们的需求又发生改变，我们把日志内容进行修改了，或者开始运行这条日志记录我们不需要了。这时候，我们就需要对每一个方法进行修改，而我们现在仅仅是只有四个方法，那如果有四十个、四百个方法呢？这样修改过于复杂、且没有什么实际意义。</p>
<p>所以我们真正想要实现的目标是：业务逻辑当中，不要出现日志记录这种辅助功能。我们写一个日志模块，在核心功能运行期间，它可以自己动态地加上。</p>
<h1 id="动态代理？？？"><a href="#动态代理？？？" class="headerlink" title="动态代理？？？"></a>动态代理？？？</h1><p>我们能想到的一种办法是可以使用动态代理来解决这个在方法运行前以及运行结束时添加日志，我们可以新建一个代理类CalculatorProxy帮助Calculator类生成代理对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atqingke.inter.Calculator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 帮Calculator.java生成代理对象的类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/29 22:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为传入的参数创建一个动态代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> calculator 被代理对象 内部类要使用参数必须将参数设置为final的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Calculator <span class="title">getProxy</span><span class="params">(<span class="keyword">final</span> Calculator calculator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法执行器，帮我们目标对象执行目标方法</span></span><br><span class="line">        InvocationHandler h = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 利用反射执行目标方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> proxy 代理对象，给JDK使用，任何时候都不要动这个对象</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> method 当前将要执行的目标对象的方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> args 这个方法调用时外界传入的参数值</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span> 返回值必须返回出去外界才能拿到真正执行后的返回值</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                Object result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;【&quot;</span> + method + <span class="string">&quot;】方法开始了，它使用的参数是【&quot;</span> + Arrays.toString(args) + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">                    result = method.invoke(calculator, args);</span><br><span class="line">                    System.out.println(<span class="string">&quot;【&quot;</span> + method + <span class="string">&quot;】方法执行完成，计算结果是：&quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;【&quot;</span> + method + <span class="string">&quot;】方法执行出现异常了，异常信息是：&quot;</span> + exception + <span class="string">&quot;；这个异常已经通知测试小组进行排查！&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;【&quot;</span> + method + <span class="string">&quot;】方法最终结束了!!!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ClassLoader loader = calculator.getClass().getClassLoader();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = calculator.getClass().getInterfaces();</span><br><span class="line">        Object proxy = Proxy.newProxyInstance(loader, interfaces, h);</span><br><span class="line">        <span class="keyword">return</span> (Calculator) proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们讨论的是SpringAOP，关于这个代理类的具体细节就不做讨论了！</p>
<p>这样做看起来很方便，也很好用，但是实际中还是由两个问题：</p>
<ul>
<li>第一个问题就是这个代理类写起来难。</li>
<li>第二个问题是JDK默认的动态代理，如果目标对象没有实现任何接口，是无法为它创建代理对象的。</li>
</ul>
<p>关于第一个问题我们不做详细探讨，我们来看第二个问题。我们将MyMathCalculator类取消对Calculator的实现</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220101002841522.png" alt="image-20220101002841522"></p>
<p>这是我们再进行测试，可以看到没有任何日志打印</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220101002920130.png" alt="image-20220101002920130"></p>
<p>因此，使用动态代理也不能很好的解决我们所遇到的问题。</p>
<p>接下来我们看使用Spring的AOP！</p>
<h1 id="AOP！！！"><a href="#AOP！！！" class="headerlink" title="AOP！！！"></a>AOP！！！</h1><p>首先，我们先在配置文件中开启基于注解的AOP功能：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220101003206313.png" alt="image-20220101003206313"></p>
<p>接下来，我们来看一下AOP中有哪些注解：</p>
<blockquote>
<p>@Before 在目标方法之前运行                                         前置通知</p>
<p>@After 在目标方法结束之后运行                                     后置通知</p>
<p>@AfterReturning 在目标方法正常返回之后运行           返回通知</p>
<p>@AfterThrowing 在目标方法抛出异常之后运行            异常通知</p>
<p>@Around                                                                          环绕通知</p>
</blockquote>
<p>现在，我们就来写一个类LogUtils来使用AOP：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/31 16:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span>	<span class="comment">// 告诉Spring这是一个切面类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(public int com.atqingke.impl.MyMathCalculator.*(int, int))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">logStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【xxx】方法开始了，它使用的参数是【xxx】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;execution(public int com.atqingke.impl.MyMathCalculator.*(int, int))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">logReturn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【xxx】方法执行完成，计算结果是：【xxx】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;execution(public int com.atqingke.impl.MyMathCalculator.*(int, int))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">logException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【xxx】方法执行出现异常了，异常信息是：【xxx】；这个异常已经通知测试小组进行排查！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(public int com.atqingke.impl.MyMathCalculator.*(int, int))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">logEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【xxx】方法最终结束了!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220101010756196.png" alt="image-20220101010756196"></p>
<p>在这里，我们先不讨论关于参数的问题。我们可以看到，通过这几个注解，我们得到了我们想要的效果！</p>
<p>下面我们来看几个关于AOP的术语：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220101005534247.png" alt="image-20220101005534247"></p>
<ul>
<li><strong>横切关注点</strong>。在图中，我们可以清楚的看到，所谓的横切关注点，就是指从每个方法中抽取出来的同一类非核心业务。在这里，有四个抽取出来的业务，分别是方法开始时、方法返回时、方法出现异常时、方法结束时需要执行的一系列操作。</li>
<li><strong>通知方法</strong>。实现横切关注点的方法。</li>
<li><strong>切入点</strong>。假设我们只需要在add方法结束时、mul方法返回时、div方法异常时打印日志，其它位置或者其它方法我们不进行任何操作。那么这三个点就是我们需要执行操作的地方，也就是我们的切入点。</li>
<li><strong>连接点</strong>。见图。</li>
<li><strong>切入点表达式</strong>。通过一个表达式，告诉通知方法需要对业务中的哪些方法进行切入。</li>
<li><strong>切面类</strong>。横切关注点 + 通知方法 = 切面类。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>文件共享与保护</title>
    <url>/2021/12/31/%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4/</url>
    <content><![CDATA[<h1 id="1-文件共享"><a href="#1-文件共享" class="headerlink" title="1. 文件共享"></a>1. 文件共享</h1><p>文件共享使多个用户（进程）共享同一个文件，系统中只需保留该文件的一个副本。随着计算机技术的发展，文件共享的范围已由单机系统发展到多机系统，进而通过网络扩展到全球。这些文件的共享是通过分布式文件系统、远程文件系统、分布式信息系统实现的。这些系统运行多个客户通过C/S模型共享网络中的服务器文件。</p>
<p>现代常用的两种文件共享方法如下：</p>
<h2 id="1-1-基于索引结点的共享方式（硬链接）"><a href="#1-1-基于索引结点的共享方式（硬链接）" class="headerlink" title="1.1 基于索引结点的共享方式（硬链接）"></a>1.1 基于索引结点的共享方式（硬链接）</h2><p>在树形结构的目录中，当有两个或多个用户要共享一个子目录或文件时，必须将共享文件或子目录链接到两个或多个用户的目录中，才能方便地找到该文件，如图所示：</p>
<p><img src="C:/Users/pengbin007/AppData/Roaming/Typora/typora-user-images/image-20220101194616578.png" alt="image-20220101194616578"></p>
<p>在这种共享方式中，诸如文件的物理地址及其他的文件属性等信息，不再放到目录项中，而放在索引结点中。在文件目录中只设置文件名及指向相应索引结点的指针。在索引结点中还应有一个链接计数count，用于表示链接到本索引结点上的用户目录项的数目。</p>
<p>用户A创建一个新文件时，将count置为1。如果此时用户B要共享此文件，则在B的目录中增加一个目录项，并设置一个指针指向该文件的索引结点，此时count = 2。如果A不再使用该文件，A不能删除该文件，因为删除该文件意味着索引结点也被删除了，那么B的指针指向将会失效。因此A只能将count减1，然后删除自己目录中的相应目录项。当count = 0时，表示没有用户使用该文件，系统将负责删除该文件。如图给出了B链接到文件上的前、后情况。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220101194906651.png" alt="image-20220101194906651"></p>
<h2 id="1-2-利用符号链实现文件共享（软链接）"><a href="#1-2-利用符号链实现文件共享（软链接）" class="headerlink" title="1.2 利用符号链实现文件共享（软链接）"></a>1.2 利用符号链实现文件共享（软链接）</h2><p>为使用户B能共享用户A的一个文件F，可以由系统创建一个LINK类型的新文件，也取名为F，并将文件F写入用户B的目录中，以实现用户B的目录与文件F的链接。在新文件中只包含被链接文件F的路径名。这样的链接方法称为<strong>符号链接</strong>。</p>
<p>新文件中的路径名只被视为符号链，当用户B要访问被链接的文件F且正要读LINK类新文件时，OS根据新文件中的路径名去读该文件，从而实现用户B的文件F的共享。</p>
<p>在利用符号链方式实现文件共享时，只有文件的拥有者才拥有指向其索引结点的指针。而共享该文件的其它用户只有该文件的路径名。这样，就不会发生文件主删除文件后，指针悬空的情况。此时，文件删除后，其它用户通过符号链访问它，会出现访问失败，于是将符号链删除，不会产生任何影响。但是，利用符号链依旧存在一个问题：当文件拥有者删除文件后，在其它用户使用符号链访问该文件之前，又有人在同一路径下创建了另一个同名的文件，则该符号链依旧有效，但访问的路径已经改变，从而导致错误。</p>
<p>在符号链的共享方式中，当其它用户读共享文件时，需要根据文件路径名逐个查找目录，直至找到该文件的索引结点。因此，每次访问时，都可能需要多次读盘，使得访问文件的开销变大且增加了启动磁盘的频率。此外，符号链的索引结点也要耗费一定的存储空间。</p>
<p>符号链有一个很大的优点：网络共享只需提供该文件所在机器的网络地址及该机器中的文件路径。</p>
<p>上述两种链接方式都存在一个共同的问题，即每个共享文件都有几个文件名。换言之，每增加一条连接，就增加一个文件名。这实质上是每个用户都使用自己的路径区访问共享文件。当我们试图去遍历整个文件系统时，将会多次遍历到该共享文件。</p>
<p>硬链接和软链接都是文件系统中的静态共享方法，在文件系统中还存在着另外的共享需求u，即两个进程同时对同一个文件进行操作，这样的共享称为动态共享。</p>
<p>可以这样说：文件共享，“软”“硬”兼施。硬链接就是多个指针指向同一个索引结点，保证只要还有一个指针指向索引结点，索引结点就不能删除；软链接就是把到达共享文件的路径记录下来，当要访问文件时，根据路径寻找文件，可以想象，硬链接的查找速度要比软链接块。</p>
<h1 id="2-文件保护"><a href="#2-文件保护" class="headerlink" title="2. 文件保护"></a>2. 文件保护</h1><p>为了防止文件共享可能会导致文件被破坏或未经核准的用户修改文件，文件系统必须控制用户对文件的存取，即解决对文件的读、写、执行的许可问题。为此，必须在文件系统中建立相应的文件保护机制。</p>
<p>文件保护通过口令保护、加密保护和访问控制等方式实现。其中，口令保护和加密保护是为了防止用户文件被他人窃取，而访问控制则用于控制用户对文件的访问方式。</p>
<h2 id="2-1-访问类型"><a href="#2-1-访问类型" class="headerlink" title="2.1 访问类型"></a>2.1 访问类型</h2><p>可加以控制的访问类型主要有以下几种：</p>
<ul>
<li>读。从文件中读。</li>
<li>写。向文件中写。</li>
<li>执行。将文件装入内存并执行。</li>
<li>添加。将新信息添加到文件结尾部分。</li>
<li>删除。删除文件，释放空间。</li>
<li>列表清单。列出文件名和文件属性。</li>
</ul>
<p>此外还可以对文件的重命名、复制、编辑等加以控制。这些高层的功能可以通过系统调用底层系统调用来实现。保护可以只在底层提供。</p>
<h2 id="2-2-访问控制"><a href="#2-2-访问控制" class="headerlink" title="2.2 访问控制"></a>2.2 访问控制</h2><p>解决访问控制最常用的方法是根据用户身份进行控制。而实现基于身份访问的最为普通的方法是，为每个文件和目录增加一个访问控制列表（Access-Control List，ACL），以规定每个用户名及其所允许的访问类型。</p>
<p>这种方法的优点是可以使用复杂的访问方法，缺点是长度无法预计并且可能导致复杂的空间管理，使用精简的访问列表可以解决这个问题。</p>
<p>精简的访问列表采用拥有者、组和其它三种用户类型。这样，只需用三个域即可列出访问表中这三类用户的访问权限。文件拥有者在创建文件时，说明创建者用户名及所在的组名，系统在创建文件时也将文件主的名字、所属组名列在该文件的FCB中。</p>
<p>口令和密码是另外两种访问控制方法。</p>
<p><strong>口令</strong>是指用户在建立一个文件时提供一个口令，系统为其建立FCB时附上相应口令，同时告诉允许共享该文件的其它用户。用户请求访问时必须提供相应的口令。这种方法时间和空间的开销不多，缺点是口令直接存在系统内部，不够安全。</p>
<p><strong>密码</strong>是指用户对文件进行加密，文件被访问时需要使用密钥。这种方法保密性强，节省了存储空间，不过编码和译码要花费一定的时间。</p>
<p>口令和密码都是防止用户文件被他人窃取，并没有控制用户对文件的访问类型。</p>
<p>注意两个问题：</p>
<ol>
<li>现代OS常用的文件保护方法是，将访问控制列表与用户、组和其它成员访问控制方案一起组合使用。</li>
<li>对于多级目录结构而言，不仅需要保护单个文件，而且需要保护子目录内的文件，即需要提供目录保护机制。目录操作与文件操作并不相同，因此需要不同的保护机制。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>文件实现——文件存储空间管理</title>
    <url>/2021/12/31/%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="1-文件存储器空间的划分与初始化"><a href="#1-文件存储器空间的划分与初始化" class="headerlink" title="1. 文件存储器空间的划分与初始化"></a>1. 文件存储器空间的划分与初始化</h1><p>一般来说，一个文件存储在一个文件卷中。文件卷可以是物理盘的一部分，也可以是整个物理盘，支持超大型文件的文件卷也可由多个物理盘组成，如图所示。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211231220016669.png" alt="image-20211231220016669"></p>
<p>在一个文件卷中，文件数据信息的空间（文件区）和存放文件控制信息FCB的空间（目录区）是分离的。由于存在许多种类的文件表示和存放格式，所以现代OS中一般都有很多不同的文件管理模块，通过它们可以访问不同格式的逻辑卷中的文件。逻辑卷在提供文件服务前，必须由对应的文件程序进行初始化，划分好目录区和文件区，建立空闲空间管理表格及存放逻辑卷信息的超级块。</p>
<h1 id="2-文件存储器空间管理"><a href="#2-文件存储器空间管理" class="headerlink" title="2. 文件存储器空间管理"></a>2. 文件存储器空间管理</h1><p>文件存储设备分成许多大小相同的物理块，并以快为单位交换信息，因此，文件存储设备的管理实质上是对空闲块的组织和管理，它包括空闲块的组织、分配与回收等问题。</p>
<h2 id="2-1-空闲表法"><a href="#2-1-空闲表法" class="headerlink" title="2.1 空闲表法"></a>2.1 空闲表法</h2><p>空闲表法属于连续分配方式，它与内存的动态分配方式类似，为每个文件分配一块连续的存储空间。系统为外存上的所有空闲区建立一张空闲盘块表。空闲盘区的分配与内存的动态分配类似，同样采用首次适应算法、循环首次适应算法等。系统在对用户所释放的存储空间进行回收时，也采取类似于内存回收的方法，即要考虑回收区是否与空闲表中插入点的前区和后区相邻接，对相邻接者应予以合并。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211231220201168.png" alt="image-20211231220201168"></p>
<h2 id="2-2-空闲链表法"><a href="#2-2-空闲链表法" class="headerlink" title="2.2 空闲链表法"></a>2.2 空闲链表法</h2><p>根据构成链所用的基本元素不同，可把链表分成两种形式：空闲盘块链和空闲盘区链。</p>
<p>空闲盘块链将磁盘上的所有空闲空间以盘块为单位拉成一条链。这种方法的优点是分配和回收一个盘块的过程非常简单，但在为一个文件分配盘块时可能要重复多次操作。</p>
<p>空闲盘区链将磁盘上的所有空闲盘区（每个盘区可包含若干盘块）拉成一条链。在每个盘区上除含有用于指示下一个空闲盘区的指针外，还应有能指明本盘区大小（盘块数）的信息。分配的方法与动态分区分配类似，通常采用首次适应算法。在回收盘区时，同样也要将回收区与相邻接的空闲盘区合并。</p>
<h2 id="2-3-位示图法"><a href="#2-3-位示图法" class="headerlink" title="2.3 位示图法"></a>2.3 位示图法</h2><p>位示图利用二进制的一位来表示磁盘中的一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。当其值为“0”时，表示对应的盘块空闲；当其值为“1”时，表示对应的盘块已分配，如图：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211231220915119.png" alt="image-20211231220915119"></p>
<p>盘块的分配：</p>
<ol>
<li>顺序扫描位示图，从中找出一个或一组其值为“0”的二进制位。</li>
<li>将找到的一个或一组二进制位，转换成与之对应的盘块号。若找到的其值位“0”的二进制位位于位示图的第i行、第j列，则其相应的盘块号应按下式计算（n代表每行的位数）：b = n * (i  - 1) + j </li>
<li>修改位示图，令map[i, j] = 1</li>
</ol>
<p>盘块的回收：</p>
<ol>
<li>将回收盘块的盘块号转换成位示图中的行号和列号。转换公式为：i = (b - 1) DIV n + 1;    j = (b - 1) MOD n + 1</li>
<li>修改位示图，令map[i, j] = 0</li>
</ol>
<h2 id="2-4-成组链接法"><a href="#2-4-成组链接法" class="headerlink" title="2.4 成组链接法"></a>2.4 成组链接法</h2><p>空闲表法和空闲链表法都不适用于大型文件系统，因为这会使空闲表或空闲链表太大。在UNIX系统中采用的是成组链接法，这种方法结合了这两种方法，克服了表太大的缺点。其大致思想是：把顺序的n个空闲扇区地址保存在第一个空闲扇区内，其最后一个空闲扇区内则保存另一组顺序空闲扇区的地址，如此继续，直至所有空闲扇区均予以链接。系统只需要保存一个指向第一个空闲扇区的指针。假设磁盘最初全为空闲扇区，其成组链接如图所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211231221706964.png" alt="image-20211231221706964"></p>
<p>通过这种方式可以迅速找到大批空闲块地址。</p>
<p>表示文件存储器空闲空间的“位向量”表或第一个成组链块，以及卷中的目录区、文件区划分信息都需要存放在辅存储器中，一般放在卷头位置，在UNIX系统中称为<strong>超级块</strong>。在对卷中的文件进行操作前，超级块需要预先读入系统空闲的主存，并且经常保持主存超级块与辅存卷中超级块的一致性。</p>
<blockquote>
<p>在这里，我们使用的位示图法中行和列都是从1开始编号。特别注意，若题目指明从0开始编号，则上述计算方法要进行相应调整。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>文件实现——文件分配方式</title>
    <url>/2021/12/31/%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>文件的实现其实就是研究文件的物理结构，即文件数据在物理存储设备上是如何分布和组织的。而文件的实现又分为两个方面：一是文件的分配方式，也就是对磁盘非空闲块的管理；二是文件存储空间管理，对磁盘空闲块的管理。</p>
<p>常用的磁盘空间分配有三种：连续分配、链接分配和索引分配。</p>
<h1 id="1-连续分配"><a href="#1-连续分配" class="headerlink" title="1. 连续分配"></a>1. 连续分配</h1><p>连续分配方法要求每个文件在磁盘上占有一组连续的块，如图所示，。磁盘地址定义了磁盘上的一个线性排序。这种排序使作业访问磁盘时需要的寻道数和寻道时间最小。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211231203004646.png" alt="image-20211231203004646"></p>
<p>文件的连续分配可以用第一块的磁盘地址和连续块的数量来定义。一个文件的目录条目包括开始块的地址和该文件所分配区域的长度。</p>
<p>连续分配支持顺序访问和直接访问。其优点是实现简单、存取速度快。</p>
<p>缺点是文件长度不易动态增加，因为一个文件末尾后的盘块可能已分配给其它文件，一旦需要增减，就需要大量移动盘块。此外，反复增删文件后会产生外部碎片，且很难确定一个文件需要的空间大小，因而只适用于长度固定的文件。</p>
<h1 id="2-链接分配"><a href="#2-链接分配" class="headerlink" title="2. 链接分配"></a>2. 链接分配</h1><p>链接分配采取离散分配的方式，消除了外部碎片，因此显著提高了磁盘空间的利用率；而且，当文件动态增长时，也能动态地再为它分配盘块。此外，对文件的增、删、改也非常方便。链接分配又分为隐式链接和显式链接。</p>
<h2 id="2-1-隐式链接"><a href="#2-1-隐式链接" class="headerlink" title="2.1 隐式链接"></a>2.1 隐式链接</h2><p>如图，每个文件对应一个磁盘块的链表；磁盘块分布在磁盘的任何地方，出最后一个磁盘块外，每个盘块都有指向下一个盘块的指针，这些指针对用户是透明的。目录包括文件的第一块指针和最后一块的指针。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211231203637822.png" alt="image-20211231203637822"></p>
<p>创建新文件时，目录中增加一个新条目。每个目录项都由一个指向文件首块的指针。该指针初始化为NULL以表示空文件，大小字段为0.写文件会通过空闲空间管理系统找到空闲块，将该块链接到文件的尾部，以便写入。该文件则通过块到块的指针顺序读块。</p>
<p>隐式链接分配的缺点是无法直接访问磁盘块，且盘块指针会消耗一定的存储空间。而且它的稳定性也是一个问题，系统在运行过程中由于软件或硬件错误导致链表中的指针丢失或损坏，会导致文件数据的丢失。</p>
<h2 id="2-2-显式链接"><a href="#2-2-显式链接" class="headerlink" title="2.2 显式链接"></a>2.2 显式链接</h2><p>显式链接是指把用于链接文件各物理块的指针，从每个物理块的块末尾中提取出来，显式地存放在内存的一张链表中。该表在整个磁盘中仅设置一张，称为<strong>文件分配表（File Allocation Table，FAT）</strong>。每个表项中存放对应块的下一块链接指针，即下一个盘块号。文件的第一个盘块号记录在目录中。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211231204343174.png" alt="image-20211231204343174"></p>
<p>如图，在这里我们用-1表示文件的最后一块，用-2表示这个磁盘块空闲。因此，FAT不仅记录了文件各块之间的先后链接关系，同时还标记了空闲的磁盘块，OS也可以通过FAT对文件存储空间进行管理。</p>
<p>FAT表在系统启动时就会被读入内存，因此查找FAT的过程是在内存中进行的，因此不仅显著地提高了检索速度，而且明显减少了访问磁盘的次数。</p>
<h1 id="3-索引分配"><a href="#3-索引分配" class="headerlink" title="3. 索引分配"></a>3. 索引分配</h1><p>链接分配虽然解决了连续分配的外部碎片和文件大小管理的问题，但是，链接分配不能有效支持直接访问（FAT除外）。索引分配则解决了这个问题，它把每个文件的所有的盘块号都集中放在一起构成<strong>索引块（表）</strong>，如图所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211231205558889.png" alt="image-20211231205558889"></p>
<p>每个文件都有其索引块，这是一个磁盘块地址的数组。索引块的第i个条目指向文件的第i个块。目录条目包括索引块的地址。</p>
<p>创建文件时，索引块的所有指针都设为空。首次写入第i块时，先从空闲空间中取得一个块，在将其地址写到索引块的第i个条目。索引分配支持直接访问，且没有外部碎片。其缺点是由于索引块的分配，增加了系统存储空间的开销。</p>
<p>索引块的大小是一个重要的问题，每个文件必须有一个索引块，因此索引块应尽可能小，但索引块太小就无法支持大文件。可以采用以下机制来处理这个问题。</p>
<ul>
<li><strong>链接方案</strong>。一个索引块通常为一个磁盘块，因此它本身能直接读写。为了处理大文件，可以将多个索引块链接起来。</li>
<li><strong>多层索引</strong>。多层索引使第一层索引块指向第二层的索引块，第二层索引块再指向文件块。这种方法根据最大文件大小的要求，可以继续到第三次或第四层。</li>
<li><strong>混合索引</strong>。将多种索引分配方式相结合的分配方式。例如，系统既采用直接地址，又采用单级索引分配方式和多级索引分配方式。</li>
</ul>
<h1 id="4-三种分配方式的比较"><a href="#4-三种分配方式的比较" class="headerlink" title="4. 三种分配方式的比较"></a>4. 三种分配方式的比较</h1><table>
<thead>
<tr>
<th></th>
<th>访问第n条记录</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>连续分配</td>
<td>需访问磁盘1次</td>
<td>顺序存储时速度快，文件定长时可根据文件起始地址及记录长度进行随机访问</td>
<td>文件存储要求连续的存储空间，会产生碎片，不利于文件的动态扩充</td>
</tr>
<tr>
<td>链接分配</td>
<td>需访问磁盘n次</td>
<td>可解决外存的碎片问题，提高外存空间的利用率，动态增长较方便</td>
<td>只能按照文件的指针链顺序访问，查找效率低，指针信息存放消耗外存空间</td>
</tr>
<tr>
<td>索引分配</td>
<td>m级需访问磁盘m + 1次</td>
<td>可以随机访问，文件易于增删</td>
<td>索引表增加存储空间的开销，索引表的查找策略对文件系统效率影响较大</td>
</tr>
</tbody></table>
<p>此外，访问文件需要两次访问外存——首先要读取索引块的内容，然后访问具体的磁盘块，因而降低了文件的存取速度。为解决这一问题，通常将文件的索引块读入内存的缓冲区中，以加快文件的访问速度。</p>
]]></content>
  </entry>
  <entry>
    <title>经典IPC问题</title>
    <url>/2021/12/30/%E7%BB%8F%E5%85%B8IPC%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>前P后V</li>
<li>互斥信号量初值一般为1</li>
<li>同步信号量初值一般为0</li>
</ul>
</blockquote>
<h1 id="1-生产者-消费者问题"><a href="#1-生产者-消费者问题" class="headerlink" title="1. 生产者-消费者问题"></a>1. 生产者-消费者问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>一组生产者进程和一组消费者进程共享一个初始为空、大小为n的缓冲区，只有缓冲区没满时，生产者才能把消息放入缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或一个消费者从中取出消息。</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="关系分析"><a href="#关系分析" class="headerlink" title="关系分析"></a>关系分析</h3><p>生产者和消费者对缓冲区的访问具有互斥关系，同时生产者和消费者又是相互协作的同步关系。</p>
<h3 id="整理思路"><a href="#整理思路" class="headerlink" title="整理思路"></a>整理思路</h3><p>这里有生产者和消费者两个进程，两个进程既是同步又是互斥，我们只要设置好PV操作的位置即可</p>
<h3 id="信号量设置"><a href="#信号量设置" class="headerlink" title="信号量设置"></a>信号量设置</h3><p>信号量mutex作为互斥信号量，用于控制互斥访问缓冲池，初值为1；信号量full用于记录当前“满”缓冲区数，初值为0；信号量empty用于记录空闲缓冲区，初值为n。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;	<span class="comment">// 临界区互斥信号量</span></span><br><span class="line">semaphore empty = n;	<span class="comment">// 空闲缓冲区</span></span><br><span class="line">semaphore full = <span class="number">0</span>;		<span class="comment">// 缓冲区初始化为空</span></span><br><span class="line">producer() &#123;	<span class="comment">// 生产者进程</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        produce an item in nextp;	<span class="comment">// 生产者生产好产品，将要将产品放入缓冲区</span></span><br><span class="line">        P(empty);				<span class="comment">// 生产者进程将要对空闲缓冲区操作，空闲缓冲区数量减少</span></span><br><span class="line">        P(mutex);				<span class="comment">// 互斥信号量“夹紧”临界区</span></span><br><span class="line">        add nextp to buffer;	<span class="comment">// 临界区，缓冲区为临界资源</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);				<span class="comment">// 生产者进程结束对空闲缓冲区的操作，“满”缓冲区数量增加</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">consumer() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(full);		<span class="comment">// 消费者要对“满”缓冲区操作，“满”缓冲区数量减少</span></span><br><span class="line">        P(mutex);		<span class="comment">// 互斥夹紧</span></span><br><span class="line">        remove an item from buffer; 	<span class="comment">// 临界区</span></span><br><span class="line">        V(mutex);		</span><br><span class="line">        V(empty);		<span class="comment">// 消费者结束对“满”缓冲区操作，空闲缓冲区增加</span></span><br><span class="line">        consumer the item;		<span class="comment">// 剩余区，消费者消费进程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-多生产者-消费者问题"><a href="#2-多生产者-消费者问题" class="headerlink" title="2.多生产者-消费者问题"></a>2.多生产者-消费者问题</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>桌子上有一个盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈放橘子，儿子专等吃盘子中的橘子，女儿吃苹果。只有盘子为空时，爸爸或妈妈才可向盘子中放一个水果；仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出。</p>
<h2 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="关系分析-1"><a href="#关系分析-1" class="headerlink" title="关系分析"></a>关系分析</h3><p>爸爸和妈妈对盘子的访问是互斥操作；爸爸和女儿对苹果的操作是同步关系；妈妈和儿子对橘子的操作是同步关系；儿子和女儿之间没有同步互斥关系。</p>
<h3 id="整理思路-1"><a href="#整理思路-1" class="headerlink" title="整理思路"></a>整理思路</h3><p>这里有爸爸、妈妈、儿子、女儿四个进程，实际上可以抽象成两个生产者进程和两个消费者进程对一个大小为1的缓冲区的进行操作。</p>
<h3 id="信号量设置-1"><a href="#信号量设置-1" class="headerlink" title="信号量设置"></a>信号量设置</h3><p>信号量plate为互斥信号量；apple用于实现爸爸和女儿的同步关系，初值为0表示盘子为空，1表示盘子中有苹果可以取；同步信号量orange同理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore plate = <span class="number">1</span>;	<span class="comment">// 互斥信号量</span></span><br><span class="line">semaphore apple = <span class="number">0</span>;	<span class="comment">// 对苹果操作的同步</span></span><br><span class="line">semaphore orange = <span class="number">0</span>;	<span class="comment">// 对橘子操作的同步</span></span><br><span class="line">dad() &#123;		<span class="comment">// 父亲进程</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        prepare an apple;	<span class="comment">// 父亲准备好一个苹果，将要放入盘子中</span></span><br><span class="line">        P(plate);	<span class="comment">// 父亲要对盘子操作，此时如果盘子空闲，则会继续往下执行；否则进入等待序列，等待女儿的解锁</span></span><br><span class="line">        put the apple on the plate;		<span class="comment">// 临界区</span></span><br><span class="line">        V(apple);	<span class="comment">// 盘子中现在有苹果，修改苹果的同步信号量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">mom() &#123;		<span class="comment">// 母亲进程</span></span><br><span class="line">   	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        prepare an orange;	<span class="comment">// 母亲准备好一个橘子，将要放入盘子中</span></span><br><span class="line">        P(plate);	<span class="comment">// 母亲要对盘子操作，此时如果盘子空闲，则会继续往下执行；否则进入等待序列，等待儿子的解锁</span></span><br><span class="line">        put the orange on the plate;	<span class="comment">// 临界区</span></span><br><span class="line">        V(orange);	<span class="comment">// 盘子中现在有橘子，修改橘子的同步信号量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">son() &#123;		<span class="comment">// 儿子进程</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(orange);	<span class="comment">// 儿子要对盘子中的橘子操作，此时如果盘子中有橘子，则会继续往下执行；否则儿子进入等待序列，等待母亲生产橘子</span></span><br><span class="line">        take an orange from plate;	<span class="comment">// 临界区</span></span><br><span class="line">        V(plate);	<span class="comment">// 儿子拿到橘子，此时盘子中没有苹果也没有橘子，因此释放盘子资源，让父亲和母亲可以继续对盘子进行操作</span></span><br><span class="line">        eat the orange;	<span class="comment">// 剩余区，儿子吃橘子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">daughter() &#123;	<span class="comment">// 女儿进程</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(apple);	<span class="comment">// 女儿要对盘子中的苹果操作，此时如果盘子中有苹果，则会继续往下执行；否则女儿进入等待序列，等待父亲生产苹果</span></span><br><span class="line">        take an apple from plate;	<span class="comment">// 临界区</span></span><br><span class="line">        V(plate);	<span class="comment">// 女儿拿到苹果，此时盘子中没有苹果也没有橘子，因此释放盘子资源，让父亲和母亲可以继续对盘子进行操作</span></span><br><span class="line">        eat the apple;	<span class="comment">// 剩余区，女儿吃苹果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，dad()执行完之后一定是daughter()，mom()执行完之后一定是son()，也正是因为这样，只有在儿子拿走橘子或者女儿拿走苹果之后才能释放盘子，即执行V(plate)操作。</p>
<h1 id="3-读者-写者问题"><a href="#3-读者-写者问题" class="headerlink" title="3. 读者-写者问题"></a>3. 读者-写者问题</h1><h2 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h2><p>有读者和写者两组并发进程，共享一个文件，当两个或以上的读进程同时访问共享数据不会产生副作用，但若某个写进程和其它进程同时访问共享数据可能导致数据不一致的错误。因此要求：</p>
<p>① 允许多个读者可以同时对文件执行读操作；</p>
<p>② 允许一个写者往文件中写信息；</p>
<p>③ 任意写者在完成写操作之前不允许其它读者或写者工作；</p>
<p>④ 写者执行写操作前，应让已有的读者和写者全部退出。</p>
<h2 id="问题分析-2"><a href="#问题分析-2" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="关系分析-2"><a href="#关系分析-2" class="headerlink" title="关系分析"></a>关系分析</h3><p>由题目分析可知：读者和写者是互斥的、写者和写者也是互斥的，而读者和读者之间不存在互斥问题，可以并发访问。</p>
<h3 id="整理思路-2"><a href="#整理思路-2" class="headerlink" title="整理思路"></a>整理思路</h3><p>在这里，写者的操作比较简单，它与任何操作都互斥。而读者的问题比较复杂，它必须在实现与写者的互斥同时，又实现与其它读者同步。因此，如果我们只是简单的设置一对PV操作，是无法解决问题的。我们可以设置一个计数器，用它来判断当前是否有读者读文件。当有读者时，写者是无法写文件的，此时读者会一直占用文件这个临界资源，只有当没有读者时，写者才可以操作文件。同时，这里不同读者对计数器的访问也是互斥的。（注意是对计数器的访问，而不是不同读者对文件的访问）。</p>
<h3 id="信号量设置-2"><a href="#信号量设置-2" class="headerlink" title="信号量设置"></a>信号量设置</h3><p>首先设置信号量count为计数器，初值为0.设置mutex为互斥信号量，用于保护更新count变量时的互斥，初值为1；设置rw为互斥信号量，用于保证读者和写者的互斥访问，初值为1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> readCount = <span class="number">0</span>;		<span class="comment">// 计数器</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;	<span class="comment">// 对计数器操作的互斥信号量</span></span><br><span class="line">semaphore rw = <span class="number">1</span>;		<span class="comment">// 对文件操作的互斥信号量</span></span><br><span class="line">writer() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(rw);		<span class="comment">// 写者将要对文件进行操作，如果读者没有访问文件，继续往下执行；否则，进入等待序列</span></span><br><span class="line">        writing;	<span class="comment">// 写文件</span></span><br><span class="line">        V(rw);		<span class="comment">// 写者结束对文件的操作，将文件资源释放，以便让读者或其它写者访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">reader() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(mutex);	<span class="comment">// 新的读者进程到来，因此要对计数器加一，如果此时没有另外的读者正在对readCount操作，继续往下执行；否则，进入等待序列</span></span><br><span class="line">        <span class="keyword">if</span> (readCount == <span class="number">0</span>)	<span class="comment">// 如果是第一个读者，说明文件资源并没有被锁住，因此要先锁定文件资源，再进行接下来的操作</span></span><br><span class="line">            P(rw);			<span class="comment">// 如果不是第一个读者，说明文件资源已经被锁定了，那么也就无须再进行锁定文件操作了</span></span><br><span class="line">        readCount++;	<span class="comment">// 读者数量加一</span></span><br><span class="line">        V(mutex);	<span class="comment">// 释放readCount</span></span><br><span class="line">        reading;	<span class="comment">// 读文件</span></span><br><span class="line">        P(mutex);	<span class="comment">// 读者进程将要结束，要对readCount进行减一操作，锁定readCount</span></span><br><span class="line">        readCount--;	<span class="comment">// 读者数量减一</span></span><br><span class="line">        <span class="keyword">if</span> (readCount == <span class="number">0</span>)		<span class="comment">// 读者数量减一之后，readCount等于0，说明已经没有读者了，就要释放读者对文件的锁定</span></span><br><span class="line">            V(rw);				<span class="comment">// 如果不等于0，说明此时还有读者在进行对文件的访问，因此也就不能释放对文件的锁定了</span></span><br><span class="line">        V(mutex);	<span class="comment">// 释放readCount</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是读进程优先的算法，即当存在读进程时，写操作都将被延迟，且只要有一个读进程活跃，那么随之而来的读进程都被允许访问文件，这样的方式可能会导致写进程长时间等待，甚至可能出现“写进程饿死”的情况。</p>
<p>如果我们希望写优先，即当有读进程在访问文件时，此时有写进程请求访问，这时我们应该禁止后续读进程的请求，等到已经在运行的读进程执行完毕，立即让写进程执行，只有在没有写进程执行的情况下才允许读进程再次运行。因此，我们需要再增加一个信号量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> readCount = <span class="number">0</span>;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore rw = <span class="number">1</span>;</span><br><span class="line">semaphore w = <span class="number">1</span>;	<span class="comment">// 用于实现写优先</span></span><br><span class="line">writer() &#123;</span><br><span class="line">    P(w);		<span class="comment">// 没有写进程，锁定</span></span><br><span class="line">    P(rw);</span><br><span class="line">    writing;</span><br><span class="line">    V(rw);</span><br><span class="line">    V(w);		<span class="comment">// 写进程结束访问</span></span><br><span class="line">&#125;</span><br><span class="line">reader() &#123;</span><br><span class="line">    P(w);		<span class="comment">// 没有写进程，锁定</span></span><br><span class="line">    P(mutex);</span><br><span class="line">    <span class="keyword">if</span> (readCount == <span class="number">0</span>)</span><br><span class="line">        P(rw);</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(w);		<span class="comment">// 恢复对文件的访问</span></span><br><span class="line">    reading;</span><br><span class="line">    P(mutex);</span><br><span class="line">    <span class="keyword">if</span>	(readCount == <span class="number">0</span>)</span><br><span class="line">        V(rw);</span><br><span class="line">    V(mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的写进程优先是相对上一种算法而言的，有些书上把这个称为“读写公平法”。因为如果读进程释放了w，系统会选择优先进行申请对文件操作的进程（根据等待序列的顺序来执行）。所以如果是读进程比写进程先申请对文件的访问，那么仍然会先执行读进程，再执行写进程。</p>
<h1 id="4-哲学家进餐问题"><a href="#4-哲学家进餐问题" class="headerlink" title="4. 哲学家进餐问题"></a>4. 哲学家进餐问题</h1><h2 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h2><p>一张圆桌边上坐着5名哲学家，每两名哲学家之间的桌上摆一根筷子，两个筷子中间是一碗米饭。哲学家们倾注毕生精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。若筷子已在他人手上，则需要等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，进餐完毕后，放下筷子继续思考。</p>
<h2 id="问题分析-3"><a href="#问题分析-3" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="关系分析-3"><a href="#关系分析-3" class="headerlink" title="关系分析"></a>关系分析</h3><p>5名哲学家与左右邻居对其中间筷子的访问是互斥关系。</p>
<h3 id="整理思路-3"><a href="#整理思路-3" class="headerlink" title="整理思路"></a>整理思路</h3><p>显然，这里有5个进程。我们要解决问题的关键在于：如何让一名哲学家拿到左右两根筷子而不造成死锁或饥饿现象。解决方法有两个：</p>
<ul>
<li>让他同时拿到两根筷子；</li>
<li>对每个哲学家的动作制定规则，避免死锁或饥饿。</li>
</ul>
<h3 id="信号量设置-3"><a href="#信号量设置-3" class="headerlink" title="信号量设置"></a>信号量设置</h3><p>定义互斥信号量数组chopstick[5] = {1, 1, 1, 1, 1}，用于对5根筷子的互斥访问。哲学家按顺序编号为0 ~ 4，哲学家i左边筷子的编号为i，右边筷子编号为(i + 1) % 5。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">Pi() &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        P(chopstick[i]);			<span class="comment">// 取左边筷子</span></span><br><span class="line">        P(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);	<span class="comment">// 取右边筷子</span></span><br><span class="line">        eat;						<span class="comment">// 临界区</span></span><br><span class="line">        V(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);	<span class="comment">// 放右边筷子</span></span><br><span class="line">        V(chopstick[i]);			<span class="comment">// 放左边筷子</span></span><br><span class="line">        think;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个算法存在的问题是：当5名哲学家都想要进餐并都拿起了左边的筷子时，筷子已经被拿光，等到他们再想拿右边的筷子时，就全被阻塞，出现了死锁。</p>
<p>为了防止死锁，我们可以增加一些限制条件，比如① 最多只允许4名哲学家同时进餐；② 仅当一名哲学家左右两边的筷子都可用时，才允许他抓起筷子；③ 对哲学家编号，要求奇数号哲学家先拿左边筷子，然后再拿右边，而偶数号恰好相反。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">Pi() &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        P(mutex);					<span class="comment">// 在取筷子前获得互斥量</span></span><br><span class="line">        P(chopstick[i]);			<span class="comment">// 取左边筷子</span></span><br><span class="line">        P(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);	<span class="comment">// 取右边筷子</span></span><br><span class="line">        V(mutex)					<span class="comment">// 筷子到手释放取筷子的信号量</span></span><br><span class="line">        eat;						<span class="comment">// 临界区</span></span><br><span class="line">        V(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);	<span class="comment">// 放右边筷子</span></span><br><span class="line">        V(chopstick[i]);			<span class="comment">// 放左边筷子</span></span><br><span class="line">        think;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-吸烟者问题"><a href="#5-吸烟者问题" class="headerlink" title="5. 吸烟者问题"></a>5. 吸烟者问题</h1><h2 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h2><p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草，第二个拥有纸，第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放到桌子上，拥有剩下哪种材料的抽烟者卷一根烟并抽掉它，并给供应者一个信号告诉已完成，此时供应者就会将另外两种材料放到桌上，如此重复（让三个抽烟者轮流地抽烟）。</p>
<h2 id="问题分析-4"><a href="#问题分析-4" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="关系分析-4"><a href="#关系分析-4" class="headerlink" title="关系分析"></a>关系分析</h3><p>供应者与三个抽烟者分别是同步关系。由于供应者无法同时满足两个或以上的抽烟者，三个抽烟者对抽烟这个动作互斥。</p>
<h3 id="整理思路-4"><a href="#整理思路-4" class="headerlink" title="整理思路"></a>整理思路</h3><p>显然这里有4个进程。供应者作为生产者向其它三个抽烟者提供材料。</p>
<h3 id="信号量设置-4"><a href="#信号量设置-4" class="headerlink" title="信号量设置"></a>信号量设置</h3><p>offer1：烟草和纸组合的资源；</p>
<p>offer2：烟草和胶水组合的资源；</p>
<p>offer3：纸和胶水组合的资源；</p>
<p>信号量smoke用于互斥进行抽烟。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;	<span class="comment">// 存储随机数</span></span><br><span class="line">semaphore offer1 = <span class="number">0</span>;</span><br><span class="line">semaphore offer2 = <span class="number">0</span>;</span><br><span class="line">semaphore offer3 = <span class="number">0</span>;</span><br><span class="line">semaphore smoke = <span class="number">0</span>;	<span class="comment">// 这里我们将互斥信号量初值设为0，是因为一开始需要供应者提供资源</span></span><br><span class="line"><span class="function">Process <span class="title">P1</span><span class="params">()</span> </span>&#123;		<span class="comment">// 供应者</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        num++;</span><br><span class="line">        num = num % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>) &#123;</span><br><span class="line">            V(offer1);	<span class="comment">// 提供烟草和纸</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">            V(offer2);	<span class="comment">// 提供烟草和胶水</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            V(offer3);	<span class="comment">// 提供纸和胶水</span></span><br><span class="line">        &#125;</span><br><span class="line">        任意两种材料放到桌子上;</span><br><span class="line">        P(smoke);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Process <span class="title">P2</span><span class="params">()</span> </span>&#123;			<span class="comment">// 拥有烟草者</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(offer3);</span><br><span class="line">        拿纸和胶水，卷成烟，抽掉;</span><br><span class="line">        V(smoke);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Process <span class="title">P3</span><span class="params">()</span> </span>&#123;			<span class="comment">// 拥有纸者</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(offer2);</span><br><span class="line">        拿烟草和胶水，卷成烟，抽掉;</span><br><span class="line">        V(smoke);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Process <span class="title">P4</span><span class="params">()</span> </span>&#123;			<span class="comment">// 拥有胶水者</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(offer1);</span><br><span class="line">        拿纸和烟草，卷成烟，抽掉;</span><br><span class="line">        V(smoke);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>进程同步</title>
    <url>/2021/12/29/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<blockquote>
<ol>
<li>为什么要引入进程同步的概念？</li>
<li>不同的进程之间会存在什么关系？</li>
<li>当单纯用本节介绍的方法解决问题会遇到什么新的问题？</li>
</ol>
</blockquote>
<h1 id="1-进程同步的基本概念"><a href="#1-进程同步的基本概念" class="headerlink" title="1. 进程同步的基本概念"></a>1. 进程同步的基本概念</h1><p>在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系，引入了进程同步的概念。</p>
<h2 id="1-1-临界资源"><a href="#1-1-临界资源" class="headerlink" title="1.1 临界资源"></a>1.1 临界资源</h2><p>虽然多个进程可以共享系统中的各种资源，但许多资源一次只能为一个进程服务，我们<strong>将一次仅允许一个进程使用的资源称为临界资源</strong>。许多物理设备都属于临界资源，如打印机等。此外，还有许多变量、数据等。</p>
<p>对临界资源的访问，必须互斥地进行，在每个进程中，<strong>访问临界资源的那段代码称为临界区</strong>。为了保证临界资源的正确使用，可把临界资源的访问过程分为4个部分：</p>
<ul>
<li><strong>进入区</strong>。为了进入临界区使用临界资源，在进入区要检查可否进入临界区，若能进入，则应设置正在访问临界区的标志，以阻止其它进程同时进入临界区。</li>
<li><strong>临界区</strong>。进程中访问临界资源的那段代码，又称临界段。</li>
<li><strong>退出区</strong>。将正在访问临界区的标志清除。</li>
<li><strong>剩余区</strong>。代码中的剩余部分。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	entry section;			<span class="comment">// 进入区</span></span><br><span class="line">    critical section;		<span class="comment">// 临界区</span></span><br><span class="line">    <span class="built_in">exit</span> section;			<span class="comment">// 退出区</span></span><br><span class="line">    remainder section;		<span class="comment">// 剩余区</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<h2 id="1-2-同步"><a href="#1-2-同步" class="headerlink" title="1.2 同步"></a>1.2 同步</h2><p>同步亦称直接制约关系，是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系源于它们之间的相互合作。</p>
<h2 id="1-3-互斥"><a href="#1-3-互斥" class="headerlink" title="1.3 互斥"></a>1.3 互斥</h2><p>互斥也称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一个进程才允许去访问此临界资源。</p>
<p>为禁止两个进程同时进入临界区，同步机制应遵循以下准则：</p>
<blockquote>
<ol>
<li><strong>空闲让进</strong>。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。</li>
<li><strong>忙则等待</strong>。当已有进程进入临界区时，其它试图进入临界区的进程必须等待。</li>
<li><strong>有限等待</strong>。对请求访问的进程，应保证能在有限时间内进入临界区。</li>
<li><strong>让权等待</strong>。当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。</li>
</ol>
</blockquote>
<h1 id="2-实现临界区互斥的基本方法"><a href="#2-实现临界区互斥的基本方法" class="headerlink" title="2. 实现临界区互斥的基本方法"></a>2. 实现临界区互斥的基本方法</h1><h2 id="2-1-软件实现方法"><a href="#2-1-软件实现方法" class="headerlink" title="2.1 软件实现方法"></a>2.1 软件实现方法</h2><p>在进入区设置并检查一些标志来标明是否有进程在临界区中，若已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。</p>
<h3 id="2-1-1-单标志法"><a href="#2-1-1-单标志法" class="headerlink" title="2.1.1 单标志法"></a>2.1.1 单标志法</h3><p>该算法设置一个公用整型变量turn，<strong>用于指示被允许进入临界区的进程编号</strong>。该算法可确保每次只允许一个进程进入临界区，但两个进程必须交替进入临界区，若某个进程不再进入临界区，则另一个进程也将无法进入临界区（违背“空闲让进”）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P0进程						// P1进程</span></span><br><span class="line"><span class="keyword">while</span> (turn != <span class="number">0</span>);			<span class="keyword">while</span> (turn != <span class="number">1</span>);		<span class="comment">// 进入区</span></span><br><span class="line">critical section;			critical section;		<span class="comment">// 临界区</span></span><br><span class="line">turn = <span class="number">1</span>;					turn = <span class="number">0</span>;				<span class="comment">// 退出区</span></span><br><span class="line">remainder section;			remainder section;		<span class="comment">// 剩余区</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-双标志先检查"><a href="#2-1-2-双标志先检查" class="headerlink" title="2.1.2 双标志先检查"></a>2.1.2 双标志先检查</h3><p>该算法的基本思想是在每个进程访问临界区资源之前，先查看临界区资源是否正在被访问，只有不在，进程才能进入自己的临界区；否则等待。为此，设置一个数据flag[i]，如第i个元素值为FALSE，表示Pi进程未进入临界区；值为TRUE，表示Pi进程进入临界区。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Pi进程						   // Pj进程</span></span><br><span class="line"><span class="keyword">while</span> (flag[j]);	①			<span class="keyword">while</span> (flag[i]);	②	<span class="comment">// 进入区</span></span><br><span class="line">flag[i] = TRUE;		③			flag[j] = TRUE;		④	<span class="comment">// 进入区</span></span><br><span class="line">critical section;				critical section;		<span class="comment">// 临界区</span></span><br><span class="line">flag[i] = FALSE;				flag[j] = FALSE;		<span class="comment">// 退出区</span></span><br><span class="line">remainder section;				remainder section;		<span class="comment">// 剩余区</span></span><br></pre></td></tr></table></figure>

<p>优点：不用交替进入，可连续使用；</p>
<p>缺点：Pi和Pj可能同时进入临界区。按序列①②③④执行时，会同时进入临界区（“违背忙则等待”）。即在检查对方的flag后和切换自己的flag前有一段时间，结果都检查通过。这里的问题就是检查和修改不能一次进行。</p>
<h3 id="2-1-3-双标志后检查"><a href="#2-1-3-双标志后检查" class="headerlink" title="2.1.3 双标志后检查"></a>2.1.3 双标志后检查</h3><p>这里与先检查的区别就是我们先将自己的标志设为TRUE，再检测对方的状态标志。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Pi进程						   // Pj进程</span></span><br><span class="line">flag[i] = TRUE;		①			flag[j] = TRUE;		②	<span class="comment">// 进入区</span></span><br><span class="line"><span class="keyword">while</span> (flag[j]);	③			<span class="keyword">while</span> (flag[i]);	④	<span class="comment">// 进入区</span></span><br><span class="line">critical section;				critical section;		<span class="comment">// 临界区</span></span><br><span class="line">flag[i] = FALSE;				flag[j] = FALSE;		<span class="comment">// 退出区</span></span><br><span class="line">remainder section;				remainder section;		<span class="comment">// 剩余区</span></span><br></pre></td></tr></table></figure>

<p>这样，我们虽然避免了“忙则等待”，但是可能会产生”饥饿“现象（按序列①②③④执行）。</p>
<h3 id="2-1-4-Peterson’s-Algorithm"><a href="#2-1-4-Peterson’s-Algorithm" class="headerlink" title="2.1.4 Peterson’s Algorithm"></a>2.1.4 Peterson’s Algorithm</h3><p>为了防止两个进程为进入临界区而无限等待，又设置了变量turn，每个进程先设置自己的标志再设置turn标志。这是，再同时检测另一个进程状态标志和允许进入标志，以便保证两个进程同时要求进入临界区时，只允许一个进程进入临界区。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Pi进程						   	   // Pj进程</span></span><br><span class="line">flag[i] = TRUE; turn = j;			flag[j] = TRUE; turn = i;			<span class="comment">// 进入区</span></span><br><span class="line"><span class="keyword">while</span> (flag[j] &amp;&amp; turn == j);		<span class="keyword">while</span> (flag[i] &amp;&amp; turn == i);		<span class="comment">// 进入区</span></span><br><span class="line">critical section;					critical section;					<span class="comment">// 临界区</span></span><br><span class="line">flag[i] = FALSE;					flag[j] = FALSE;					<span class="comment">// 退出区</span></span><br><span class="line">remainder section;					remainder section;					<span class="comment">// 剩余区</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-硬件实现方法"><a href="#2-2-硬件实现方法" class="headerlink" title="2.2 硬件实现方法"></a>2.2 硬件实现方法</h2><p>计算机提供了特殊的硬件指令，允许对一个字中的内容进行检测和修正，或对两个字的内容进行交换等。通过硬件支持实现临界段问题的方法称为低级方法，或称元方法。</p>
<h3 id="2-2-1-中断屏蔽方法"><a href="#2-2-1-中断屏蔽方法" class="headerlink" title="2.2.1 中断屏蔽方法"></a>2.2.1 中断屏蔽方法</h3><p>当一个进程正在使用处理机执行它的临界区代码时，防止其它进程进入其临界区进行访问的最简单方法就是：<strong>禁止一切中断发生</strong>，或称之为屏蔽中断、关中断。因为CPU只有在发生中断时才引起进程切换，典型模式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">关中断;</span><br><span class="line">临界区;</span><br><span class="line">开中断;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这种方法限制了处理机交替执行程序的能力，因此执行的效率会明显降低。对内核来说，在它执行更新变量或列表的几条指令期间，关中断是很方便，但是将关中断的权利交给用户是很不明智的，如果一个进程关中断后不再开，则系统可能祭了。</p>
<h3 id="2-2-2-硬件指令方法"><a href="#2-2-2-硬件指令方法" class="headerlink" title="2.2.2 硬件指令方法"></a>2.2.2 硬件指令方法</h3><p><strong>TestAndSet指令</strong>：这条指令是原子操作，即执行该代码时不允许被中断。其功能是读出指定的标志后把该标志设为真。指令的功能描述如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">TestAndSet</span><span class="params">(boolean *lock)</span> </span>&#123;</span><br><span class="line">    boolean old;</span><br><span class="line">    old = *lock;</span><br><span class="line">    *lock = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以为每个临界资源设置一个共享布尔变量lock，表示资源的两种状态：true表示正在被占用，初值为false。在进程访问临界资源之前，利用TestAndSet检查和修改标志lock；若有进程在临界区，则重复检查，知道进程退出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (TestAndSet(&amp;lock));</span><br><span class="line">进程的临界区代码段;</span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line">进程的其它代码;</span><br></pre></td></tr></table></figure>

<p><strong>Swap指令</strong>：见名知意，其功能描述如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Swap(boolean *a, boolean *b) &#123;</span><br><span class="line">    boolean temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：以上对TestAndSet和Swap指令的描述仅仅是功能实现，而并非软件实现的定义。事实上，它们是由硬件逻辑直接实现的，不会被中断。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">key = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (key != <span class="literal">false</span>);</span><br><span class="line">	Swap(&amp;lock, &amp;key);</span><br><span class="line">进程的临界区代码段;</span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line">进程的其它代码;</span><br></pre></td></tr></table></figure>

<p>硬件方法的优点：适用于任意数目的进程，而不管是单处理机还是多处理机；简单、容易验证其正确性。可以支持进程内有多个临界区，只需为每个临界区设立一个布尔变量。</p>
<p>硬件方法的缺点：进程等待进入临界区时要耗费处理机时间，不能实现让权等待。从等待进程中随机选择一个进入临界区，有的进程可能一直选不上，从而导致“饥饿”。</p>
<h1 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3. 信号量"></a>3. 信号量</h1><p>信号量机制是一种功能较强的机制，可用来解决同步与互斥问题，它只能被两个标准的原语wait(S)和signal(S)访问，也可记为“P操作”和“V操作”。</p>
<p>原语是指完成某种功能且不被分割、不被中断执行的操作序列，通常可由硬件来实现。例如，上面的TestAndSet和Swap指令就是由硬件实现的原子操作。原语功能的不被中断执行特性在单处理机上可由软件通过屏蔽中断方法实现。</p>
<h2 id="3-1-整型信号量"><a href="#3-1-整型信号量" class="headerlink" title="3.1 整型信号量"></a>3.1 整型信号量</h2><p>整型信号量被定义为一个用于表示资源数目的整型量S，wait和signal操作可描述为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">wait(S) &#123;</span><br><span class="line">	<span class="keyword">while</span> (S &lt;= <span class="number">0</span>);</span><br><span class="line">    S = S - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">signal(S) &#123;</span><br><span class="line">    S = S + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wait操作中，只要信号量S ≤ 0，就会不断地测试。因此，该机制<strong>并未遵循“让权等待”的准则</strong>，而是使进程处于“忙等”的状态。</p>
<h2 id="3-2-记录型信号量"><a href="#3-2-记录型信号量" class="headerlink" title="3.2 记录型信号量"></a>3.2 记录型信号量</h2><p>为解决忙等现象，我们再增加一个进程链表L，用于链接所有等待该资源的进程。记录型信号量得名于采用了记录型的数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span></span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure>

<p>相应的wait(S)和signal(S)的操作如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(semaphore S)</span> </span>&#123;	<span class="comment">// 相当于申请资源</span></span><br><span class="line">	S.value--;	<span class="comment">// 进程请求一个该类资源</span></span><br><span class="line">    <span class="keyword">if</span>(S.value &lt; <span class="number">0</span>) &#123;	<span class="comment">// 资源已分配完毕</span></span><br><span class="line">        add <span class="keyword">this</span> process to S.L;	<span class="comment">// 将此进程加入到等待队列中</span></span><br><span class="line">        block(S.L);		<span class="comment">// 调用block原语，进行自我阻塞，放弃处理机，遵循了“让权等待”原则</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">(semaphore S)</span> </span>&#123;	<span class="comment">// 相当于释放资源</span></span><br><span class="line">    S.value++;	<span class="comment">// 使系统中可供分配的该类资源数量加一</span></span><br><span class="line">    <span class="keyword">if</span>(S.value &lt;= <span class="number">0</span>) &#123;	<span class="comment">// 加一之后value仍然小于等于0，说明S.L中仍有等待该资源的进程被阻塞</span></span><br><span class="line">        remove a process P from S.L;</span><br><span class="line">        wakeup(P); <span class="comment">// 调用wakeup原语，将S.L中的第一个等待进程唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-利用信号量实现同步"><a href="#3-3-利用信号量实现同步" class="headerlink" title="3.3 利用信号量实现同步"></a>3.3 利用信号量实现同步</h2><p>设S为实现进程P1，P2同步的公共信号量，初值为0。进程P2中的语句y要使用进程P1中语句x的运行结果，所有只有当语句x完成之后y才能执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore S = <span class="number">0</span>;	<span class="comment">// 初始化信号量</span></span><br><span class="line">P1() &#123;</span><br><span class="line">    x;				<span class="comment">// 语句x</span></span><br><span class="line">    V(S);			<span class="comment">// 告诉P2，x已经完成</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">P2() &#123;</span><br><span class="line">    ...</span><br><span class="line">    P(S);			<span class="comment">// 检查x是否完成</span></span><br><span class="line">    y;				<span class="comment">// 检查无误，执行y</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-利用信号量实现进程互斥"><a href="#3-4-利用信号量实现进程互斥" class="headerlink" title="3.4 利用信号量实现进程互斥"></a>3.4 利用信号量实现进程互斥</h2><p>设S为实现进程P1，P2互斥的信号量，由于每次只允许一个进程进入临界区，所以S的初值设为1（即可用资源数为1）.只需把临界区置于P(S)和V(S)之间，就可以实现两个进程对临界区资源的互斥访问。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semphore S = <span class="number">1</span>;			<span class="comment">// 初始化信号量</span></span><br><span class="line">P1() &#123;</span><br><span class="line">    ...</span><br><span class="line">    P(S);				<span class="comment">// 准备开始访问临界资源，加锁</span></span><br><span class="line">    进程P1的临界区;</span><br><span class="line">    V(S);				<span class="comment">// 访问结束，解锁</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">P2() &#123;</span><br><span class="line">    ...</span><br><span class="line">    P(S);				<span class="comment">// 准备开始访问临界资源，加锁</span></span><br><span class="line">    进程P2的临界区;		</span><br><span class="line">    V(S);				<span class="comment">// 访问结束，解锁</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单总结PV操作在同步互斥中的应用：在同步问题中，若某个行为要用到某种资源，则在这个行为前面P这种资源一下；若某个行为会提供某种资源，则在这个行为后面V这种资源一下（<strong>前P后V</strong>）。在互斥问题中，P，V操作要紧夹着是哦也能够互斥资源的那个行为，中间不能有其它冗余代码。</p>
<h2 id="3-5-利用信号量实现前驱关系"><a href="#3-5-利用信号量实现前驱关系" class="headerlink" title="3.5 利用信号量实现前驱关系"></a>3.5 利用信号量实现前驱关系</h2><p><img src="C:/Users/pengbin007/AppData/Roaming/Typora/typora-user-images/image-20211230152305157.png" alt="image-20211230152305157"></p>
<p>如图，S1,S2,…,S6是最简单的程序段（只有一条语句）。为使个程序段能正确执行，应设置若干初始值为“0”的信号量。例如，为保证S1→S2，S1→S3的前驱关系，应分别设置a1,a2。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore a1 = a2 = b1 = b2 = c = d = e = <span class="number">0</span>;	<span class="comment">// 初始化信号量</span></span><br><span class="line">S1() &#123;</span><br><span class="line">    ...;</span><br><span class="line">    V(a1); V(a2);	<span class="comment">// S1运行完成</span></span><br><span class="line">&#125;</span><br><span class="line">S2() &#123;</span><br><span class="line">    P(a1);			<span class="comment">// 检查S1是否完成</span></span><br><span class="line">    ...;</span><br><span class="line">    V(b1); V(b2);	<span class="comment">// S2完成</span></span><br><span class="line">&#125;</span><br><span class="line">S3() &#123;</span><br><span class="line">    P(a2);			<span class="comment">// 检查S1是否完成</span></span><br><span class="line">    ...;</span><br><span class="line">    V(c);			<span class="comment">// S3完成</span></span><br><span class="line">&#125;</span><br><span class="line">S4() &#123;</span><br><span class="line">    P(b1);			<span class="comment">// 检查S2是否完成</span></span><br><span class="line">    ...;</span><br><span class="line">    V(d);			<span class="comment">// S4完成</span></span><br><span class="line">&#125;</span><br><span class="line">S5() &#123;</span><br><span class="line">    P(b2);			<span class="comment">// 检查S2是否完成</span></span><br><span class="line">    ...;</span><br><span class="line">    V(e);			<span class="comment">// S5完成</span></span><br><span class="line">&#125;</span><br><span class="line">S6() &#123;</span><br><span class="line">    P(c);			<span class="comment">// 检查S3是否完成</span></span><br><span class="line">    P(d);			<span class="comment">// 检查S4是否完成</span></span><br><span class="line">    P(e);			<span class="comment">// 检查S5是否完成</span></span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-分析进程同步和互斥问题的方法步骤"><a href="#3-6-分析进程同步和互斥问题的方法步骤" class="headerlink" title="3.6 分析进程同步和互斥问题的方法步骤"></a>3.6 分析进程同步和互斥问题的方法步骤</h2><ol>
<li><strong>关系分析</strong>。</li>
<li><strong>整理思路</strong>。</li>
<li><strong>设置信号量</strong>。</li>
</ol>
<h1 id="4-管程"><a href="#4-管程" class="headerlink" title="4. 管程"></a>4. 管程</h1><p>在信号量机制中，每个要访问临界资源的进程都必须自备同步的PV操作，大量分散的同步操作给系统管理带来了麻烦，且容易因同步操作不当而导致死锁。于是，一种新的同步工具——管程。管程的特性保证了进程互斥，无须程序员自己实现互斥，从而降低了死锁发生的可能性。同时管程提供了条件变量，可以让程序员灵活地实现进程同步。</p>
<h2 id="4-1-管程的定义"><a href="#4-1-管程的定义" class="headerlink" title="4.1 管程的定义"></a>4.1 管程的定义</h2><h2 id="4-2-条件变量"><a href="#4-2-条件变量" class="headerlink" title="4.2 条件变量"></a>4.2 条件变量</h2><h1 id="5-经典同步问题"><a href="#5-经典同步问题" class="headerlink" title="5. 经典同步问题"></a>5. 经典同步问题</h1><h2 id="5-1-生产者-消费者问题"><a href="#5-1-生产者-消费者问题" class="headerlink" title="5.1 生产者-消费者问题"></a>5.1 生产者-消费者问题</h2><h2 id="5-2-读者-写者问题"><a href="#5-2-读者-写者问题" class="headerlink" title="5.2 读者-写者问题"></a>5.2 读者-写者问题</h2><h2 id="5-3-哲学家进餐问题"><a href="#5-3-哲学家进餐问题" class="headerlink" title="5.3 哲学家进餐问题"></a>5.3 哲学家进餐问题</h2><h2 id="5-4-吸烟者问题"><a href="#5-4-吸烟者问题" class="headerlink" title="5.4 吸烟者问题"></a>5.4 吸烟者问题</h2>]]></content>
  </entry>
  <entry>
    <title>二十三个实验入门SpringIOC(下)</title>
    <url>/2021/12/25/%E4%BA%8C%E5%8D%81%E4%B8%89%E4%B8%AA%E5%AE%9E%E9%AA%8C%E5%85%A5%E9%97%A8SpringIOC-%E4%B8%8B/</url>
    <content><![CDATA[<blockquote>
<p>实验15：通过注解分别创建Dao、Service、Controller★</p>
<p>实验16：使用context:include-filter指定扫描包时要包含的类</p>
<p>实验17：使用context:exclude-filter指定扫描包时不包含的类</p>
<p>实验18：使用@Autowired注解实现根据类型实现自动装配★</p>
<p>实验19：如果资源类型的bean不止一个，默认根据@Autowired注解标记的成员变量名作为id查找bean，进行装配★</p>
<p>实验20：如果根据成员变量名作为id还是找不到bean，可以使用@Qualifier注解明确指定目标bean的id★</p>
<p>实验21：在方法的形参位置使用@Qualifier注解</p>
<p>实验22：@Autowired注解的required属性指定某个属性允许不被设置</p>
<p>实验23：测试泛型依赖注入★</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验23：测试泛型依赖注入★--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        @Autowired、@Resource、@Inject；都是自动装配的意思</span></span><br><span class="line"><span class="comment">        @Autowired：最强大，Spring自己的注解</span></span><br><span class="line"><span class="comment">        @Resource：j2ee：Java的标准</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        @Resource：扩展性更强，如果我们切换成另外一个容器框架，@Resource还是可以使用的，@Autowired就不行了</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验21：在方法的形参位置使用@Qualifier注解--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        @Target(&#123;ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="comment">        @Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment">        @Documented</span></span><br><span class="line"><span class="comment">        public @interface Autowired &#123;</span></span><br><span class="line"><span class="comment">        可以在方法上使用@Autowired注解(@Qualifier也可以)，而这个方法也会在bean创建的时候自动运行，并且这个方法的每一个参数都会自动注入值</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验22：@Autowired注解的required属性指定某个属性允许不被设置--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--实验20：如果根据成员变量名作为id还是找不到bean，可以使用@Qualifier注解明确指定目标bean的id★--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--实验19：如果资源类型的bean不止一个，默认根据@Autowired注解标记的成员变量名作为id查找bean，进行装配★--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--实验18：使用@Autowired注解实现根据类型实现自动装配★--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        使用@Autowired注解，Spring会自动的为这个属性赋值，它一定是去容器中找到对应的组件</span></span><br><span class="line"><span class="comment">        @Autowired</span></span><br><span class="line"><span class="comment">        private BookService bookService;</span></span><br><span class="line"><span class="comment">        @Autowired原理：</span></span><br><span class="line"><span class="comment">            ① 先按照类型去容器中找到对应的组件：bookService = ioc.getBean(BookService.class);</span></span><br><span class="line"><span class="comment">                1)找到一个，就赋值</span></span><br><span class="line"><span class="comment">                2)没找到，抛异常</span></span><br><span class="line"><span class="comment">                3)找到多个</span></span><br><span class="line"><span class="comment">                    ① 按照变量名作为id继续匹配</span></span><br><span class="line"><span class="comment">                        1)匹配上</span></span><br><span class="line"><span class="comment">                        2)没有匹配上</span></span><br><span class="line"><span class="comment">                          没有匹配上是因为我们按照变量名作为id继续匹配的</span></span><br><span class="line"><span class="comment">                          因此我们可以使用@Qualifier(&quot;bookServiceExt&quot;)指定一个新的id</span></span><br><span class="line"><span class="comment">                            找到，装配</span></span><br><span class="line"><span class="comment">                            找不到，报错</span></span><br><span class="line"><span class="comment">        @Autowired标注的自动装配的属性默认是一定装配上的</span></span><br><span class="line"><span class="comment">            找到就装配，找不到就祭了</span></span><br><span class="line"><span class="comment">        我们可以设置@Autowired(required=false)来指定属性可以没有，这是找不到就装配null</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验17：使用context:exclude-filter指定扫描包时不包含的类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atqingke&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            扫描的时候可以排除一些不要的组件</span></span><br><span class="line"><span class="comment">             ★ type=&quot;annotation&quot;：指定排除规则，按照注解进行排除，标注了指定注解的组件不要</span></span><br><span class="line"><span class="comment">                    expression=&quot;&quot;：注解的全类名</span></span><br><span class="line"><span class="comment">             ★ type=&quot;assignable&quot;：指定排除某个具体的类，按照类排除</span></span><br><span class="line"><span class="comment">                    expression=&quot;&quot;：类的全类名</span></span><br><span class="line"><span class="comment">                type=&quot;aspectj&quot;：aspectj表达式</span></span><br><span class="line"><span class="comment">                type=&quot;custom&quot;：自定义一个TypeFilter；自己写代码决定哪些使用</span></span><br><span class="line"><span class="comment">                type=&quot;regex&quot;：正则表达式</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验16：使用context:include-filter指定扫描包时要包含的类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atqingke&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            只扫描哪些组件，默认全部扫描进来</span></span><br><span class="line"><span class="comment">            使用时一定要禁用默认扫描规则：use-default-filters=&quot;false&quot;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;context:include-filter type=&quot;assignable&quot; expression=&quot;com.atqingke.servlet.BookServlet&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验15：通过注解分别创建Dao、Service、Controller（控制器：控制网站跳转逻辑）★--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        通过给bean上添加某些注解，可以快速的将bean加入到ioc容器中</span></span><br><span class="line"><span class="comment">        Ⅰ 某个类上添加上任何一个注解都能快速的将这个组件加入到ioc容器的管理中</span></span><br><span class="line"><span class="comment">        Ⅱ Spring有四个注解：</span></span><br><span class="line"><span class="comment">            @Controller：控制器；我们推荐给控制器层（servlet包下的这些）的组件加这个注解</span></span><br><span class="line"><span class="comment">            @Service：业务逻辑；我们推荐业务逻辑层的组件添加这个注解</span></span><br><span class="line"><span class="comment">            @Repository：给数据库层（持久化层，dao层）的组件添加这个注解</span></span><br><span class="line"><span class="comment">            @Component：给不属于以上几层的组件添加这个注解</span></span><br><span class="line"><span class="comment">        Ⅲ 注解可以随便加，Spring底层不会去验证你的这个组件，时候如你注解所说的就是一个dao层的或者就是一个servlet层的组件</span></span><br><span class="line"><span class="comment">            我们推荐给各层这样加，是为了给程序员看的</span></span><br><span class="line"><span class="comment">        Ⅳ 使用解将组件快速的加入到容器中需要几步：</span></span><br><span class="line"><span class="comment">            ① 给要添加的组件上标四个注解的任何一个</span></span><br><span class="line"><span class="comment">            ② 告诉Spring，自动扫描加了注解的组件；依赖context名称空间</span></span><br><span class="line"><span class="comment">            ③ 一定要导入aop包，支持加注解模式的</span></span><br><span class="line"><span class="comment">        Ⅴ 使用注解加入到容器中的组件，和使用配置加入到容器中的组件行为都是默认一样的</span></span><br><span class="line"><span class="comment">            ① 组件的id，默认就是组件的类名首字母小写</span></span><br><span class="line"><span class="comment">            ② 组件的作用域，默认就是单例的</span></span><br><span class="line"><span class="comment">        Ⅵ 组件的默认行为调整</span></span><br><span class="line"><span class="comment">            ① 在主键中添加默认的value属性值可以修改组件的id    @Controller(&quot;bookservletcontroller&quot;)</span></span><br><span class="line"><span class="comment">            ② 在组件上添加@scope注解，可以修改作用域</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        context:component-scan：自动组件扫描</span></span><br><span class="line"><span class="comment">        base-package：指定扫描的基础包；把基础包及它下面所有的包的所有加了注解的类，自动的扫描进IOC容器</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;context:component-scan base-package=&quot;com.atqingke&quot;/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>二十三个实验入门SpringIOC(中)</title>
    <url>/2021/12/25/%E4%BA%8C%E5%8D%81%E4%B8%89%E4%B8%AA%E5%AE%9E%E9%AA%8C%E5%85%A5%E9%97%A8SpringIOC-%E4%B8%AD/</url>
    <content><![CDATA[<blockquote>
<ul>
<li><p>实验5：配置通过静态工厂方法创建的bean、实例工厂方法创建的bean、FactoryBean★</p>
</li>
<li><p>实验6：通过继承实现bean配置信息的重用</p>
</li>
<li><p>实验7：通过abstract属性创建一个模板bean</p>
</li>
<li><p>实验8：bean之间的依赖</p>
</li>
<li><p>实验9：测试bean的作用域，分别创建单实例和多实例的bean★</p>
</li>
<li><p>实验10：创建带有生命周期方法的bean</p>
</li>
<li><p>实验11：测试bean的后置处理器</p>
</li>
<li><p>实验12：引用外部属性文件★</p>
</li>
<li><p>实验13：基于XML的自动装配</p>
</li>
<li><p>实验14：[SpEL测试I]</p>
<ul>
<li> 在SpEL中使用字面量、</li>
<li> 引用其他bean、</li>
<li> 引用其他bean的某个属性值、</li>
<li> 调用非静态方法</li>
<li> 调用静态方法、</li>
<li> 使用运算符</li>
</ul>
</li>
</ul>
</blockquote>
<p>ioc2.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验14：[SpEL测试I]</span></span><br><span class="line"><span class="comment">        在SpEL中使用字面量、</span></span><br><span class="line"><span class="comment">        引用其他bean、</span></span><br><span class="line"><span class="comment">        引用其他bean的某个属性值、</span></span><br><span class="line"><span class="comment">        调用非静态方法</span></span><br><span class="line"><span class="comment">        调用静态方法、</span></span><br><span class="line"><span class="comment">        使用运算符</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person14&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--字面量：$&#123;&#125;;    #&#123;&#125; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;12*2&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引用其他bean--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;car&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;car&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引用其他bean的某个属性值--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;car.carName&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--调用非静态方法  #&#123;对象.方法名&#125;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;car.getCarName()&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--调用静态方法  #&#123;T(全类名).静态方法名(参数)&#125;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;T(java.util.UUID).randomUUID().toString().substring(0,5)&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用运算符--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验13：基于XML的自动装配--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;car&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Car&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;carName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;宝宝&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        为Person里面的自定义类型的属性赋值</span></span><br><span class="line"><span class="comment">            property：手动赋值 ===== &lt;property name=&quot;car&quot; ref=&quot;car13&quot;/&gt;</span></span><br><span class="line"><span class="comment">            autowire=&quot;default&quot;：不自动装配，（不自动为car属性赋值）</span></span><br><span class="line"><span class="comment">            autowire=&quot;byName&quot;：以属性名作为id去容器中找到这个组件，给它赋值</span></span><br><span class="line"><span class="comment">            autowire=&quot;byType&quot;：以属性类型作为查找依据找到这个组件，给它赋值</span></span><br><span class="line"><span class="comment">            autowire=&quot;constructor&quot;：先按照有参构造器参数的类型进行装配（成功就赋值），没有就直接为组件装配null即可。</span></span><br><span class="line"><span class="comment">                                    如果按照类型找到了多个，参数的名作为id继续匹配，找到就装配，找不到就null</span></span><br><span class="line"><span class="comment">                                    不会报错</span></span><br><span class="line"><span class="comment">            autowire=&quot;no&quot;：同default</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person13&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验12：引用外部属性文件 ★ 依赖context名称空间--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        数据库连接池作为单实例最好：一个项目就一个连接池，连接池里管理很多连接。连接是直接从连接池中拿</span></span><br><span class="line"><span class="comment">        可以让Spring帮我们创建连接池对象（管理连接池）</span></span><br><span class="line"><span class="comment">        加载外部配置文件 固定写法classpath:文件名称；表示引用类路径下的一个资源</span></span><br><span class="line"><span class="comment">        通过$&#123;key&#125;动态取出配置文件中某个key对应的值</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:dbconfig.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--username是Spring的key中的一个关键字，为了防止配置文件中的key与Spring自己的关键字冲突，我们通常在配置文件中加一个前缀--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.jdbcUrl&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClass&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验11：测试bean的后置处理器--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        Spring有一个接口：后置处理器，可以在bean初始化前后调用方法</span></span><br><span class="line"><span class="comment">            （容器启动）构造器=====&gt;后置处理器before=====&gt;初始化方法=====&gt;后置处理器after=====&gt;（容器关闭）销毁方法</span></span><br><span class="line"><span class="comment">        无论bean是否有初始化方法，后置处理器都会默认其有，还会继续工作</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanPostProcessor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.MyBeanPostProcessor&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验10：创建带有生命周期方法的bean--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        生命周期：bean的创建到销毁</span></span><br><span class="line"><span class="comment">            ioc容器中注册的bean：</span></span><br><span class="line"><span class="comment">                1、单例bean，容器启动的时候就会创建好，容器关闭也会销毁创建的bean</span></span><br><span class="line"><span class="comment">                2、多实例bean，获取的时候才创建</span></span><br><span class="line"><span class="comment">            我们可以为bean自定义一些生命周期方法：Spring在创建或销毁的时候就会调用指定方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        单例bean的生命周期：</span></span><br><span class="line"><span class="comment">            构造器  》  初始化方法   》   （容器关闭）销毁方法</span></span><br><span class="line"><span class="comment">        多实例</span></span><br><span class="line"><span class="comment">            获取bean    》    容器关闭不会调用bean的销毁方法</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book10&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Book&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">destroy-method</span>=<span class="string">&quot;myDestory&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;myInit&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验9：测试bean的作用域，分别创建单实例和多实例的bean★--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        scope：指定bean是否是单实例，默认单实例</span></span><br><span class="line"><span class="comment">            prototype：多实例的</span></span><br><span class="line"><span class="comment">                1)、容器启动默认不会去创建多实例</span></span><br><span class="line"><span class="comment">                2)、获取的时候创建这个bean</span></span><br><span class="line"><span class="comment">                3)、每次获取都会创建一个新的对象</span></span><br><span class="line"><span class="comment">            singleton：单实例的，默认的</span></span><br><span class="line"><span class="comment">                1)、在容器启动完成之前就已经创建好了对象，保存在容器中了</span></span><br><span class="line"><span class="comment">                2)、任何获取都是获取之前创建好的那个对象</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person09&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--原来是按照配置的顺序创建bean--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--实验8：bean之间的依赖（只是改变创建顺序）--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        没有配置depends-on之前的bean创建顺序为person08、car、book</span></span><br><span class="line"><span class="comment">        配置之后为book、car、person08</span></span><br><span class="line"><span class="comment">        注意depends-on里面的顺序也会影响创建顺序</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person08&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span> <span class="attr">depends-on</span>=<span class="string">&quot;book,car&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;car08&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Car&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Book&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验7：通过abstract属性创建一个模板bean--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--abstract=&quot;true&quot;：通过这个属性，说明这个bean配置是一个抽象的，不能获取它的实例，只能被别人用来继承--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person07&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验6：通过继承实现bean配置信息的重用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person061&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;23&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;www.atqingke.com&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--我们可以通过parent属性：指定当前bean的配置信息继承于哪个--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person062&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;person061&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;李四&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实验5：配置通过静态工厂方法创建的bean、实例工厂方法创建的bean、FactoryBean★--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--bean的创建默认都是框架利用反射new出来的bean实例--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        工厂模式：工厂帮我们创建对象：</span></span><br><span class="line"><span class="comment">        AirPlane ap = AirPlaneFactory.getAirPlane(String jzName);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        静态工厂：工厂本身不用创建对象；通过静态方法调用，对象 = 工厂类.工厂方法名()</span></span><br><span class="line"><span class="comment">        实例工厂：工厂本身需要创建对象；</span></span><br><span class="line"><span class="comment">            工厂类 工厂对象 = new 工厂类();</span></span><br><span class="line"><span class="comment">            工厂对象.getAirPlane(&quot;zs&quot;);</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--静态工厂</span></span><br><span class="line"><span class="comment">            class：指定静态工厂全类名</span></span><br><span class="line"><span class="comment">            factory-method：指定工厂方法</span></span><br><span class="line"><span class="comment">            constructor-arg：为方法传参</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;airPlaneStaticFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.factory.AirPlaneStaticFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getAirPlane&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;李思思&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--实例工厂</span></span><br><span class="line"><span class="comment">            先配置出实例工厂</span></span><br><span class="line"><span class="comment">            配置我们要创建的AirPlane使用哪个工厂创建</span></span><br><span class="line"><span class="comment">                factory-bean：指定指定当前对象创建使用哪个工厂</span></span><br><span class="line"><span class="comment">                factory-method：指定使用工厂方法</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;airPlaneInstanceFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.factory.AirPlaneInstanceFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;airPlane&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.AirPlane&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">factory-bean</span>=<span class="string">&quot;airPlaneInstanceFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getAirPlane&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;张三三&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        FactoryBean（是Spring规定的一个接口），</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myFactoryBeanImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.factory.MyFactoryBeanImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>dbconfig.properties:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="meta">jdbc.jdbcUrl</span>=<span class="string">jdbc:mysql://localhost:3306/book</span></span><br><span class="line"><span class="meta">jdbc.driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<p>MyBeanPostProcessor:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/27 19:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化之前调用</span></span><br><span class="line"><span class="comment">     * Object bean：将要初始化的bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【&quot;</span> + beanName + <span class="string">&quot;】bean将要调用初始化方法了。。。BeforeInitialization。。。这个bean是这样【&quot;</span> + bean + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回传入的bean</span></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法之后调用</span></span><br><span class="line"><span class="comment">     *      String beanName：bean在xml中配置的id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【&quot;</span> + beanName + <span class="string">&quot;】bean初始化方法调用完了。。。AfterInitialization。。。这个bean是这样【&quot;</span> + bean + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AirPlaneInstanceFactory:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atqingke.bean.AirPlane;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/27 12:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirPlaneInstanceFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * new AirPlaneInstanceFactory.getAirPlane();</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AirPlane <span class="title">getAirPlane</span><span class="params">(String jzName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实例工厂调用了......&quot;</span>);</span><br><span class="line">        AirPlane airPlane = <span class="keyword">new</span> AirPlane();</span><br><span class="line">        airPlane.setFdj(<span class="string">&quot;太行&quot;</span>);</span><br><span class="line">        airPlane.setFjsName(<span class="string">&quot;pb&quot;</span>);</span><br><span class="line">        airPlane.setJzName(jzName);</span><br><span class="line">        airPlane.setPersonNum(<span class="number">300</span>);</span><br><span class="line">        airPlane.setYc(<span class="string">&quot;198.56m&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> airPlane;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AirPlane:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/27 12:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirPlane</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 发动机 */</span></span><br><span class="line">    <span class="keyword">private</span> String fdj;</span><br><span class="line">    <span class="comment">/** 机翼长度 */</span></span><br><span class="line">    <span class="keyword">private</span> String yc;</span><br><span class="line">    <span class="comment">/** 乘客 */</span></span><br><span class="line">    <span class="keyword">private</span> Integer personNum;</span><br><span class="line">    <span class="comment">/** 机长 */</span></span><br><span class="line">    <span class="keyword">private</span> String jzName;</span><br><span class="line">    <span class="comment">/** 副驾驶 */</span></span><br><span class="line">    <span class="keyword">private</span> String fjsName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AirPlane</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AirPlane</span><span class="params">(String fdj, String yc, Integer personNum, String jzName, String fjsName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fdj = fdj;</span><br><span class="line">        <span class="keyword">this</span>.yc = yc;</span><br><span class="line">        <span class="keyword">this</span>.personNum = personNum;</span><br><span class="line">        <span class="keyword">this</span>.jzName = jzName;</span><br><span class="line">        <span class="keyword">this</span>.fjsName = fjsName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFdj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fdj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFdj</span><span class="params">(String fdj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fdj = fdj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getYc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> yc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setYc</span><span class="params">(String yc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.yc = yc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getPersonNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> personNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPersonNum</span><span class="params">(Integer personNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.personNum = personNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getJzName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jzName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJzName</span><span class="params">(String jzName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jzName = jzName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFjsName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fjsName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFjsName</span><span class="params">(String fjsName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fjsName = fjsName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;AirPlane&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;fdj=&#x27;&quot;</span> + fdj + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, yc=&#x27;&quot;</span> + yc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, personNum=&quot;</span> + personNum +</span><br><span class="line">                <span class="string">&quot;, jzName=&#x27;&quot;</span> + jzName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, fjsName=&#x27;&quot;</span> + fjsName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>AirPlaneStaticFactory:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atqingke.bean.AirPlane;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/27 12:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirPlaneStaticFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AirPlaneStaticFactory.getAirPlane();</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AirPlane <span class="title">getAirPlane</span><span class="params">(String jzName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态工厂调用了......&quot;</span>);</span><br><span class="line">        AirPlane airPlane = <span class="keyword">new</span> AirPlane();</span><br><span class="line">        airPlane.setFdj(<span class="string">&quot;太行&quot;</span>);</span><br><span class="line">        airPlane.setFjsName(<span class="string">&quot;pb&quot;</span>);</span><br><span class="line">        airPlane.setJzName(jzName);</span><br><span class="line">        airPlane.setPersonNum(<span class="number">300</span>);</span><br><span class="line">        airPlane.setYc(<span class="string">&quot;198.56m&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> airPlane;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>MyFactoryBeanImpl:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atqingke.bean.Book;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.FactoryBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现了FactoryBean接口的类是Spring可以认识的工厂类</span></span><br><span class="line"><span class="comment"> * Spring会自动调用工厂方法创建实例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1、编写一个FactoryBean的实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/27 13:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFactoryBeanImpl</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Book</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂方法，返回创建对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Book <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Book book = <span class="keyword">new</span> Book();</span><br><span class="line">        book.setBookName(UUID.randomUUID().toString());</span><br><span class="line">        <span class="keyword">return</span> book;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回创建的对象类型，Spring会自动调用这个方法来确认创建的对象是什么类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Book.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为单例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true,单例；false,不是单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>IOCTest:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atqingke.bean.Book;</span><br><span class="line"><span class="keyword">import</span> com.atqingke.bean.Person;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/26 15:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOCTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;ioc2.xml&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> ConfigurableApplicationContext ioc = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;ioc2.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test14</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person person14 = ioc.getBean(<span class="string">&quot;person14&quot;</span>, Person.class);</span><br><span class="line">        System.out.println(person14);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test13</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person person13 = ioc.getBean(<span class="string">&quot;person13&quot;</span>, Person.class);</span><br><span class="line">        System.out.println(person13);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test11</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        DataSource dataSource = ioc.getBean(DataSource.class);</span><br><span class="line">        System.out.println(dataSource.getConnection());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Book book10 = ioc.getBean(<span class="string">&quot;book10&quot;</span>, Book.class);</span><br><span class="line">        System.out.println(book10);</span><br><span class="line">        ioc.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person person = context.getBean(<span class="string">&quot;person07&quot;</span>,Person.class);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>二十三个实验入门SpringIOC(上)</title>
    <url>/2021/12/25/%E4%BA%8C%E5%8D%81%E4%B8%89%E4%B8%AA%E5%AE%9E%E9%AA%8C%E5%85%A5%E9%97%A8SpringIOC-%E4%B8%8A/</url>
    <content><![CDATA[<h1 id="搭建实验环境"><a href="#搭建实验环境" class="headerlink" title="搭建实验环境"></a>搭建实验环境</h1><p>新建普通Java工程：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211225163705634.png" alt="image-20211225163705634"></p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211225163912669.png" alt="image-20211225163912669"></p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211225163750396.png" alt="image-20211225163750396"></p>
<p>创建项目包结构如图所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211225164253162.png" alt="image-20211225164253162"></p>
<p>lib目录下引入SpringIOC所需jar包：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211225164356096.png" alt="image-20211225164356096"></p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/idea64_CVGsLXEMFL.png"></p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211225165523791.png" alt="image-20211225165523791"></p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211225165711714.png" alt="image-20211225165711714"></p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211225165753740.png" alt="image-20211225165753740"></p>
<p>bean目录下新建Person类：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211225165846399.png" alt="image-20211225165846399"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/25 16:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String lastName, Integer age, String email, String gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;lastName=&#x27;&quot;</span> + lastName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, email=&#x27;&quot;</span> + email + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, gender=&#x27;&quot;</span> + gender + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>conf目录下新建一个Spring的配置文件，ioc.xml：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211225170136906.png" alt="image-20211225170136906"></p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211225170255175.png" alt="image-20211225170255175"></p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211225170350958.png" alt="image-20211225170350958"></p>
<p>OK，大功告成！</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211225170430871.png" alt="image-20211225170430871"></p>
<h1 id="实验1：通过IOC容器创建对象，并为属性赋值-★"><a href="#实验1：通过IOC容器创建对象，并为属性赋值-★" class="headerlink" title="实验1：通过IOC容器创建对象，并为属性赋值 ★"></a>实验1：通过IOC容器创建对象，并为属性赋值 ★</h1><p> IOC，Spring官网给出的英文释义是：Inversion of control，中文翻译过来就是<strong>控制反转</strong>。那什么是控制反转呢？</p>
<p>我们知道，在没有引入Spring框架之前，我们如果需要使用一个资源，我们需要自己去创建、管理、销毁等等，这是一种主动式的获取资源。而SpringIOC所做的就是控制我们的资源获取方式，将主动式反转成被动式——资源的获取不是我们自己创建，而是交由容器来创建和设置。而所谓<strong>容器</strong>就是：管理所有组件（有功能的类）；简单来说，容器做的就是让主动的new资源变成了被动的接受资源。</p>
<p>而说到容器，就离不开另一个概念——DI（Dependency Injection）依赖注入，通过这个依赖注入，容器能知道哪个组件运行的时候，需要另外的组件。并通过反射的形式，将容器中准备好的对象注入进来。</p>
<p>我们先看没有引入SpringIOC之前，我们的对象创建以及属性赋值操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atqingke.bean.Person;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/26 15:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeIOCTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.setLastName(<span class="string">&quot;引入Spring之前为属性赋值&quot;</span>);</span><br><span class="line">        person.setAge(<span class="number">21</span>);</span><br><span class="line">        person.setEmail(<span class="string">&quot;fff&quot;</span>);</span><br><span class="line">        person.setGender(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们来看实验1！</p>
<p>首先在之前创建的ioc.xml文件中加入以下内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 注册一个Person对象，Spring会自动创建这个Person对象 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        一个Bean标签可以注册一个组件</span></span><br><span class="line"><span class="comment">        class：写要注册的组件的全类名</span></span><br><span class="line"><span class="comment">        id：这个对象的唯一标识</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">              使用property标签为Person对象的属性赋值</span></span><br><span class="line"><span class="comment">              name指定属性名</span></span><br><span class="line"><span class="comment">              value指定属性值</span></span><br><span class="line"><span class="comment">           --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;引入IOC之后的属性赋值&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;23&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ddd&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ddd&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们在容器中添加一个bean标签，就相当于创建了一个对象，class属性指明了我们创建的对象类型，id就是我们创建的对象名称。在bean标签里有property子标签，property表示的就是对象的属性，我们通过property给对象的属性赋值。property的name属性指明要赋值的属性名称，value属性指明要赋的值。</p>
<p>接下来，我们就可以获取这个由容器管理的组件了。</p>
<h1 id="实验2：根据bean的类型从IOC容器中获取bean的实例-★"><a href="#实验2：根据bean的类型从IOC容器中获取bean的实例-★" class="headerlink" title="实验2：根据bean的类型从IOC容器中获取bean的实例 ★"></a>实验2：根据bean的类型从IOC容器中获取bean的实例 ★</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ackage com.atqingke.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atqingke.bean.Person;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/26 15:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOCTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;ioc.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person person = context.getBean(Person.class);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ApplicationContext是Spring提供给我们的IOC容器的接口，通过这个接口，我们可以读取我们在配置文件中配置的组件。ClassPathXmlApplicationContext表示的就是在类路径下读取配置文件。而getBean方法就是根据bean的类型从IOC容器中获取bean的实例方法。我们来看运行效果：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211226153911719.png" alt="image-20211226153911719"></p>
<p>可以看到报错了，为什么呢？我们知道，ClassPathXmlApplicationContext是从类路径下读取配置文件，而我们的ioc.xml是在conf目录下，所以我们需要将conf目录设为我们工程的资源目录。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211226154259269.png" alt="image-20211226154259269"></p>
<p>成功之后，conf目录图标就变成了Resource资源的图标了：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211226154340666.png" alt="image-20211226154340666"></p>
<p>现在再运行，不报错了！</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211226154423157.png" alt="image-20211226154423157"></p>
<p>现在，我们来看一些细节。</p>
<blockquote>
<ol>
<li>给容器中注册一个组件，我们也从容器中按照id拿到了这个组件的对象，组件的创建工作，是由容器完成的。容器中的对象在容器创建完成的时候就已经创建好了。</li>
<li>同一个组件在IOC容器中是单实例的，容器启动完成之前已经创建好了。</li>
<li>容器中如果没有这个组件，获取组件，报异常：org.springframework.beans.factory.NoSuchBeanDefinitionException:No bean named ‘person2’ available</li>
<li>IOC容器在创建这个组件对象的时候，property标签会利用setter方法为JavaBean的属性进行赋值。</li>
</ol>
</blockquote>
<p>我们除了可以通过ClassPathXmlApplicationContext获取配置文件，还可以通过FileSystemXmlApplicationContext在系统文件路径下获取配置文件。</p>
<h1 id="实验3：通过构造器为bean的属性赋值（index-type属性介绍）"><a href="#实验3：通过构造器为bean的属性赋值（index-type属性介绍）" class="headerlink" title="实验3：通过构造器为bean的属性赋值（index,type属性介绍）"></a>实验3：通过构造器为bean的属性赋值（index,type属性介绍）</h1><p> 实验2的赋值是通过setter方法赋值的，我们也可以通过构造器为bean的属性赋值：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person031&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 调用有参构造器进行创建对象并赋值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小行星&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;4564654@ddd.com&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;55&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在，我们有两个由容器管理的bean对象了，在获取bean对象的时候，我们可以通过在类型前面加一个参数指明要获取的bean的id就可以成功获取了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">context.getBean(<span class="string">&quot;person031&quot;</span>, Person.class);</span><br><span class="line"><span class="comment">// 也可以直接省略后面的bean类型</span></span><br></pre></td></tr></table></figure>

<p>我们也可以省略name参数，但这是我们要严格按照构造器中的顺序来赋值，如果没有按顺序，可以通过index属性来指明顺序：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">   <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   	可以省略name属性，严格按照构造器参数位置赋值</span></span><br><span class="line"><span class="comment">   	也可以通过index指定对应参数位置</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person032&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;xixi&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span> <span class="attr">index</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;xixi&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;456&quot;</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在构造器有重载的情况下，我们可以用type属性来指明要赋值的属性的类型：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    public Person(String lastName, String gender, String email)</span></span><br><span class="line"><span class="comment">    public Person(String lastName, Integer age, String email)</span></span><br><span class="line"><span class="comment">    在重载情况下，可以通过type指定参数的类型</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person033&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;ddd&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.Integer&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;ddd&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 当我们为一个JavaBean的属性赋值时，如果这个JavaBean出现与其它属性同名的情况，为了区分，我们可以通过p名称空间为bean赋值。要使用新的名称空间，我们需要在配置文件的beans标签中加入该名称空间：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211226161151185.png" alt="image-20211226161151185"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    通过p名称空间为bean赋值</span></span><br><span class="line"><span class="comment">    名称空间：在xml中名称空间是用来防止标签重复的</span></span><br><span class="line"><span class="comment">    &lt;book&gt;</span></span><br><span class="line"><span class="comment">        &lt;name&gt;西游记&lt;/name&gt;</span></span><br><span class="line"><span class="comment">        &lt;price&gt;155&lt;/price&gt;</span></span><br><span class="line"><span class="comment">        &lt;author&gt;</span></span><br><span class="line"><span class="comment">            &lt;a:name&gt;吴承恩&lt;a:/name&gt;</span></span><br><span class="line"><span class="comment">            &lt;gender&gt;男&lt;/gender&gt;</span></span><br><span class="line"><span class="comment">        &lt;/author&gt;</span></span><br><span class="line"><span class="comment">    &lt;/book&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    带前缀的标签&lt;c:forEach&gt; &lt;jsp:forEach&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person034&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span> <span class="attr">p:age</span>=<span class="string">&quot;15&quot;</span> <span class="attr">p:lastName</span>=<span class="string">&quot;www&quot;</span> <span class="attr">p:email</span>=<span class="string">&quot;fff&quot;</span> <span class="attr">p:gender</span>=<span class="string">&quot;ddd&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="实验4：正确的为各种属性赋值"><a href="#实验4：正确的为各种属性赋值" class="headerlink" title="实验4：正确的为各种属性赋值"></a>实验4：正确的为各种属性赋值</h1><p>在进行实验4之前，我们要对现在的工程进行改造一下：</p>
<p>添加两个类Car和Book：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/26 16:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String carName, Integer price, String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.carName = carName;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCarName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> carName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCarName</span><span class="params">(String carName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.carName = carName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(Integer price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Car&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;carName=&#x27;&quot;</span> + carName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&quot;, color=&#x27;&quot;</span> + color + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/26 16:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String bookName, String author)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookName = bookName;</span><br><span class="line">        <span class="keyword">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBookName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBookName</span><span class="params">(String bookName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookName = bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAuthor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthor</span><span class="params">(String author)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Book&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;bookName=&#x27;&quot;</span> + bookName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, author=&#x27;&quot;</span> + author + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改Person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Car car;</span><br><span class="line"><span class="keyword">private</span> List&lt;Book&gt; books;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; maps;</span><br><span class="line"><span class="keyword">private</span> Properties properties;</span><br></pre></td></tr></table></figure>

<p>添加四个属性，并重新生成getter、setter方法和toString以及Constructor。</p>
<blockquote>
<ul>
<li> 测试使用null值 </li>
<li> 引用类型赋值（引用其他bean、引用内部bean）</li>
<li> 集合类型赋值（List、Map、Properties）、</li>
<li> util名称空间创建集合类型的bean</li>
<li> 级联属性赋值</li>
</ul>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--级联属性赋值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person045&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;car&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;car01&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;car.price&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456798&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--util名称空间创建集合类型的bean--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--util名称空间创建集合类型的bean，方便别人引用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person044&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maps&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;myMap&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">util:map</span> <span class="attr">id</span>=<span class="string">&quot;myMap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;key01&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;key02&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;key03&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;book01&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;key04&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Car&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;carName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ddd&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;key05&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">util:map</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--集合类型赋值（List、Map、Properties）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person043&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;books&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--list 标签相当于 books = new ArrayList&lt;Book&gt;();--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book000x&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Book&quot;</span> <span class="attr">p:bookName</span>=<span class="string">&quot;西游记&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;book01&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maps&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--map 标签相当于 maps = new LinkedHashMap&lt;&gt;();--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;key01&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;key02&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;key03&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;book01&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;key04&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Car&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;carName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ddd&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;key05&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--props 标签相当于 properties = new Properties();--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;username&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Book&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;水浒传&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--引用类型赋值（引用其他bean、引用内部bean）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person042&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--ref标签就是用来引用外部其它bean--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;car&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;car01&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;car01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Car&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;carName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;五零&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--测试使用null值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person041&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;测试null值&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        通过p名称空间为bean赋值</span></span><br><span class="line"><span class="comment">        名称空间：在xml中名称空间是用来防止标签重复的</span></span><br><span class="line"><span class="comment">        &lt;book&gt;</span></span><br><span class="line"><span class="comment">            &lt;name&gt;西游记&lt;/name&gt;</span></span><br><span class="line"><span class="comment">            &lt;price&gt;155&lt;/price&gt;</span></span><br><span class="line"><span class="comment">            &lt;author&gt;</span></span><br><span class="line"><span class="comment">                &lt;a:name&gt;吴承恩&lt;a:/name&gt;</span></span><br><span class="line"><span class="comment">                &lt;gender&gt;男&lt;/gender&gt;</span></span><br><span class="line"><span class="comment">            &lt;/author&gt;</span></span><br><span class="line"><span class="comment">        &lt;/book&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        带前缀的标签&lt;c:forEach&gt; &lt;jsp:forEach&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person034&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span> <span class="attr">p:age</span>=<span class="string">&quot;15&quot;</span> <span class="attr">p:lastName</span>=<span class="string">&quot;www&quot;</span> <span class="attr">p:email</span>=<span class="string">&quot;fff&quot;</span> <span class="attr">p:gender</span>=<span class="string">&quot;ddd&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        public Person(String lastName, String gender, String email)</span></span><br><span class="line"><span class="comment">        public Person(String lastName, Integer age, String email)</span></span><br><span class="line"><span class="comment">        在重载情况下，可以通过type指定参数的类型</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person033&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;ddd&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.Integer&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;ddd&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        可以省略name属性，严格按照构造器参数位置赋值</span></span><br><span class="line"><span class="comment">        也可以通过index指定对应参数位置</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person032&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;xixi&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span> <span class="attr">index</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;xixi&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;456&quot;</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person031&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 调用有参构造器进行创建对象并赋值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小行星&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;4564654@ddd.com&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;55&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 注册一个Person对象，Spring会自动创建这个Person对象 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        一个Bean标签可以注册一个组件</span></span><br><span class="line"><span class="comment">        class：写要注册的组件的全类名</span></span><br><span class="line"><span class="comment">        id：这个对象的唯一标识</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atqingke.bean.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">              使用property标签为Person对象的属性赋值</span></span><br><span class="line"><span class="comment">              name指定属性名</span></span><br><span class="line"><span class="comment">              value指定属性值</span></span><br><span class="line"><span class="comment">           --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;引入IOC之后的属性赋值&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;23&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ddd&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ddd&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>内存管理概念</title>
    <url>/2021/12/25/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<blockquote>
<ol>
<li>为什么要进行内存管理？</li>
<li>页式管理中每个页表项的大小的下限如何决定？</li>
<li>多级页表解决了什么问题？又会带来什么问题？</li>
</ol>
</blockquote>
<h1 id="1-内存管理的基本原理和要求"><a href="#1-内存管理的基本原理和要求" class="headerlink" title="1. 内存管理的基本原理和要求"></a>1. 内存管理的基本原理和要求</h1><p>Memory Management是OS设计中最重要和最复杂的内容之一。虽然硬件技术在不断发展，内存容量在不断增大，但仍然不可能将所有用户进程和系统所需的全部资源放入主存，因此OS必须对内存空间进行合理的划分和有效的动态分配，而这就是内存管理的概念。</p>
<p>内存管理的功能有：</p>
<blockquote>
<ul>
<li><strong>内存空间的分配与回收</strong>。由OS完成主存储器空间的分配和管理，使程序员摆脱存储分配的麻烦，提高编程效率。</li>
<li><strong>地址转换。</strong>在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址。</li>
<li><strong>内存空间的扩充。</strong>利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存。</li>
<li><strong>存储保护。</strong>保证所有作业在自己的存储空间内运行，互不干扰。</li>
</ul>
</blockquote>
<h2 id="1-1-程序装入和链接"><a href="#1-1-程序装入和链接" class="headerlink" title="1.1 程序装入和链接"></a>1.1 程序装入和链接</h2><p>创建进程首先要将程序和数据装入内存。将用户源程序变为可在内存中执行的程序，通常需要以下几个步骤：</p>
<blockquote>
<ul>
<li>编译。由编译程序将用户源代码编译成若干目标模块。</li>
<li>链接。由链接程序将编译后形成的一组目标模块及所需的库函数链接在一起，形成一个完整的装入模块。</li>
<li>装入。由装入程序将装入模块装入内存运行。</li>
</ul>
</blockquote>
<p>这三步如图所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211228140435063.png" alt="image-20211228140435063"></p>
<p>程序的链接有以下三种方式：</p>
<ul>
<li><strong>静态链接</strong>。程序运行前，就已经将各个模块和库函数链接成一个可执行程序，以后也不再拆开。</li>
<li><strong>装入时动态链接</strong>。装入内存时，边装入，边链接。</li>
<li><strong>运行时动态链接</strong>。程序运行时链接。便于修改和更新以及实现对目标模块的共享。</li>
</ul>
<p>内存的装入模块在装入内存时，也有三种方式：</p>
<ul>
<li><p><strong>绝对装入</strong>。编译时，就已经知道程序的内存位置。绝对装入程序只要按照模块中的地址，将程序和数据装入进去即可（不需要修改程序和数据）。这种方式只适用于单道程序环境。</p>
</li>
<li><p><strong>可重定位装入</strong>。在多道程序环境下，多个目标模块的起始地址通常都是从0开始，程序中的其它地址都是相对于始址的。根据内存的当前情况，将装入模块装入内存的适当位置。装入时对目标程序中指令和数据的修改过程称为<strong>重定位</strong>，地址变换通常是在装入时一次完成的，所以又称静态重定位。</p>
<p>静态重定位的特点是：一个作业装入内存时，必须给它分配要求的全部内存空间，如果没有足够的空间，则不能装入。此外，作业一旦进入内存空间，就不能移动或者再申请内存空间。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211228145653209.png" alt="image-20211228145653209"></p>
<ul>
<li><p><strong>动态运行时装入</strong>。也称动态重定位。上面讲了，可重定位装入方式一旦作业进入内存空间就不能移动，而通常而言，程序都有移动的需求，因此动态重定位也就产生了。装入程序装入内存后，并不立即把装入模块中的相对地址转换成绝对地址，而是<strong>把这种地址转换推迟到程序真正执行的时候才进行</strong>。因此，装入内存后的所有地址均为相对地址。这种方式需要一个重定位寄存器的支持。</p>
<p>动态重定位的特点是：可以将程序分配到不连续的存储区中；只需要装入部分代码即可运行程序，然后在程序运行期间，动态申请内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。</p>
</li>
</ul>
<h2 id="1-2-逻辑地址空间和物理地址空间"><a href="#1-2-逻辑地址空间和物理地址空间" class="headerlink" title="1.2 逻辑地址空间和物理地址空间"></a>1.2 逻辑地址空间和物理地址空间</h2><p>用户和程序员只需要知道逻辑地址，而内存管理的具体机制则是完全透明的，只有系统编程人员才会涉及内存管理的具体机制。不同进程可以有相同的逻辑地址，因为这些相同的逻辑地址可以映射到主存中的不同位置。</p>
<p>当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址，这个过程称为<strong>地址重定位</strong>。</p>
<h2 id="1-3-内存保护"><a href="#1-3-内存保护" class="headerlink" title="1.3 内存保护"></a>1.3 内存保护</h2><p>内存分配前，需要保护OS不受用户进程的影响，同时保护用户进程不受其它用户进程的影响。内存保护可采取两种方法：</p>
<ol>
<li>在CPU中设置一对上、下限寄存器，存放用户作业在主存中的下限和上限地址，每当CPU要访问一个地址时，分别和两个寄存器的值相比，判断有无越界。</li>
<li>采用重定位寄存器（或基址寄存器）和界地址寄存器（又称限长寄存器）来实现这种保护。重定位寄存器包含最小的物理地址，界地址寄存器包含逻辑地址的最大值。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211228160242172.png" alt="image-20211228160242172"></p>
<p>实现内存保护需要重定位寄存器和界地址寄存器，因此要注意两者区别：</p>
<ul>
<li>重定位寄存器是用来“加”的，逻辑地址 + 重定位寄存器中的值 = 物理地址</li>
<li>界地址寄存器是用来“比”的，通过比较界地址寄存器和逻辑地址的值来判断是否越界。</li>
</ul>
<h1 id="2-覆盖与交换"><a href="#2-覆盖与交换" class="headerlink" title="2. 覆盖与交换"></a>2. 覆盖与交换</h1><p>覆盖与交换技术是用在多道程序环境下用来扩充内存的两种方法。</p>
<h2 id="2-1-覆盖"><a href="#2-1-覆盖" class="headerlink" title="2.1 覆盖"></a>2.1 覆盖</h2><p>由于程序时并非任何时刻都要访问所有数据，因此可以把用户空间分成一个固定区和若干覆盖区。将经常活跃的部分放在固定区，其余按调用关系分段。先将即将访问的段放入覆盖区，其它段放在外存中，需要调用时，系统再将其调入覆盖区，替换覆盖区中原有的段。</p>
<p>覆盖技术的特点是：打破了一个进程必须全部装入主存才能运行的限制，但是当同时运行的程序大于主存的容量，仍然是不能运行的。而且，内存中只有覆盖区可以更新，不在覆盖区的部分会常驻内存。</p>
<h2 id="2-2-交换"><a href="#2-2-交换" class="headerlink" title="2.2 交换"></a>2.2 交换</h2><p>把处于等待状态的程序从内存移到辅存，腾出内存空间，这一过程又称<strong>换出</strong>；把准备好的竞争CPU运行的程序从辅存移到内存，这一过程又称<strong>换入</strong>。</p>
<p>关于交换需要注意的问题：</p>
<ol>
<li>交换需要备份存储，通常是快速磁盘。它必须足够大，并提供对这些内存映像的直接访问。</li>
<li>为了有效使用CPU，需要使每个进程的执行时间比交换时间长。</li>
<li>若换出进程，则必须保证该进程处于完全空闲状态。</li>
<li>交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用起来可能更快。</li>
<li>交换通常在有许多进程运行且内存空间吃紧时开始启动，而在系统负荷降低时就暂停。</li>
<li>普通的交换使用不多，但交换策略的变体在许多系统中仍然发挥作用。</li>
</ol>
<p>交换主要在不同进程之间进行，而覆盖则在同一程序或进程中。</p>
<h1 id="3-连续分配管理方式"><a href="#3-连续分配管理方式" class="headerlink" title="3. 连续分配管理方式"></a>3. 连续分配管理方式</h1><p>连续分配方式是指为一个用户程序分配一个连续的内存空间。主要包括单一连续分配、固定分区分配和动态分区分配。</p>
<h2 id="3-1-单一连续分配"><a href="#3-1-单一连续分配" class="headerlink" title="3.1 单一连续分配"></a>3.1 单一连续分配</h2><p>内存在此方式下分为系统区和用户区，系统区仅供OS使用，通常在低地址部分。这种方式无须进行内存包含，因为内存中永远只有一道程序，因此肯定不会因为访问越界而干扰其它程序。</p>
<p>这种方式简单、无外部碎片，可以采用覆盖技术，不需要额外的技术支持。缺点是只能用于单用户、单任务的OS中，有内部碎片，存储器的利用率极低。</p>
<h2 id="3-2-固定分区分配"><a href="#3-2-固定分区分配" class="headerlink" title="3.2 固定分区分配"></a>3.2 固定分区分配</h2><p>将用户内存空间划分为若干固定大小的区域，每个分区只装入一道作业。在划分分区时有两种不同的方法：</p>
<ul>
<li>分区大小相等</li>
<li>分区大小不等</li>
</ul>
<p>为便于内存分配，通常将分区按大小排队，并为之建立一张分区说明表，其中各表项包括每个分区的始址、大小及状态。当有用户程序要装入时，便检索该表，以找到合适的分区予以分配并将其状态置为“已分配”；没有找到则拒绝分配。</p>
<p>这种方式存在两个问题：</p>
<ol>
<li>程序可能太大而放不进任何一个分区</li>
<li>主存利用率低，当程序小于固定分区大小时，也占用了一个完整的内存分区空间，这样分区内部就存在空间浪费，这种现象称为内部碎片。</li>
</ol>
<h2 id="3-3-动态分区分配"><a href="#3-3-动态分区分配" class="headerlink" title="3.3 动态分区分配"></a>3.3 动态分区分配</h2><p>这种分区方法不预先划分内存，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此，系统中分区的大小和数目是可变的。</p>
<p>动态分区在开始分配时是很好的，但之后会导致内存中出现许多小的内存块，内存利用率也随之下降。克服外部碎片可以通过<strong>紧凑</strong>技术来解决，即OS不时地对进程进行移动和整理。但这需要动态重定位寄存器的支持，且相对费时。</p>
<p>在进程装入或换入主存时，若内存中有多个足够大的空闲块，则OS必须确定分配哪个内存块给进程使用，这就是动态分区的分配策略。考虑以下几种算法：</p>
<ol>
<li><strong>首次适应算法（First Fit）</strong>空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。</li>
<li><strong>最佳适应算法（Best Fit）</strong>空闲分区按容量递增的方式形成分区链，找到第一个能满足要求的空闲分区。</li>
<li><strong>最坏适应算法（Worst Fit）</strong>又称最大适应（Largest Fit）算法，空闲分区以容量递减的次序链接，找到第一个能满足要求的空闲分区，即挑选出最大的分区。</li>
<li><strong>邻近使用算法（Next Fit）</strong>又称循环首次适应算法，由首次适应算法演变而成。不同之处是，分配内存时从上次查找结束的位置开始继续查找。</li>
</ol>
<p>在这几种方法中，First Fit不仅最简单，通常也是最好和最快的。但是会使得低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此增加了查找的开销。</p>
<p>邻近适应算法试图解决这个问题。但实际上，它常常导致在内存的末尾分配空间分裂成小碎片。它通常比首次适应算法的结果要差。</p>
<p>最佳适应虽然称为“最佳”，但是性能通常很差，因为每次最佳的分配会留下很小的难以利用的内存块，会产生最多的外部碎片。</p>
<p>最坏与最佳相反，选择最大的可用块，会很快导致没有可用的大内存块，因此性能也非常差。</p>
<p>Knuth和Shore分别就前三种方法做了模拟实验，结果表明：首次可能比最佳效果好，而这两者一定比最大效果好。另外，在算法实现时，分配操作中最佳和最大需要对可用块进行排序或遍历查找，而首次和邻近只需要简单查找；在回收操作时，当回收的块与原来的空闲块相邻时，需要合并。</p>
<p>三种内存分区管理方式的比较如下表：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211228202338021.png" alt="image-20211228202338021"></p>
<p>以上三种内存分区管理方法有一个共同特点，即用户进程在主存中都是连续存放的。</p>
<h1 id="4-非连续分配管理方式"><a href="#4-非连续分配管理方式" class="headerlink" title="4. 非连续分配管理方式"></a>4. 非连续分配管理方式</h1><p>在连续分配方式中，即使内存中有1GB的空闲空间，但如果不是连续的，那么需要1GB的作业仍然是无法运行的。但如果采用非连续分配方式，则可以将这1GB的作业分散地分配在内存的各个区域，当然，这也需要额外的空间去存储它们（分散区域）的索引，使得非连续分配方式的存储密度低于连续存储方式的。</p>
<p>非连续分配管理方式根据分区的大小是否固定，分为分页存储管理方式和分段存储管理方式。</p>
<p>在分页存储管理方式中，又根据运行作业时是否要把作业的所有页面都装入内存才能运行，分为基本分页存储管理方式和请求分页存储管理方式。</p>
<h2 id="4-1-基本分页存储管理方式"><a href="#4-1-基本分页存储管理方式" class="headerlink" title="4.1 基本分页存储管理方式"></a>4.1 基本分页存储管理方式</h2><p>固定分区会产生内部碎片，动态分区会产生外部碎片，而且这两种技术对内存的利用率都比较低。我们希望内存的使用能尽量避免碎片的产生，这就引入了分页的思想：<strong>把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。</strong></p>
<p>分页从形式上看，类似分区相等的固定分区技术，但是分页管理不会产生外部碎片。但是两者有本质的不同点：<strong>块的大小相对分区的大小要小很多</strong>。而且因为进程也是按块划分的，所以尽管会产生内部碎片，但也只有在进程的最后一个块才有，这种碎片相对进程来说是非常小的，每个进程平均只产生半个块大小的内部碎片（也称<strong>页内碎片</strong>）。</p>
<h3 id="4-1-1-分页存储的几个基本概念"><a href="#4-1-1-分页存储的几个基本概念" class="headerlink" title="4.1.1 分页存储的几个基本概念"></a>4.1.1 分页存储的几个基本概念</h3><ol>
<li><p><strong>页面和页面大小</strong></p>
<p>进程中的块称为<strong>页</strong>，内存中的块称为<strong>页框（或页帧</strong>）。外存也以同样的单位进行划分，直接称为<strong>块</strong>。进程在执行时需要申请主存空间，即要为每个页面分配主存中的可用页框，这就产生了页和页框一一对应。</p>
<p>为方便地址转换，<strong>页面大小应是2的整数幂</strong>。同时页面大小应该适中，<strong>太小</strong>会使进程页面数过多，这样页表就过长，占用大量内存，而且也会增加硬件地址转换的开销，降低页面的换入/换出的效率；页面<strong>过大</strong>会使页内碎片增多，降低内存的利用率。</p>
</li>
<li><p><strong>地址结构</strong></p>
<p>地址结构包含两部分：前一部分为页号P，后一部分为页内偏移量W。地址长度为32位，其中0~11位为页内地址，即每页大小为4KB；12-31位为页号，地址空间最多允许二的二十次方页。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229131227978.png" alt="image-20211229131227978"></p>
<p>注意，地址结构决定了虚拟内存的寻址空间有多大。</p>
</li>
<li><p><strong>页表</strong></p>
<p>为了便于在内存中找到进程的每个页面对应的物理块，系统为每个进程建立了一张页表，它<strong>记录页面在内存中对应的物理块号</strong>，页表一般存放在内存中。</p>
<p>页表是由页表项组成的，页表项和地址都是由两部分组成的，而且第一部分都是页号，但页表项的第二部分是物理内存中的块号，而地址的第二部分是页内偏移；<strong>页表项的第二部分与地址的第二部分共同组成物理地址</strong>。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229132720413.png" alt="image-20211229132720413"></p>
<p><strong>页表的作用就是实现从页号到物理块号的地址映射。</strong></p>
</li>
</ol>
<h3 id="4-1-2-基本地址变换机构"><a href="#4-1-2-基本地址变换机构" class="headerlink" title="4.1.2 基本地址变换机构"></a>4.1.2 基本地址变换机构</h3><p>地址变换机构的任务是将逻辑地址转换为内存中的物理地址。地址变换是借助于页表实现的。如图给出了分页存储管理系统中的地址变换机构：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229135240244.png" alt="image-20211229135240244"></p>
<p>在系统中通常设置一个页表寄存器（PTR），存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和长度存放在进程控制块中，当进程执行时，才将页表始址和长度存入页表寄存器。设页面大小为L，逻辑地址A到物理地址E的变换过程如下（逻辑地址、页号、每页的长度都是十进制数）：</p>
<ol>
<li>计算页号P(P = A / L)和页内偏移量W(W=A % L)。</li>
<li>比较页号P和页表长度M，若P ≥ M，则产生越界中断，否则继续执行。</li>
<li>页表中页号P对应的页表项地址 = 页表始址F + 页号P * 页表项长度，取出该页表项内容b，即为物理块号。要注意区分页表长度和页表项长度。页表长度是指一共有多少页，页表项长度是指页地址占多大存储空间。</li>
<li>计算E = b * L + W，用得到的物理地址E去访问内存。</li>
</ol>
<p>以上整个地址转换由硬件完成。例如，若页面大小L为1KB，页号2对应的物理块为b = 8，计算逻辑地址A = 2500的物理地址E的过程如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P = <span class="number">2500</span> / <span class="number">1</span>KB = <span class="number">2</span></span><br><span class="line">W = <span class="number">2500</span> % <span class="number">1</span>KB = <span class="number">452</span></span><br><span class="line">E = <span class="number">8</span> * <span class="number">1024</span> + <span class="number">452</span> = <span class="number">8644</span></span><br></pre></td></tr></table></figure>

<p> 页表项的大小不是随意规定的，而是有所约束的。页表项的作用是找到该页在内存中的位置。以32位逻辑地址空间、字节编址单位、一页4KB为例，地址空间内一共有1MB（2的32B / 4KB）页，因此需要20位才能保证表示范围能容纳所有页面，又因为以字节作为编址单位，即页表项的大小 ≥ 20/8 = 3B。所以在这个条件下，为了保证页表项能够指向所有页面，页表项的大小应该大于3B。</p>
<p>下面讨论分页管理方式存在的两个主要问题：</p>
<ul>
<li>每次访存操作都需要进行逻辑地址到物理地址的转换，地址转换过程必须足够快，否则访存速度会降低；</li>
<li>每个进程引入页表，用于存储映射机制，页表不能太大，否则内存利用率会降低。</li>
</ul>
<h3 id="4-1-3-具有快表的地址变换机构"><a href="#4-1-3-具有快表的地址变换机构" class="headerlink" title="4.1.3 具有快表的地址变换机构"></a>4.1.3 具有快表的地址变换机构</h3><p>在上面的地址变换过程中，将所有页表存放在内存中，如果要存取数据或指令，则至少需要经过两次访存：第一次是访问页表，取出数据或指令的存放地址；第二次是根据地址取出数据或指令。</p>
<p>这样就比通常执行指令的速度满了一半。为此，在地址变换机构中增设一个具有并行查找能力的高速缓冲存储器——快表。又称<strong>相联存储器（TLB）</strong>，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，主存中的页表常称为慢表。具有快表的地址变换机构如图所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229145806007.png" alt="image-20211229145806007"></p>
<p>在具有快表的分页机制中，地址的变换过程如下：</p>
<ol>
<li>CPU给出逻辑地址后，由硬件进行地址转换，将页号送入高速缓存寄存器，并将此页号与快表中的所有页号进行比较。</li>
<li>若找到匹配的页号，说明所要访问的页表项在快表中，则直接从中取出该页对应的页框号，与页内偏移量拼接形成物理地址。这样，存取数据仅一次访存即可实现。</li>
<li>若未找到匹配的页号，则需要访问主存中的页表，在读出页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换。</li>
</ol>
<blockquote>
<p>注意：有些处理机设计为快表和慢表同时查找，若在快表中查找成功则终止慢表的查找。</p>
</blockquote>
<p>一般快表的命中率可达90%以上，这样分页带来的速度损失就可降低至10%一下。</p>
<h3 id="4-1-4-两级页表"><a href="#4-1-4-两级页表" class="headerlink" title="4.1.4 两级页表"></a>4.1.4 两级页表</h3><p>由于引入了分页管理，进程在执行时不需要将所有页调入内存页框，而只需将保存有映射关系的页表调入内存。但是，我们仍然需要考虑页表的大小。以32为逻辑地址空间、页面大小4KB、页表项大小4B为例。以一个40MB的进程为例，页表项共40KB（40MB / 4KB * 4B），若将所有页表项内容保存在内存中，则需要10个内存页框来保存整个页表，整个进程大小约为一万个页面。</p>
<p>为了压缩页表，我们进一步延伸页表映射的思想，就可得到二级分页。二级页表的逻辑地址空间格式如下：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229200300740.png" alt="image-20211229200300740"></p>
<p>二级页表实际上是在原有页表结构上再加上一层页表，示意结构如下：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229201658072.png" alt="image-20211229201658072"></p>
<p>建立多级页表的目的在于建立索引，以便不用浪费主存空间去存储无用的页表项，也不用盲目地顺序式查找页表项。</p>
<h2 id="4-2-基本分段存储管理方式"><a href="#4-2-基本分段存储管理方式" class="headerlink" title="4.2 基本分段存储管理方式"></a>4.2 基本分段存储管理方式</h2><p>分页管理方式是从计算机的角度考虑设计的，目的是为了提高内存的利用率。分页通过硬件机制实现，对用户完全透明。分段管理方式的提出则考虑了用户和程序员，以满足编程、信息保护和共享、动态增长和动态链接等多方面的需要。</p>
<h3 id="4-2-1-分段"><a href="#4-2-1-分段" class="headerlink" title="4.2.1 分段"></a>4.2.1 分段</h3><p>段式管理方式按照用户进程中的自然段划分逻辑空间。例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为5段，每段从0开始编址，并分配一段连续的地址空间（段内要求连续，段间不要求连续），其逻辑地址由段号S与段内偏移量W两部分组成。</p>
<p>如图，段号为16位，段内偏移量为16位，因此一个作业最多有2的16次方 = 65536段，最大段长为64KB。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229153510705.png" alt="image-20211229153510705"></p>
<h3 id="4-2-2-段表"><a href="#4-2-2-段表" class="headerlink" title="4.2.2 段表"></a>4.2.2 段表</h3><p>每个进程都有一张逻辑空间与内存空间映射的段表，其中每个段表项对应进程的一段，段表项记录该段在内存中的始址和长度。段表的内容如图所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229153735071.png" alt="image-20211229153735071"></p>
<p>配置段表后，执行中的进程可以通过查找段表，找到每段所对应的内存区。可见，段表用于实现从逻辑段到物理内存区的映射，如图所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229155523742.png" alt="image-20211229155523742"></p>
<h3 id="4-2-3-地址变换机构"><a href="#4-2-3-地址变换机构" class="headerlink" title="4.2.3 地址变换机构"></a>4.2.3 地址变换机构</h3><p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229203619342.png" alt="image-20211229203619342"></p>
<p>分段系统的地址变换过程如图所示。为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器，用于存放段表始址F和段表长度M。从逻辑地址A到物理地址E之间的地址变换过程如下：</p>
<ol>
<li>从逻辑地址A中取出前几位为段号S，后几位为段内偏移量W。</li>
<li>比较段号S和段表长度M，若S ≥ M，则产生越界中断，否则继续执行。</li>
<li>段表中段号S对应的段表项地址 = 段表始址F + 段号S * 段表项长度，取出该段表项的前几位得到段长C。若段内偏移量 ≥ C，则产生越界中断，否则继续执行。从这里我们可以知道，段表项实际上只有两部分，前几位是段长，后几位是始址。</li>
<li>取出段表项中该段的始址b，计算E = b + W，用得到的物理地址E去访问内存。</li>
</ol>
<h3 id="4-2-4-段的共享和保护"><a href="#4-2-4-段的共享和保护" class="headerlink" title="4.2.4 段的共享和保护"></a>4.2.4 段的共享和保护</h3><p>在分段系统中，段的共享是通过两个作业的段表中相应表项指向被共享的段的同一个物理副本来实现的。当一个作业正从共享段中读取数据时，必须防止另一个作业修改此共享段中的数据。不能修改的代码称为纯代码或可重入代码（不属于临界资源），这样的代码和不能修改的数据可以共享，而可修改的代码和数据不能共享。</p>
<h2 id="4-3-段页式管理方式"><a href="#4-3-段页式管理方式" class="headerlink" title="4.3 段页式管理方式"></a>4.3 段页式管理方式</h2><p>页式管理可以有效提高内存利用率，而分段管理能反映程序的逻辑结构并有利于段的共享。将这两种方式结合起来，便形成了段页式存储管理方式。</p>
<p>在段页式系统中，作业的地址空间首先被分成若干逻辑段，每段都有自己的段号，然后将每段分成若干大小固定的页。作业的逻辑地址分为三部分：段号、页号和页内偏移量，如图所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229203843529.png" alt="image-20211229203843529"></p>
<blockquote>
<p>注意：在一个进程中，段表只有一个，而页表可能有多个。</p>
</blockquote>
<p>在进行地址变换时，首先通过段表查到页表始址，然后通过页表找到页帧号，最后形成物理地址。如图，进行一次访问实际需要三次访问主存，这里同样可以使用快表来加快查找速度，其关键字由段号、页号组成，值是对应的页帧号和保护码。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229205235593.png" alt="image-20211229205235593"></p>
]]></content>
  </entry>
  <entry>
    <title>死锁预防</title>
    <url>/2021/12/24/%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2/</url>
    <content><![CDATA[<p>死锁避免从本质上来说是不可能的，因为它需要获知未来的请求，而这些请求是不可知的。</p>
<h1 id="1-破坏互斥条件"><a href="#1-破坏互斥条件" class="headerlink" title="1. 破坏互斥条件"></a>1. 破坏互斥条件</h1><p>如果资源不被一个进程所独占，那么死锁肯定不会产生。当然，允许两个进程同时使用打印机会造成混乱，通过采用假脱机打印机技术可以允许若干个进程同时产生输出。该模型中唯一真正请求使用物理打印机的进程是打印机守护进程，由于守护进程绝不会请求别的资源，所以不会因打印机而产生死锁。</p>
<p>假设守护进程被设计成在所有输出进入假脱机之前就开始打印。我们考虑这样一个情况，如果一个输出进程在头一轮打印之后决定等待几个小时，打印机就可能空闲。为了避免这一现象，一般将守护进程设计成在完整的输出文件就绪后才开始打印。</p>
<h1 id="2-破坏占有和等待条件"><a href="#2-破坏占有和等待条件" class="headerlink" title="2. 破坏占有和等待条件"></a>2. 破坏占有和等待条件</h1><p>只要禁止已持有资源的进程再等待其它资源便可以消除死锁。一种实现方法是规定所有进程在开始执行前请求所需的全部资源。如果所需的全部资源可用，那么就将它分配给这个进程，于是该进程肯定能够运行结束。反之，则不分配，进程等待。</p>
<p>这种方法的一个直接问题是很多进程直到运行时才知道它需要多少资源。实际上，如果进程能够知道它需要多少资源，就可以使用银行家算法了。另一个问题是这种方法的资源利用率不是最优的。例如，有一个进程先从输入磁带上读取数据，进行一小时的分析，最后会写到输出磁带上，同时会在绘图仪上绘出。如果所有资源都必须提前请求，这个进程就会把输出磁带机和绘图仪控制住一小时。</p>
<p>另一种破坏占有和等待条件的方案是，要求当一个进程请求资源时，先暂时释放当前占有的所有资源，然后再尝试一次获取所需的全部资源。</p>
<h1 id="3-破坏不可抢占条件"><a href="#3-破坏不可抢占条件" class="headerlink" title="3. 破坏不可抢占条件"></a>3. 破坏不可抢占条件</h1><p>假设一个进程已经分配到一台打印机，且正在进行打印输出，如果由于它需要的绘图仪无法获得而强制性把它占有的打印机抢占掉，就会引起一片混乱。但是，一些资源可以通过虚拟化的方式来避免发生这样的情况。</p>
<p>假脱机打印机向磁盘输出，并且只允许打印机守护进程访问真正的物理打印机，这种方式可以消除涉及打印机的死锁，然而却可能带来由磁盘空间导致的死锁。但是对于大容量磁盘，要消耗完所有的磁盘空间一般是不可能的。</p>
<p>但是，并不是所有的资源都可以进行类似的虚拟化。例如，数据库中的记录或者操作系统中的表都必须被锁定，因此存在出现死锁的可能。</p>
<h1 id="4-破坏环路等待条件"><a href="#4-破坏环路等待条件" class="headerlink" title="4. 破坏环路等待条件"></a>4. 破坏环路等待条件</h1><p>消除环路等待有几种方法。一种是保证每一个进程在任何时刻只能占用一个资源，如果要请求另外一个资源，它必须先释放第一个资源。</p>
<p>另一种是将所有资源统一编号，如图。现在的规则是：进程可以在任何时刻提出资源请求，但是所有请求必须按照资源编号顺序（升序）提出。进程可以先请求打印机后请求磁带机，但不可以先请求绘图仪再请求打印机。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211224065357041.png" alt="image-20211224065357041"></p>
<p>若按此规则，资源分配图中肯定不会出现环。右图所示，只有在A请求资源j且B请求i的情况下会产生死锁。假设i和j是不同资源，它们会具有不同编号。若i&gt;j，那么A不允许请求j，因为这个编号小于A已有资源的编号；反之，则B不允许请求i。不论哪种情况都不可能产生死锁。</p>
<p>对于多于两个进程的情况，同样的逻辑依然成立。<strong>在任何时刻，总有一个已分配的资源是编号最高的</strong>。占用该资源的进程不可能请求其它已分配的各种资源。它或者会执行完毕，或者最坏的情形是去请求编号更高的资源，而编号更高的资源肯定是可用的。最终，它会结束并释放所有资源，这是其它占有最高编号资源的进程也可以执行完。简言之，存在一种所有进程都可以执行完毕的场景，所以不会产生死锁。</p>
<p>该算法的一个变种是摈弃必须按升序请求资源的限制，而仅仅要求不允许进程请求比当前所独占资源编号低的资源。</p>
<p>尽管对资源编号的方法消除了死锁的问题，但几乎找不出一种使每个人都满意的编号次序。当资源包括进程表项、假脱机磁盘空间、加锁的数据库记录及其它抽象资源时，潜在的资源及各种不同用途的数目会变得很大，以至于使编号根本无法使用。</p>
<h1 id="5-死锁预防总结"><a href="#5-死锁预防总结" class="headerlink" title="5. 死锁预防总结"></a>5. 死锁预防总结</h1><table>
<thead>
<tr>
<th>条件</th>
<th>处理方式</th>
</tr>
</thead>
<tbody><tr>
<td>互斥</td>
<td>一切都是用假脱机技术</td>
</tr>
<tr>
<td>占有和等待</td>
<td>在开始就请求全部资源</td>
</tr>
<tr>
<td>不可抢占</td>
<td>抢占资源</td>
</tr>
<tr>
<td>环路等待</td>
<td>对资源按序编号</td>
</tr>
</tbody></table>
<h1 id="6-和死锁相关的问题"><a href="#6-和死锁相关的问题" class="headerlink" title="6. 和死锁相关的问题"></a>6. 和死锁相关的问题</h1><h2 id="6-1-两阶段加锁"><a href="#6-1-两阶段加锁" class="headerlink" title="6.1 两阶段加锁"></a>6.1 两阶段加锁</h2><p>虽然在一般情况下避免死锁和预防死锁并不是很有希望，但是在一些特殊的应用方面，有很多卓越的专用算法。例如，在很多数据库系统中，一个经常发生的操作是请求锁住一些记录，然后更新所有锁住的记录。当同时有多个进程运行时，就会有死锁的危险。</p>
<p>常用的方法是两阶段加锁。在第一阶段，进程试图对所有所需的记录进行加锁，一次锁一个记录。如果第一阶段加锁成功，就开始第二阶段，完成更新然后释放锁。在第一阶段并没有做实际的工作。</p>
<h2 id="6-2-通信死锁"><a href="#6-2-通信死锁" class="headerlink" title="6.2 通信死锁"></a>6.2 通信死锁</h2><h2 id="6-3-活锁"><a href="#6-3-活锁" class="headerlink" title="6.3 活锁"></a>6.3 活锁</h2><h2 id="6-4-饥饿"><a href="#6-4-饥饿" class="headerlink" title="6.4 饥饿"></a>6.4 饥饿</h2><p>与死锁和活锁非常相似的一个问题是饥饿（starvation）。在动态运行的系统中，在任何时刻都可能请求资源。这就需要一些策略来决定在什么时候谁获得什么资源。虽然这个策略表面上很有道理，但依然有可能使一些进程永远得不到服务，虽然它们并不是死锁进程。</p>
<p>饥饿可以通过先来先服务资源分配策略来避免。在这种机制下，等待最久的进程会是下一个被调度的进程。随着时间的推移，所有进程都会变成最“老”的，因而，最终能够获得资源而完成。</p>
<h1 id="7-死锁小结"><a href="#7-死锁小结" class="headerlink" title="7. 死锁小结"></a>7. 死锁小结</h1><p>死锁是任何OS的潜在问题。在一组进程中，每个进程都因等待由该组进程中的另一进程所占有的资源而导致阻塞，死锁就发生了。这种情况会使所有的进程都处于无限等待的状态。一般来讲，这是进程一直等待被其他进程占用的某些资源释放的事件。死锁的另外一种可能的情况是一组通信进程都在等待一个消息，而通信信道却是空的，并且也没有采用超时机制。</p>
<p>通过跟踪哪一个状态是安全状态，哪一个状态是不安全状态，可以避免死锁。安全状态就是这样一个状态：存在一个事件序列，保证所有的进程都能完成。不安全状态就不存在这样的保证。银行家算法可以通过拒绝可能引起不安全状态的请求来避免死锁。</p>
<p>也可以在设计系统时就不允许死锁发生，从而在系统结构上预防死锁的发生。例如，只允许进程在任何时刻最多占有一个资源，这就破坏了循环等待环路。也可以将所有资源编号，规定进程按严格的升序请求资源，这样也能预防死锁。</p>
<p>资源死锁并不是唯一的一种死锁。尽管我们可以通过设置适当的超时机制来解决通信死锁，但它依然是某些系统中潜在的问题。</p>
<p>活锁和死锁的问题有些相似，那就是它也可以停止所有的转发进程，但是二者在技术上不同，由于活锁包含了一些实际上并没有锁住的进程，因此可以通过先来先服务的分配策略来避免饥饿。</p>
]]></content>
  </entry>
  <entry>
    <title>死锁避免（含银行家算法）</title>
    <url>/2021/12/23/%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D%EF%BC%88%E5%90%AB%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%EF%BC%89/</url>
    <content><![CDATA[<p>在大多数系统中，一个进程一次只能请求一个资源。系统必须能够判断分配资源是否安全，并且只能在保证安全的条件下分配资源。问题是：是否存在一种算法总能做出正确的选择从而避免死锁？</p>
<h1 id="1-资源轨迹图"><a href="#1-资源轨迹图" class="headerlink" title="1. 资源轨迹图"></a>1. 资源轨迹图</h1><p>避免死锁的主要算法是基于一个安全状态的概念。在描述算法前，我们先讨论有关安全的概念。通过图的方式，能更容易理解。虽然它不能被直接翻译成有用的算法，但它给出了一个解决问题的直观感受。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211223221557289.png" alt="image-20211223221557289"></p>
<p>如图，我们看到一个处理两个进程和两个资源（打印机和绘图仪）的模型。横轴表示进程A执行的指令，纵轴表示进程B执行的指令。进程A在m1处申请打印机，在m3处释放；在m2处申请绘图仪，在m4处释放。进程B在m5处申请绘图仪，在m7处释放；在m6处申请打印机，在m8处释放。</p>
<p>图中的每一个点都表示出两个进程的连接状态。初始点为p，没有执行任何指令，如果调度程序选中进程A先运行，那么在A执行一段指令后到达q，此时B没有执行任何指令。在q点，如果轨迹沿着垂直方向移动，表示调度程序选中B执行。</p>
<p>当进程A越过m1线时，它请求并获得打印机；当进程B到达t点时，它请求绘图仪。</p>
<p>图中蓝色部分表示两个进程都拥有打印机，红色部分表示两个进程都拥有绘图仪，而互斥使用的规则决定了不可能进入这些区域。</p>
<p>如果系统一旦进入m1、m2、m5和m6组成的矩形区域，那么最后一定会到达m2和m6的交叉点，这是就产生死锁。在该点，A拥有打印机，请求绘图仪；B拥有绘图仪，请求打印机。整个紫色区域都是不安全的，因此绝不能进入这个区域。在点t处唯一的办法就是运行进程A直到m4，过了m4之后，可以按任何路线前进，直到终点u。</p>
<p>需要注意的是，在点t进程B请求资源。系统必须决定是否分配。如果系统把资源分配给B，系统进入不安全区域，最终形成死锁。要避免死锁，应该将B挂起，直到A请求并释放绘图仪。</p>
<h1 id="2-安全状态和不安全状态"><a href="#2-安全状态和不安全状态" class="headerlink" title="2. 安全状态和不安全状态"></a>2. 安全状态和不安全状态</h1><p>如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。我们看下面这张图：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211223224618571.png" alt="image-20211223224618571"></p>
<p>在图a中进程A拥有3个资源实例但最终可能会需要9个资源实例，进程B拥有2个资源实例但可能会需要4个资源实例，……总共有10个资源实例，还有3个是空闲的。图a的状态是安全的，考虑下面这个分配序列：先单独运行B，直到它请求并获得另外两个资源实例，从而达到图b的状态。当B完成后，就到了图c的状态。然后调度运行C，再到达图d的状态。当C完成后，到达了图e的状态，现在A可以获得它所需要的6个资源实例，并且完成。这样系统通过仔细的调度，就能够避免死锁，所以图a的状态是安全的。</p>
<p>现在假设初始状态如下图a所示，但这次A请求并得到一个资源，如下图b所示。我们还能找到一个序列来完成所有工作吗？如果调度程序运行B，直到B获取所需资源，如下图c所示。最终，进程B完成，状态如下图d所示，此时进入困境了，只有4个资源实例空闲，并且所有进程A和C都需要5个资源实例。任何分配资源实例的序列都无法保证工作的完成。于是，从下图的a到b的分配方案，从安全状态进入到了不安全状态。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211223225802876.png" alt="image-20211223225802876"></p>
<p>值得注意的是，不安全状态并不是死锁。从图b出发，系统能运行一段时间。实际上，甚至有一个进程能完成。而且，在A请求其它资源实例前，A可能先释放一个资源实例，这就可以让C先完成，从而避免了死锁。因而，<strong>安全状态和不安全状态的区别是：从安全状态出发，系统能够保证所有进程都能完成，而从不安全状态出发，就没有这样的保证。</strong></p>
<h1 id="3-单个资源的银行家算法"><a href="#3-单个资源的银行家算法" class="headerlink" title="3. 单个资源的银行家算法"></a>3. 单个资源的银行家算法</h1><p>Dijkstra提出了一种能够避免死锁的调度算法，称为<strong>银行家算法</strong>。该模型基于一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度。<strong>算法要做的是判断对请求的满足是否会导致进入不安全状态。</strong>如果是，就拒绝请求；否则就予以分配。在图a中我们可以看到4个客户A、B、C、D，每个客户都被授予一定数量的贷款单位，银行家知道不可能所有客户同时都需要最大贷款额，所以他只保留10个单位而不是22个单位的资金来为客户服务。这里将客户比作进程，贷款单位比作资源，银行家比作OS。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211223231131980.png" alt="image-20211223231131980"></p>
<p>客户们各自做自己的生意，在某些时刻需要贷款（相当于请求资源）。某一时刻，具体情况如图b所示。这个状态是安全的，由于保留着2个单位，银行家能够拖延除了C以外的其它请求。因而可以让C先完成，然后释放C所占的4个资源单位。有了这4个单位资源，银行家就可以给D或B分配所需的贷款单位，以此类推。</p>
<p>考虑假如向B提供了剩下的一个贷款单位，如图c所示，该状态是不安全的。如果忽然所有的客户都请求最大的限额，而银行家无法满足其中任何一个的要求，那么就会产生死锁。不安全状态并不一定引起死锁，由于客户不一定需要其最大贷款额度，但银行家不敢抱这样的侥幸心理。</p>
<p>银行家算法就是对每一个请求进行检查，检查如果满足这一请求是否会达到安全状态。若是，那么满足该请求；否则，就推迟对这一请求的满足。为了检查状态是否安全，银行家需要考虑他是否有足够的资源满足某一个客户。如果可以，那么这笔贷款就是能够收回的，并且接着检查最接近最大限额的一个客户，以此类推。如果所有投资最终都能被收回，那么该状态是安全的，最初的请求可以批准。</p>
<h1 id="4-多个资源的银行家算法"><a href="#4-多个资源的银行家算法" class="headerlink" title="4. 多个资源的银行家算法"></a>4. 多个资源的银行家算法</h1><p>可以把银行家算法进行推广以处理多个资源。如图（状态是安全的）：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211223232843534.png" alt="image-20211223232843534"></p>
<p>图中的三个向量分别表示现有资源E、已分配资源P和可用资源A。由E可知系统中共有6台磁带机、3台绘图仪、4台打印机和2台蓝光光驱，其它同理类推。</p>
<p>检查一个状态是否安全的算法如下：</p>
<ol>
<li>查找右边矩阵中是否有一行，其没有被满足的资源数均小于或等于A。如果不存在这样的行，那么系统将会产生死锁，因为任何进程都无法运行结束。（假设进程会一直占有资源直到它们终止为止）</li>
<li>如果找到这样一行，那么可以假设它获得所需的资源并运行结束，将该进程标记为终止，并将其资源加到向量A。</li>
<li>重复以上两步，或者直到所有的进程都标记为终止，其初始状态是安全的；或者所有进程的资源需求都得不到满足，此时就是发生了死锁。</li>
</ol>
<p>如果在第一步有若干进程均符合条件，那么不管挑选那一个运行都没有关系，因为可用资源或者会增多，至少会保持不变。</p>
<p>银行家算法最早由Dijkstra于1965年发表。从那以后几乎每本OS的专著都有详细地描述它，很多论文的内容也围绕着该算法讨论了它的不同方面。但很少有作者指出该算法虽然很有意义但缺乏实用价值。因为很少有进程能够在运行前就知道其所需资源的最大值。而且进程数也不是固定的，往往在不断变化，况且原本可用的资源也可能突然变成不可用。因此，在实际中，如果有，也只有极少的系统使用银行家算法来避免死锁。然而，一些系统可以使用诸如银行家算法之类的启发式方法类避免死锁。例如，当缓冲区利用率达到70%以上时，网络会实现自动节流，此时网络预计剩余的30%就足够用户完成服务并返回资源。</p>
<h2 id="4-1-数据结构描述"><a href="#4-1-数据结构描述" class="headerlink" title="4.1 数据结构描述"></a>4.1 数据结构描述</h2><ul>
<li><p>可利用资源向量Available：</p>
<p>含有m个元素的数组，其中每个元素代表一类可用的资源数目。Available[j] = k表示系统中现有Rj类资源k个。</p>
</li>
<li><p>最大需求矩阵Max：</p>
<p>n×m矩阵，定义系统中n个进程中的每个进程对m类资源的最大需求。</p>
</li>
<li><p>分配矩阵Allocation：</p>
<p>n×m矩阵，定义系统中每类资源当前已分配给每个进程的资源数。</p>
</li>
<li><p>需求矩阵Need：</p>
<p>n×m矩阵，表示每个进程接下来最多还需要多少资源。</p>
</li>
</ul>
<p>上述三个矩阵间存在下述关系：Need = Max - Allocation。一般情况下，在银行家算法的题目中，Max和Allocation矩阵是已知条件，而求出Need矩阵是解题的第一步。</p>
<h2 id="4-2-安全性算法"><a href="#4-2-安全性算法" class="headerlink" title="4.2 安全性算法"></a>4.2 安全性算法</h2><p>设置工作向量Work，有m个元素，表示系统中剩余可用资源数目。在执行安全性算法开始时，Work = Available。</p>
<ol>
<li>初始时安全序列为空。</li>
<li>从Need矩阵中找出符号下面条件的行：该行对应的进程不在安全序列中，而且该行小于等于Work向量，找到后，把对应的进程加入安全序列；若找不到，执行步骤④。</li>
<li>进程Pi进入安全序列后，可顺利执行，直至完成，并释放分配给它的资源，因此应执行Work = Work + Allocation[i]，返回步骤②。</li>
<li>若此时安全序列中已有所有进程，则系统处于安全状态，否则处于不安全状态。</li>
</ol>
<h1 id="5-银行家算法举例"><a href="#5-银行家算法举例" class="headerlink" title="5. 银行家算法举例"></a>5. 银行家算法举例</h1><p>在银行家算法的题目中，一般会有某个进程的一个资源请求向量，我们只要执行上面所介绍的银行家算法的三步，马上就会得到更新的Allcation矩阵和Need矩阵，再进行安全状态的判断，就能知道系统能否满足进程提出的资源请求。</p>
<p>假设当前系统中资源的分配和剩余情况如表所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211224000223816.png" alt="image-20211224000223816"></p>
<p>从表中我们可以提取Max矩阵和Allocation矩阵，这两个矩阵相减得到Need矩阵：<br>$$<br>\begin{Bmatrix}<br>7 &amp; 5 &amp; 3\<br>3 &amp; 2 &amp; 2\<br>9 &amp; 0 &amp; 2\<br>2 &amp; 2 &amp; 2\<br>4 &amp; 3 &amp; 3<br>\end{Bmatrix}<br>-<br>\begin{Bmatrix}<br>0 &amp; 1 &amp; 0\<br>2 &amp; 0 &amp; 0\<br>3 &amp; 0 &amp; 2\<br>2 &amp; 1 &amp; 1\<br>0 &amp; 0 &amp; 2<br>\end{Bmatrix}<br>=<br>\begin{Bmatrix}<br>7 &amp; 4 &amp; 3\<br>1 &amp; 2 &amp; 2\<br>6 &amp; 0 &amp; 0\<br>0 &amp; 1 &amp; 1\<br>4 &amp; 3 &amp; 1<br>\end{Bmatrix}<br>$$<br>（1）P1请求资源：P1发出的请求向量Request1(1,0,2)，系统按银行家算法进行检查：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Request1(1,0,2) &lt;= Need1(1,2,2)</span><br><span class="line">Request1(1,0,2) &lt;= Available1(3,3,2)</span><br></pre></td></tr></table></figure>

<p>系统先假定可为P1分配资源，并修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Available = Available - Request1 = (2,3,0)</span><br><span class="line">Allocation1 = Allocation1 + Request1 = (3,0,2)</span><br><span class="line">Need1 = Need1 - Request1 = (0,2,0)</span><br></pre></td></tr></table></figure>

<p>由此形成的资源变化情况如上表中的圆括号所示。</p>
<p>令Work = Available = (2,3,0)，再利用安全性算法检查此时系统是否安全，如表所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211224115522411.png" alt="image-20211224115522411"></p>
<p>由所进行的安全性检查可知，可找到一个安全序列{P1,P3,P4,P2,P0}。因此，系统是安全的，可以立即将P1所申请的资源分配给它。分配后系统中的资源情况如表所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211224120132179.png" alt="image-20211224120132179"></p>
<p>（2）P4请求资源：P4发出请求向量Request4(3,3,0)，系统按银行家算法进行检查：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Request4(3,3,0) &lt;= Need4(4,3,1)</span><br><span class="line">Request4(3,3,0) &gt; Available4(2,3,0)</span><br></pre></td></tr></table></figure>

<p>因此让P4等待。</p>
<p>（3）P0请求资源：P0发出请求向量Request0(0,2,0),系统按银行家算法进行检查：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Request0(0,2,0) &lt;= Need0(7,4,3)</span><br><span class="line">Request0(0,2,0) &lt;= Available0(2,3,0)</span><br></pre></td></tr></table></figure>

<p>系统暂时先假定可以为P0分配资源，并修改相关数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Available= Available- Request0 = (2,1,0)</span><br><span class="line">Allocation0 = Allocation0 + Request0 = (0,3,0)</span><br><span class="line">Need0 = Need0 - Request0 = (7,2,3)</span><br></pre></td></tr></table></figure>

<p>结果如表所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211224120825960.png" alt="image-20211224120825960"></p>
<p>进行安全性检查，可用资源Available(2,1,0)已不能满足任何进程的需要，因此系统进入不安全状态，因此拒绝P0的请求，让P0等待，并将Available、Allocation0、Need0恢复为之前的值。</p>
]]></content>
  </entry>
  <entry>
    <title>URI &amp; URL &amp; URN</title>
    <url>/2021/12/22/URI-URL-URN/</url>
    <content><![CDATA[<p>与URI相比，我们更熟悉URL。URL正是使用Web浏览器等访问Web页面时需要输入的网页地址。比如，下图的<a href="https://atqingke.com就是一个url./">https://atqingke.com就是一个URL。</a></p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211222095055654.png" alt="image-20211222095055654"></p>
<h1 id="统一资源标识符"><a href="#统一资源标识符" class="headerlink" title="统一资源标识符"></a>统一资源标识符</h1><p>每个Web服务器资源都有一个名字，这样客户端就可以说明它们感兴趣的资源是什么了。服务器资源名被称为<strong>统一资源标识符</strong>（Uniform Resource Identifier，URI）。URI就像因特网上的邮政地址一样，在世界范围内唯一标识并定位信息资源。</p>
<p>这是在我的博客的Web服务器上的一个图片资源的URI：</p>
<p><a href="https://atqingke.com/usr/uploads/2021/12/4247011469.png">https://atqingke.com/usr/uploads/2021/12/4247011469.png</a></p>
<p>在RFC2396分别对URI的三个单词进行了如下定义：</p>
<ul>
<li><p>Uniform</p>
<p>规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。另外，加入新增的协议方案也更容易。</p>
</li>
<li><p>Resource</p>
<p>资源的定义是”可标识的任何东西“。不仅是文档文件，图像或服务等能够区别于其它类型的，全都可作为资源。另外，资源不仅可以是单一的，也可以是多数的集合体。</p>
</li>
<li><p>Identifier</p>
<p>表示可标识的对象。也称为标识符。</p>
</li>
</ul>
<p>综上所述，URI就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。</p>
<p>采用HTTP协议时，协议方案就是http。除此之外，还有ftp、mailto、telnet、file等。标准的URI协议方案有30种左右，由隶属于国际互联网资源管理的非营利社团ICANN的IANA管理颁布。</p>
<p>URI用字符串标识某一互联网资源，而URL表示资源的地点。可见URL是URI的子集。</p>
<h1 id="URI格式"><a href="#URI格式" class="headerlink" title="URI格式"></a>URI格式</h1><p>表示指定的URI，要使用涵盖全部必要信息的绝对URI、绝对URL以及相对URL。相对URL，是指从浏览器种基本URI处指定的URL，形如/image/logo.gif。</p>
<p>现在我们来看一下绝对URI的格式：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211222101211563.png" alt="image-20211222101211563"></p>
<p>使用http:或https:等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号。也可以使用data:或javascript:这类指定数据或脚本程序的方案名。</p>
<ul>
<li><p>登录信息（认证）</p>
<p>指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证）。此项是可选项。</p>
</li>
<li><p>服务器地址</p>
<p>使用绝对URI必须指定待访问的服务器地址。地址可以是类似atqingke.com这种DNS可解析的名称，或是192.168.1.1这类IPv4地址名，还可以是[0:0:0:0:0:0:0:1]这样用方括号括起来的IPv6地址名。</p>
</li>
<li><p>服务器端口号</p>
<p>指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。</p>
</li>
<li><p>带层次的文件路径</p>
<p>指定服务器上的文件路径来定位特指的资源。这与UNIX系统的文件目录结构类似。</p>
</li>
<li><p>查询字符串</p>
<p>针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。此项可选。</p>
</li>
<li><p>片段标识符</p>
<p>使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在RFC中并没有明确规定其使用方法。该项也是可选项。</p>
</li>
</ul>
<h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><p>统一资源定位符（URL）是资源标识符最常见的形式。URL描述了一台特定服务器上某资源的特定位置。它们可以明确说明如何从一个精确、固定的位置获取资源。</p>
<p>大部分URL都遵循一种标准格式，这种格式包含三个部分。</p>
<ul>
<li>第一部分称为方案，说明了访问资源所使用的协议类型。</li>
<li>第二部分给出了服务器的因特网地址。</li>
<li>其余部分指定了Web服务器上的某个资源。</li>
</ul>
<p>现在，几乎所有的URI都是URL。</p>
<h1 id="URN"><a href="#URN" class="headerlink" title="URN"></a>URN</h1><p>URI的第二种形式就是统一资源名（URN）。URN是作为特定内容的唯一名称使用的，与目前的资源所在地无关。使用这些与位置无关的URN，就可以将资源四处搬移。通过URN，还可以使用同一个名字通过多种网络访问协议来访问资源。</p>
<p>比如，不论因特网标准文档RFC 2141位于何处（甚至可以将其复制到多个地方），都可以用下列URN来命名它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">urn:ietf:rfc:2141</span><br></pre></td></tr></table></figure>

<p>URN仍然处于试验阶段，还未大范围使用，为了更有效工作，URN需要一个支撑架构来解析资源的位置。而此类结构的缺乏也延缓了其被采用的进度。</p>
]]></content>
  </entry>
  <entry>
    <title>meta标签</title>
    <url>/2021/12/20/meta%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<p>我们只需要在我们的<a href="https://atqingke.com/index.php/archives/122/">第一个网页</a>的基础上加一点东西，它就变成了我们的标准的HTML5网页：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文档声明，声明当前网页的版本 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- html的根标签（元素），网页中的所有内容都要写在根元素里面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- head是网页的头部，head中的内容不会在网页中直接出现，主要用来帮助浏览器或搜索引擎来解析网页 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- meta标签用来设置网页的元数据，这里meta用来设置网页的字符集，避免乱码问题 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- title中的内容会显示在浏览器的标题栏，搜索引擎会主要根据title中的内容来判断网页的主要内容 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>网页的标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- body是html的子元素，表示网页的主题，网页中所有的课件内容都应该写在body里面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 网页的一级标题 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>网页的大标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这里，我们详细解释一下这个meta标签。从它的文档解释中我们可以看到：这是一个用来表示元数据的标签。</p>
<p><img src="C:/Users/pengbin007/AppData/Roaming/Typora/typora-user-images/image-20211220144716530.png" alt="image-20211220144716530"></p>
<p>那么，什么是元数据呢？在<a href="https://baike.baidu.com/item/%E5%85%83%E6%95%B0%E6%8D%AE/1946090?fr=aladdin">百度百科</a>上给出的解释是“元数据是关于数据的<a href="https://baike.baidu.com/item/%E7%BB%84%E7%BB%87/10200">组织</a>、数据域及其关系的<a href="https://baike.baidu.com/item/%E4%BF%A1%E6%81%AF/111163">信息</a>，简言之，元数据就是关于数据的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE">数据</a>”。这样说，可能不太好理解，举个栗子：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211220145548852.png" alt="image-20211220145548852"></p>
<p>这是电脑上一个很普通的txt文件，我们可以看到这里有banner.txt的文件类型、打开方式、位置、大小…等等信息。而元数据指的就是方框中所圈出来的数据，因为它们是用来描述具体数据的。类似的，还有我们在淘宝上购买电脑的时候，可以查看它的内存大小、显存、硬盘等等，而这些就是元数据，用来描述电脑具体信息的数据。</p>
<p>回到我们的meta标签，它主要用于设置网页中的一些元数据，而这些元数据并不是给用户看的。在上面的标准网页中，我们看到有“&lt;meta charset=”utf-8”&gt;”，我们用charset来指定网页的字符集为utf-8。</p>
<p>我们还可以在meta标签里面用name指定数据的名称，用content指定数据的内容。</p>
<ul>
<li><p>author</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;pengbin&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>给出页面作者的姓名。</p>
</li>
<li><p>keywords</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;HTML5,前端,CSS3&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>表示网站的关键字，可以同时指定多个关键字，关键字之间用 , 隔开。</p>
</li>
<li><p>description</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;pengbin的网站&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>description用于指定网站的描述，网站的描述会显示在搜索引擎的搜索结果中。</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Web和HTTP</title>
    <url>/2021/12/19/Web%E5%92%8CHTTP/</url>
    <content><![CDATA[<p>Web是一个引起公众注意的因特网应用，它极大地改变了人们与工作环境内外交流的方式。它将因特网从只是很多数据网之一的地位提升为仅有的一个数据网。也许对大多数用户来说，最具吸引力的就是Web的<strong>按需</strong>操作。</p>
<h1 id="1-HTTP概况"><a href="#1-HTTP概况" class="headerlink" title="1. HTTP概况"></a>1. HTTP概况</h1><p>Web的应用层协议是<strong>超文本传输协议</strong>（HyperText Transfer Protocol，HTTP），它是Web的核心，在[RFC 1945]和[RFC 2616]中进行了定义。HTTP由两个程序实现：一个客户程序和一个服务器程序。客户程序和服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话。HTTP定义了这些报文的结构以及客户和服务器进行报文交换的方式。</p>
<p><strong>Web页面</strong>（也叫文档）是由对象组成的。一个<strong>对象</strong>只是一个文件，且它们可通过一个<strong>URL地址寻址</strong>。多数Web页面含有一个<strong>HTML基本组件</strong>以及几个引用对象。例如，如果一个Web页面包含HTML文本和5个JPEG图形，那么这个Web页面有6个对象。HTML基本文件通过对象的URL地址引用页面中的其它对象。<strong>每个URL地址由两部分组成：存放对象的服务器主机名和对象的路径名</strong>。因为Web浏览器实现了HTTP的客户端，所以在Web环境中我们经常交替使用“浏览器”和“客户”这两个术语。Web服务器实现了HTTP的服务器端，它用于存储Web对象，每个对象由URL寻址。</p>
<p>HTTP定义了<strong>Web客户向Web服务器请求Web页面的方式，以及服务器向客户传送Web页面的方式</strong>。它使用<strong>TCP作为它的支撑运输协议</strong>。HTTP客户首先发起一个与服务器的TCP连接。一旦连接建立，该浏览器和服务器进程就可以通过套接字接口访问TCP。在这个过程中，TCP为HTTP提供可靠数据传输服务。这意味着，一个客户进程发出的每个HTTP请求报文最终能完整地到达服务器；类似地，服务器进程发出的每一个HTTP响应报文最终能完整地到达客户。在这里，我们看到了分层体系结构最大的优点，即HTTP协议不用担心数据丢失，也不关注TCP从网络的数据丢失和乱序故障中恢复的细节。而这是TCP以及协议栈较低层协议的工作。</p>
<p>现在我们考虑一个现象：服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息。假如某个特定的客户在短短的几秒钟内两次请求同一个对象，服务器并不会因为刚刚为该客户提供了该对象就不再做反应，而是重新发送该对象，就像服务器已经完全忘记不久之前所做过的事一样。因为HTTP服务器并不保存关于客户的任何信息，所以我们说HTTP是一个<strong>无状态协议</strong>。</p>
<h1 id="2-非持续连接和持续连接"><a href="#2-非持续连接和持续连接" class="headerlink" title="2. 非持续连接和持续连接"></a>2. 非持续连接和持续连接</h1><p>所谓非持续连接和持续连接就是指每个请求/响应对在一个长时间内通信时，是经过一个单独的TCP连接发送，还是所有请求及其响应经相同的TCP连接发送。HTTP既能够使用非持续连接，也能够使用持续连接，默认使用持续连接。（对应的在下面对请求报文中的介绍有一个Connection：keep-alive首部行）</p>
<h2 id="2-1-采用非持续连接的HTTP"><a href="#2-1-采用非持续连接的HTTP" class="headerlink" title="2.1 采用非持续连接的HTTP"></a>2.1 采用非持续连接的HTTP</h2><p>假设页面含有一个HTML基本文件和10个JPEG图形，并且这11个对象位于同一台服务器上。该HTML文件的URL为：<a href="http://www.atqingke.com/someDepartment/home.index%E3%80%82">http://www.atqingke.com/someDepartment/home.index。</a></p>
<p>我们看看发生了什么情况：</p>
<ul>
<li>HTTP客户进程在端口号80发起一个到服务器<a href="http://www.atqingke.com的tcp连接,该端口号是http的默认端口.在客户和服务器上分别有一个套接字与该连接相关联./">www.atqingke.com的TCP连接，该端口号是HTTP的默认端口。在客户和服务器上分别有一个套接字与该连接相关联。</a></li>
<li>HTTP客户经它的套接字向该服务器发送一个HTTP请求报文。请求报文中包含了路径名/someDepartment/home.index。</li>
<li>HTTP服务器进程经它的套接字接收该请求报文，从其存储器中检索出对象<a href="http://www.atqingke.com/someDepartment/home.index%EF%BC%8C%E5%9C%A8%E4%B8%80%E4%B8%AAHTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E4%B8%AD%E5%B0%81%E8%A3%85%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%B9%B6%E9%80%9A%E8%BF%87%E5%85%B6%E5%A5%97%E6%8E%A5%E5%AD%97%E5%90%91%E5%AE%A2%E6%88%B7%E5%8F%91%E9%80%81%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E3%80%82">www.atqingke.com/someDepartment/home.index，在一个HTTP响应报文中封装对象，并通过其套接字向客户发送响应报文。</a></li>
<li>HTTP服务器进程通知TCP断开该TCP连接。</li>
<li>HTTP客户接收响应报文，TCP连接关闭。该报文指出封装的对象是一个HTML文件，客户从响应报文中提取出该文件并检查，得到对10个JPEG图形的引用。</li>
<li>对每个引用的JPEG图形对象重复前4个步骤。</li>
</ul>
<p>在上面的步骤中，每个TCP连接只传输一个请求报文和响应报文。因此，当用户请求该Web页面时，要产生11个TCP连接。</p>
<p>在上面的步骤中，并没有明确给出获得这10个JPEG图形对象是串行还是并行。事实上，用户能够配置现代浏览器以控制并行度。默认方式下大部分浏览器打开5~10个并行的TCP连接，而每条连接处理一个请求响应事务。</p>
<p>我们来简单估算一下从客户请求HTML基本文件起到客户收到整个文件所花费的时间。为此，我们给出<strong>往返时间（Round-Trip Time，RTT）</strong>的定义，该时间是指<strong>一个短分组从客户到服务器然后再返回客户所花费的时间</strong>。RTT包括分组传播时延、分组在中间路由器和交换机上的排队时延以及分组处理时延。现在考虑用户点击超链接会发生什么现象。如图所示，这引起浏览器在它和Web服务器之间发起一个TCP连接；这涉及一次”三次握手“过程，即客户向服务器发送一个小TCP报文段，服务器用一个小TCP报文段做出确认和响应，最后，客户向服务器返回确认。三次握手中前两个部分所耗费的时间占用了一个RTT。完成前两个部分后，客户结合三次握手的第三部分向该TCP连接发送一个HTTP请求报文。一旦该请求报文到达服务器，服务器就在该TCP连接上发送HTML文件。该HTTP请求/响应用用去了另一个RTT。因此，粗略地讲，总的响应时间就是两个RTT加上服务器传输HTML文件的时间。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211222005616390.png" alt="image-20211222005616390"></p>
<h2 id="2-2-采用持续连接的HTTP"><a href="#2-2-采用持续连接的HTTP" class="headerlink" title="2.2 采用持续连接的HTTP"></a>2.2 采用持续连接的HTTP</h2><p>非持续连接有一些缺点：</p>
<ul>
<li>必须为每一个请求的对象建立和维护一个全新的连接。对于每个这样的连接，在客户和服务器中都要分配TCP的缓冲区和保持TCP变量，这个Web服务器带来了严重的负担。</li>
<li>每个对象经受两倍RTT的交付时延，即一个RTT用于创建TCP，另一个RTT用于请求和接收一个对象。</li>
</ul>
<p>在采用持续连接的情况下，服务器在发送响应后保持该TCP连接打开。在相同的客户与服务器之间的后续请求和响应报文能够通过相同的连接进行传送。特别是，一个完整的Web页面可以用单个持续TCP连接进行传送，更有甚者，位于同一台服务器的多个Web页面在从该服务器发送给同一个客户时，可以在单个持续TCP连接上进行。可以一个接一个的发出对对象的这些请求，而不必等待对未决请求（流水线）的回答。一般来说，如果一条连接经过一定时间间隔仍未被使用，HTTP服务器就关闭该连接。</p>
<h1 id="3-HTTP报文格式"><a href="#3-HTTP报文格式" class="headerlink" title="3. HTTP报文格式"></a>3. HTTP报文格式</h1><p>HTTP规范【RFC 1945；RFC 2616】包含了对HTTP报文格式的定义。HTTP报文请求有两种：请求报文和响应报文。</p>
<h2 id="3-1-HTTP请求报文"><a href="#3-1-HTTP请求报文" class="headerlink" title="3.1 HTTP请求报文"></a>3.1 HTTP请求报文</h2><p>我们通过wireshark进行抓包得到一个HTTP的请求报文如下所示：（每行都有一个\r\n结束）</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211221221924118.png" alt="image-20211221221924118"></p>
<p>其中，请求行的方法字段可以取的值包括GET、POST、HEAD、PUT和DELETE。绝大部分的HTTP请求报文使用GET方法。</p>
<p>在首部行Host中，我们也许认为该首部行是不必要的，因为在该主机中已经有一条TCP连接存在了。但是，在后面的Web缓存的介绍中我们可以知道，该首部行提供的信息是Web代理高速缓存所要求的。Accept-language：首部行是HTTP中可用的众多内容协商首部之一。</p>
<p>我们再来看一个请求报文的通用格式：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211221223651918.png" alt="image-20211221223651918"></p>
<p>在这张图里我们可以看到，在首部行后面还有一个“实体体”（entity body）。使用GET方法时实体体为空，而使用POST方法时才使用该实体体。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211221224126555.png" alt="image-20211221224126555"></p>
<p>通过wireshark抓包可以看到，上图中的使用GET方法请求，空行后面没有实体体。而下图中的POST方法请求时，空行后面就是实体体。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211221224421953.png" alt="image-20211221224421953"></p>
<p>当用户提交表单时，HTTP客户常常使用POST方法，例如当用户向搜索引擎提供搜索关键词时。使用POST报文时，用户仍可以向服务器请求一个Web页面，但Web页面的特定内容依赖于用户在表单字段中输入的内容。如果方法字段的值为POST时，则实体体中包含的就是用户在表单字段中的输入值。</p>
<p>当然，HTML表单也经常使用GET方法，并在所请求的URL中包括输入的数据，如图：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211221224933910.png" alt="image-20211221224933910"></p>
<p>HEAD方法类似于GET方法。当服务器收到使用HEAD方法的请求时，将会用一个HTTP报文进行响应，但是并不返回请求对象。应用程序开发者常用HEAD方法进行调试跟踪。PUT方法常与Web发行工具联合使用，它允许用户上传对象到指定的Web服务器上指定的路径。PUT方法也被那些需要向Web服务器上传对象的应用程序使用。DELETE方法允许用户或者应用程序删除Web服务器上的对象。</p>
<h2 id="3-2-HTTP响应报文"><a href="#3-2-HTTP响应报文" class="headerlink" title="3.2 HTTP响应报文"></a>3.2 HTTP响应报文</h2><p>使用wireshark抓取的一条HTTP响应报文：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211221230250851.png" alt="image-20211221230250851"></p>
<p>再看一下响应报文的通用格式：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211221230632598.png" alt="image-20211221230632598"></p>
<p>在这里，我们补充说明一下状态码和它们对应的短语。状态码及其相应的短语指示了请求的结果。一些常见的状态码和相关的短语包括：</p>
<ul>
<li>200    OK：请求成功，信息在返回的响应报文中。</li>
<li>301    Moved Permanently：请求的对象已经被永久转移了，新的URL定义在响应报文的Location：首部行中。客户软件将自动获取新的URL。</li>
<li>400    Bad Request：一个通用差错代码，指示该请求不能被服务器理解。</li>
<li>404    Not Found：被请求的文档不在服务器上。</li>
<li>505    HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本。</li>
</ul>
<h1 id="4-用户与服务器的交互：cookie"><a href="#4-用户与服务器的交互：cookie" class="headerlink" title="4. 用户与服务器的交互：cookie"></a>4. 用户与服务器的交互：cookie</h1><p>前面提到了HTTP服务器是无状态的。而一个Web站点通常希望能够识别用户，可能是因为它希望把内容与用户身份联系起来。为此，HTTP使用了cookie。cookie在【RFC 6265】中定义，它允许站点对用户进行跟踪。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211223152406114.png" alt="image-20211223152406114"></p>
<p>如图，cookie技术有4个组件：</p>
<ol>
<li>在HTTP响应报文中的一个cookie首部行；</li>
<li>在HTTP请求报文中的一个cookie首部行；</li>
<li>在用户端系统中保留有一个cookie文件，并由用户的浏览器进行管理；</li>
<li>位于Web站点的一个后端数据库。</li>
</ol>
<p>我们通过这个图来看看cookie的工作过程。假设Lucy总是从家中PC使用Internet Explorer上网，她首次与taobao.com联系。我们假定过去她已经访问过bay站点。当请求报文到达该taobao Web服务器时，该Web站点将产生一个唯一识别码，并以此作为索引在它的后端数据库中产生一个表项。接下来taobao Web服务器用一个包含Set-cookie: 首部的HTTP响应报文对Lucy的浏览器进行响应，其中Set-cookie：首部含有该识别码。例如，该首部行可能是</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Set-cookie: 1633</span><br></pre></td></tr></table></figure>

<p>当Lucy的浏览器收到了该HTTP响应报文时，它会看到Set-cookie：首部。该浏览器在它管理的规定cookie文件中添加一行，该行包含服务器的主机名和在Set-cookie：首部中的识别码。值得注意的是该cookie文件已经有了用于bay的表项，因为Lucy过去访问过该站点。当Lucy继续浏览taobao网站时，每请求一个Web页面，其浏览器会从该cookie文件中获取她对这个网站的识别码，并放到HTTP请求报文中包括识别码的cookie首部行中。</p>
<h1 id="5-Web缓存"><a href="#5-Web缓存" class="headerlink" title="5. Web缓存"></a>5. Web缓存</h1><p>Web缓存器（Web cache）也叫代理服务器（proxy server），它是能够代表初始Web服务器来满足HTTP请求的网络实体。Web缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本。如图，可以配置用户的浏览器，使得用户的所有HTTP请求首先指向Web缓存器。一旦某浏览器被配置，每个对某对象的浏览器请求首先被定向到该Web缓存器。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211223150002667.png" alt="image-20211223150002667"></p>
<p>值得注意的是Web缓存器是服务器同时又是客户。当它接收浏览器的请求并发回响应时，它是一个服务器。当它项初始服务器发出请求并接收响应时，它是一个客户。</p>
<p>在因特网上部署Web缓存器有两个原因。首先，Web缓存器可以大大减少对客户请求的响应时间，特别是当客户与初始服务器之间的瓶颈带宽远低于客户与Web缓存器之间的瓶颈带宽时更是如此。其次，Web缓存器能够大大减少一个机构的接入链路到因特网的通信量。通过减少通信量，该机构就不必急于增加带宽，因此降低了费用。此外，Web缓存器能从整体上大大减低因特网上的Web流量，从而改善了所有应用的性能。</p>
<h1 id="6-条件GET方法"><a href="#6-条件GET方法" class="headerlink" title="6. 条件GET方法"></a>6. 条件GET方法</h1><p>尽管高速缓存能减少用户感受到的响应时间，但也引入了一个新的问题，即存放在缓存器中的对象副本可能并不是最新的。为此，HTTP协议有一种机制，允许缓存器证实它的对象是最新的。这种机制就是<strong>条件GET方法</strong>。如果：①请求报文使用GET方法；并且②请求报文中包含一个”If-Modified-Since:“首部行。那么，这个HTTP请求报文就是一个条件GET请求报文。</p>
<p>我们看一个例子。首先，一个proxy cache代表一个请求浏览器，向某Web服务器发送一个请求报文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /fruit/kiwi.git HTTP/1.1</span><br><span class="line">Host: www.exotiquecuisine.com</span><br></pre></td></tr></table></figure>

<p>其次，该Web服务器向缓存器发送具有被请求的对象的响应报文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Sat, 8 Oct 2021 15:39:29</span><br><span class="line">Server: nginx</span><br><span class="line">Last-Modified: Wed, 7 Sep 2021 09:23:24</span><br><span class="line">Content-Type: image/gif</span><br><span class="line"></span><br><span class="line">(data data data data data data ......)</span><br></pre></td></tr></table></figure>

<p>该缓存器在将对象转发到请求的浏览器的同时，也在本地缓存了该对象。重要的是，缓存器在存储该对象时也存储了最后修改日期。一个星期后，另一个哟用户经过该缓存器请求同一个对象，该对象仍在这个缓存器中。由于在过去的一个星期中位于Web服务器上的该对象可能已经被修改了，该缓存器通过发送一个条件GET执行最新检查：</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line">GET /fruit/kiwi.git HTTP/<span class="number">1.1</span></span><br><span class="line">Host: www.exotiquecuisine.com</span><br><span class="line">If-Modified-Since: Wed, <span class="number">7</span> Sep <span class="number">2021</span> <span class="number">0</span>9:<span class="number">23</span>:<span class="number">24</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到：If-Modified-Since: 首部行的值正好等于一星期前服务器发送的响应报文中的Last-Modified: 首部行的值。该条件GET报文告诉服务器，仅当自指定日期之后该对象被修改过，才发送该对象。而如果没有被修改，Web服务器向该缓存器发送一个响应报文：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">304</span> Not Modified</span><br><span class="line">Date: Sat, <span class="number">15</span> Oct <span class="number">2021</span> <span class="number">15</span>:<span class="number">39</span>:<span class="number">29</span></span><br><span class="line">Server: nginx</span><br><span class="line"></span><br><span class="line">(empty entity body)</span><br></pre></td></tr></table></figure>

<p>我们看到，作为对该条件GET方法的响应，该Web服务器仍发送一个响应报文，但并没有在该响应报文中包含所请求的对象。包含该对象只会浪费带宽，并增加用户感受到的响应时间，特别是如果对象很大。最后的状态行中的304 Not Modified就告诉缓存器可以使用该对象，能向请求的浏览器转发proxy cache缓存的该对象副本。</p>
]]></content>
  </entry>
  <entry>
    <title>分组交换网中的时延、丢包和吞吐量</title>
    <url>/2021/12/19/%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E7%BD%91%E4%B8%AD%E7%9A%84%E6%97%B6%E5%BB%B6%E3%80%81%E4%B8%A2%E5%8C%85%E5%92%8C%E5%90%9E%E5%90%90%E9%87%8F/</url>
    <content><![CDATA[<p>在理想情况下，我们希望因特网服务能够在任意两个端系统之间瞬间移动我们想要的大量数据而没有任何数据丢失。然而，这是一个极高的目标，实践中难以达到。与之相反，计算机网络必定要限制在端系统之间的吞吐量，在端系统之间引入时延，而且实际上能够丢失分组。</p>
<h1 id="1-分组交换网中的时延概述"><a href="#1-分组交换网中的时延概述" class="headerlink" title="1. 分组交换网中的时延概述"></a>1. 分组交换网中的时延概述</h1><p>分组从一台主机出发，通过一系列路由器传输，在另一台主机中结束它的历程。当分组从一个结点沿着这条路径到后继结点，该分组在沿途的每个结点经受了几种不同类型的时延。这些时延最为重要的是<strong>结点处理时延（nodal processing delay）、排队时延（queuing delay）、传输时延（transmission delay）和传播时延（propagation delay）</strong>，这些时延总体累加起来就是<strong>结点总时延（total nodal delay）。</strong></p>
<h2 id="1-1-时延的类型"><a href="#1-1-时延的类型" class="headerlink" title="1.1 时延的类型"></a>1.1 时延的类型</h2><p>如图，作为源和目的地之间的端到端路径的一部分，一个分组从上游结点通过路由器A向路由器B发送。路由器A具有通往路由器B的出链路，该链路前面有一个队列（也称为缓存）。当该分组从上游结点到达路由器A时，路由器A检查该分组的首部以决定该分组的适当出链路，并将该分组导向该链路。</p>
]]></content>
  </entry>
  <entry>
    <title>SpringSecurity Web权限方案(上)</title>
    <url>/2021/12/18/SpringSecurity-Web%E6%9D%83%E9%99%90%E6%96%B9%E6%A1%88-%E4%B8%8A/</url>
    <content><![CDATA[<p>f</p>
<p>设置登录用户名和密码</p>
<p>方案一：application.properties</p>
<p>方案二：编写配置类</p>
<p>方案三：自定义编写实现类</p>
<p>基于角色或权限进行访问控制</p>
<p>hasAuthority方法</p>
<p>hasAnyAuthority方法</p>
<p>hasRole</p>
<p>hasAnyRole</p>
<p>注解使用</p>
]]></content>
  </entry>
  <entry>
    <title>SpringSecurity入门案例&amp;基本原理</title>
    <url>/2021/12/18/SpringSecurity%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>Spring Security is a framework that provides <a href="https://docs.spring.io/spring-security/reference/features/authentication/index.html">authentication</a>, <a href="https://docs.spring.io/spring-security/reference/features/authorization/index.html">authorization</a>, and <a href="https://docs.spring.io/spring-security/reference/features/exploits/index.html">protection against common attacks</a>. With first class support for securing both <a href="https://docs.spring.io/spring-security/reference/servlet/index.html">imperative</a> and <a href="https://docs.spring.io/spring-security/reference/reactive/index.html">reactive</a> applications, it is the de-facto standard for securing Spring-based applications.</p>
</blockquote>
<p>Spring是非常流行和成功的Java应用开发框架，Spring Security正是Spring家族的成员。Spring Security基于Spring框架，提供了一套Web应用安全性的完整解决方案。</p>
<p>一般来说，Web应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分，这两点也是Spring Security的重要核心功能。</p>
<blockquote>
<ol>
<li>用户认证指的是：验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。通俗点说就是<strong>系统认为用户是否能登录。</strong></li>
<li>用户授权指的是：验证某个用户是否具有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。通俗点讲就是<strong>系统判断用户是否有权限去做某些事情。</strong></li>
</ol>
</blockquote>
<p>Spring Security特点：</p>
<ul>
<li>和Spring无缝整合。</li>
<li>全面的权限控制。</li>
<li>专门为Web开发而设计。<ul>
<li>旧版本不能脱离Web环境使用。</li>
<li>新版本对整个框架进行了分层抽取，分成了核心模块和Web模块。单独引入核心模块就可以脱离Web环境。</li>
</ul>
</li>
<li>重量级。</li>
</ul>
<h1 id="1-Spring-Security入门案例"><a href="#1-Spring-Security入门案例" class="headerlink" title="1. Spring Security入门案例"></a>1. Spring Security入门案例</h1><h2 id="1-1-创建Spring-Boot项目"><a href="#1-1-创建Spring-Boot项目" class="headerlink" title="1.1  创建Spring Boot项目"></a>1.1  创建Spring Boot项目</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atqingke<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>securitydemo1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>securitydemo1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2-修改启动端口号"><a href="#1-2-修改启动端口号" class="headerlink" title="1.2 修改启动端口号"></a>1.2 修改启动端口号</h2><p>application.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8111</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-新建Controller"><a href="#1-3-新建Controller" class="headerlink" title="1.3 新建Controller"></a>1.3 新建Controller</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke.securitydemo1.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/18 15:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello security!!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-启动项目"><a href="#1-4-启动项目" class="headerlink" title="1.4 启动项目"></a>1.4 启动项目</h2><p>访问<a href="http://localhost:8111/test/hello%EF%BC%8C%E5%87%BA%E7%8E%B0%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA%E9%A1%B5%E9%9D%A2%EF%BC%9A">http://localhost:8111/test/hello，出现下图所示页面：</a></p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211218164137833.png" alt="image-20211218164137833"></p>
<p>现在我们只能使用它提供的默认用户名user登录，密码在项目启动的时候在控制台有打印，注意每次启动的时候密码都会发生变化！</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211218164333749.png" alt="image-20211218164333749"></p>
<p>登录成功！</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211218164439841.png" alt="image-20211218164439841"></p>
<h1 id="2-Spring-Security基本原理"><a href="#2-Spring-Security基本原理" class="headerlink" title="2. Spring Security基本原理"></a>2. Spring Security基本原理</h1><p>Spring Security本质上就是一个过滤器链：</p>
]]></content>
  </entry>
  <entry>
    <title>服务器性能剖析(上)</title>
    <url>/2021/12/18/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90-%E4%B8%8A/</url>
    <content><![CDATA[<h1 id="1-性能优化简介"><a href="#1-性能优化简介" class="headerlink" title="1. 性能优化简介"></a>1. 性能优化简介</h1>]]></content>
  </entry>
  <entry>
    <title>MySQL的存储引擎</title>
    <url>/2021/12/18/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<p>g</p>
<p>在这里我们只是概要地描述MySQL的存储引擎，而不会设计太多细节。</p>
<p>在文件系统中，MySQL将每个数据库（也可以称之为schema）保存为数据库目录下的一个子目录。创建表时，MySQL会在数据库子目录下创建一个和表同名的.frm文件保存表的定义。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211218124930511.png" alt="image-20211218124930511"></p>
<p>因为MySQL使用文件系统的目录和文件来保存数据库和表的定义，大小写敏感性和具体的平台密切相关。在Windows中，大小写是不敏感的；而在类Unix中则是敏感的。不同的存储引擎保存数据和索引的方式是不同的，但表的定义则是在MySQL服务层统一处理的。</p>
<p>可以使用show table status命令显示表的相关信息。例如，对于mysql数据库中的user表：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211218125959234.png" alt="image-20211218125959234"></p>
<p>输出的结果表明，这是一个MyISAM表。下面简单介绍一些每一行的含义：</p>
<blockquote>
<ul>
<li> Name: user</li>
<li>表名。</li>
<li>Engine: MyISAM<ul>
<li>表的存储引擎类型。在旧版本中，该列的名字叫Type，而不是Engine。</li>
</ul>
</li>
<li>Version: 10<ul>
<li>官方解释“The version number of the table’s .frm file.”。推测是mysql表结构的版本号，作用么就是跟踪表结构的历程，如在replication时，如果表结构的版本不一致，就不应该进行replication.自己可以测试一下，alter一下表结构，在show 一下看看version应该变化了，应该是mysql内部机制使用，对用户来说是透明的。</li>
</ul>
</li>
<li>Row_format: Dynamic<ul>
<li>行的格式。对于MyISAM表，可选的值为Dynamic、Fixed或者Compressed。Dynamic的行长度是可变的，一般包含可变长度的字段，如VARCHAR或BLOB。Fixed的行长度则是固定的，只包含固定长度的列，如CHAR和INTEGER。Compressed的行则只在压缩表中存在。</li>
</ul>
</li>
<li>Rows: 4<ul>
<li>表中的行数。对于MyISAM和其它一些存储引擎，该值是精确的，但对于InnoDB，该值是估计值。</li>
</ul>
</li>
<li>Avg_row_length: 129<ul>
<li>平均每行包含的字节数。</li>
</ul>
</li>
<li>Data_length: 516<ul>
<li>表数据的大小（以字节为单位）。</li>
</ul>
</li>
<li>Max_data_length: 281474976710655<ul>
<li>表数据的最大容量，该值和存储引擎有关。</li>
</ul>
</li>
<li>Index_length: 4096<ul>
<li>索引的大小（以字节为单位）。</li>
</ul>
</li>
<li>Data_free: 0<ul>
<li>对于MyISAM表，表示已分配但目前没有使用的空间。这部分空间包括了之前删除的行，以及后续可以被INSERT利用到的空间。</li>
</ul>
</li>
<li>Auto_increment: NULL<ul>
<li>下一个AUTO_INCREMENT的值。</li>
</ul>
</li>
<li>Create_time: 2021-04-25 17:12:01<ul>
<li>表的创建时间。</li>
</ul>
</li>
<li> Update_time: 2021-12-10 23:14:07</li>
<li>表数据的最后修改时间。</li>
<li>Check_time: NULL<ul>
<li>使用CHECK TABLE命令或者myisamchk工具最后一次检查表的时间。</li>
</ul>
</li>
<li>Collation: utf8_bin<ul>
<li>表的默认字符集和字符列排序规则。</li>
</ul>
</li>
<li>Checksum: NULL<ul>
<li>如果启用，保存的是整个表的实时校验和。</li>
</ul>
</li>
<li>Create_options:<ul>
<li>创建表时指定的其它选项。</li>
</ul>
</li>
<li>Comment: Users and global privileges<ul>
<li>该列包含了一些其它的额外信息。对于MyISAM表，保存的是表在创建时带的注释。对于InnoDB表，则保存的是InnoDB表空间的剩余空间信息。如果是一个视图，则该列包含“VIEW”的文本字样。</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="1-InnoDB存储引擎"><a href="#1-InnoDB存储引擎" class="headerlink" title="1. InnoDB存储引擎"></a>1. InnoDB存储引擎</h1><p>InnoDB是MySQL的默认事务型引擎，也是最重要、使用最广泛的存储引擎。它被设计用来处理大量的短期事务，短期事务大部分情况是正常提交的，很少会被回滚。InnoDB的性能和自动崩溃恢复特性，使得它在非事务型存储的需求中也很流行。除非有非常特别的原因需要使用其它存储引擎，否则应该优先考虑InnoDB引擎。</p>
<h2 id="InnoDB历史"><a href="#InnoDB历史" class="headerlink" title="InnoDB历史"></a>InnoDB历史</h2>]]></content>
  </entry>
  <entry>
    <title>MySQL架构与历史(上)</title>
    <url>/2021/12/17/MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%8E%86%E5%8F%B2-%E4%B8%8A/</url>
    <content><![CDATA[<p>和其它数据库系统相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥好的作用，但同时也会带来一点选择上的困难。</p>
<h1 id="1-MySQL逻辑架构"><a href="#1-MySQL逻辑架构" class="headerlink" title="1. MySQL逻辑架构"></a>1. MySQL逻辑架构</h1><p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211217211444051.png" alt="image-20211217211444051"></p>
<p>如图展示了MySQL的逻辑架构图，最上层的服务并不是MySQL独有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。比如连接处理、授权认证、安全等等。</p>
<p>第二层架构是大多数MySQL的核心服务功能所在地方，包括查询解析、分析、优化、缓存以及所有的内置函数，所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。</p>
<p>第三层包含了存储引擎。存储引擎负责MySQL中数据的存储和提取。和GNU/Linux下的各种文件系统一样，每个存储引擎都有它的优劣势。服务器通过API与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。存储引擎API包含几十个底层函数，用于执行诸如“开始一个事务”或者“根据主键提取一行记录”等操作。但存储引擎不会去解析SQL（InnoDB是例外，它会解析外键定义，因为MySQL服务器本身没有实现该功能），不同存储引擎之间也不会相互通信，而只是简单地响应上层服务器的请求。</p>
<h2 id="1-1-连接管理与安全性"><a href="#1-1-连接管理与安全性" class="headerlink" title="1.1.连接管理与安全性"></a>1.1.连接管理与安全性</h2><p>每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或者CPU中运行。服务器会负责缓存线程，因此不需要为每一个新建的连接创建或者销毁线程。</p>
<p>当客户短端连接到MySQL服务器时，服务器需要对其进行认证。认证基于用户名、原始主机信息和密码。如果使用了安全套接字（SSL）的方式连接，还可以使用X.509证书认证。一旦客户端连接成功，服务器会继续验证该客户端是否具有执行某个特定查询的权限。</p>
<h2 id="1-2-优化和执行"><a href="#1-2-优化和执行" class="headerlink" title="1.2 优化和执行"></a>1.2 优化和执行</h2><p>MySQL会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化。用户可以通过特殊的关键字提示优化器，影响它的决策过程。也可以请求优化器解释优化过程的各个因素，使用户知道服务器是如何进行优化决策的，并提供一个参考基准，便于用户重构查询和schema、修改相关配置，使应用尽可能高效运行。</p>
<p>优化器并不关心表使用的存储引擎，但存储引擎会影响优化查询。优化器会请求存储引擎提供容量或某个具体操作的开销信息，以及表数据的统计信息等。</p>
<p>对于SELECT语句，在解析查询之前，服务器会先检查查询缓存，如果能够在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行的整个过程，而是直接返回缓存中的结果集。</p>
<h1 id="2-并发控制"><a href="#2-并发控制" class="headerlink" title="2. 并发控制"></a>2. 并发控制</h1><p>无论何时，只要有多个查询需要在同一时刻修改数据，都会产生并发控制的问题。</p>
<h2 id="2-1-读写锁"><a href="#2-1-读写锁" class="headerlink" title="2.1 读写锁"></a>2.1 读写锁</h2><p>在处理并发读或者写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁通常被称为<strong>共享锁（shared lock）和排他锁（exclusive lock），也叫读锁（read lock）和写锁（write lock）</strong>。</p>
<p>读锁是共享的，或者说是相互不阻塞的。多个客户在同一时刻可以同时读取同一个资源，而互不干扰。写锁则是排他的，也就是说一个写锁会阻塞其它的写锁和读锁，这是处于安全策略的考虑，只有这样，才能确保在给定的时间里，只有一个用户能执行写入，并防止其它用户读取正在写入的同一资源。</p>
<p>在实际的数据库系统中，每时每刻都在发生锁定，当某个用户在修改某一部分数据时，MySQL会通过锁定防止其它用户读取同一数据。大多数时候，MySQL锁的内部管理都是透明的。</p>
<h2 id="2-2-锁粒度"><a href="#2-2-锁粒度" class="headerlink" title="2.2 锁粒度"></a>2.2 锁粒度</h2><p>一种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量只锁定需要修改的部分数据，而不是所有资源。更理想的方式是，只对会修改的数据片进行精确的锁定。任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程序越高，只要相互之间不发生冲突即可。</p>
<p>问题是加锁也需要消耗资源，如果系统花费大量的时间来管理锁，而不是存取数据，那么系统性能可能会因此受到影响。</p>
<p>所谓的锁策略，就是在锁的开销和数据的安全性之间寻求平衡，这种平衡当然也会影响性能。大多数商业数据库系统没有提供更多的选择，一般都是在表上施加行级锁（row-level lock）并以各种复杂的方式来实现，以便在锁比较多的情况下尽可能提供更好的性能。</p>
<p>而MySQL则提供了多种选择。每种MySQL存储引擎都可以实现自己的锁策略和锁粒度。</p>
<h3 id="表锁（table-lock）"><a href="#表锁（table-lock）" class="headerlink" title="表锁（table lock）"></a>表锁（table lock）</h3><p><strong>表锁是MySQL中最基本的锁策略，并且是开销最小的策略</strong>。它会锁定整个表，一个用户在对表进行写操作前，需要先获得锁，这回阻塞其它用户对该表的读写操作。而读锁之间是不相互阻塞的。写锁比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列的前面，但是读锁不能插到写锁前面。</p>
<p>尽管存储引擎可以管理自己的锁，MySQL本身还是会使用各种有效的表锁来实现不同的目的。</p>
<h3 id="行级锁（row-lock）"><a href="#行级锁（row-lock）" class="headerlink" title="行级锁（row lock）"></a>行级锁（row lock）</h3><p><strong>行级锁可以最大程度地支持并发处理</strong>（同时也带来了<strong>最大的锁开销</strong>）。行级锁只在存储引擎层实现，而MySQL服务器层没有实现。服务器层完全不了解存储引擎中的锁实现。</p>
<h1 id="3-事务"><a href="#3-事务" class="headerlink" title="3. 事务"></a>3. 事务</h1><p>事务就是一组原子性的SQL查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询；否则，所有语句都不会执行。也就是说，<strong>事务内的语句，要么全部执行成功，要么全部执行失败。</strong></p>
<p>银行应用是解释事务必要性的一个经典例子。假设一个银行的数据库有两张表：支票（checking）表和储蓄（savings）表。现在要从用户Jane的支票账户转移200美元到她的储蓄账户，那么至少需要三个步骤：</p>
<ol>
<li>检查支票账户的余额高于200美元。</li>
<li>从支票账户余额中减去200美元。</li>
<li>在储蓄账户余额中增加200美元。</li>
</ol>
<p>上述操作必须在一个事务中执行，任何一个步骤失败，都必须回滚所有步骤。</p>
<p>可以用 START TRANSACTION 语句开始一个事务，然后要么使用 COMMIT 提交事务将修改的数据持久保留，要么使用ROLLBACK撤销所有修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">SELECT balance FROM checking WHERE customer_id = 10233276;</span><br><span class="line">UPDATE checking SET balance =  balance - 200.00 WHERE customer_id = 10233276;</span><br><span class="line">UPDATE saving SET balance = balance + 200.00 WHERE customer_id = 10233276;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<p>除非系统通过严格的ACID测试，否则空谈事务的概念是不够的。ACID表示原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durability）。一个运行良好的事务处理系统，必须具备这些标准特征。</p>
<h3 id="原子性（atomicity）"><a href="#原子性（atomicity）" class="headerlink" title="原子性（atomicity）"></a>原子性（atomicity）</h3><p>一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚。不可能只执行其中的一部分操作。</p>
<h3 id="一致性（consistency）"><a href="#一致性（consistency）" class="headerlink" title="一致性（consistency）"></a>一致性（consistency）</h3><p>数据库总是从一个一致性的状态转换到另一个一致性的状态。在前面的例子中，一致性确保了，即使在执行第三、四条语句之前时系统崩溃，支票账户中也不会损失200美元，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。</p>
<h3 id="隔离性（isolation）"><a href="#隔离性（isolation）" class="headerlink" title="隔离性（isolation）"></a>隔离性（isolation）</h3><p>通常来说，一个事务所做的修改在最终提交以前，对其它事务是不可见的。在前面的例子中，当执行完第三条语句，第四条还未开始时，此时有另外一个账户汇款程序开始运行，则其看到的支票账户的余额并没有被减去200美元。</p>
<h3 id="持久性（durability）"><a href="#持久性（durability）" class="headerlink" title="持久性（durability）"></a>持久性（durability）</h3><p>一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。</p>
<h2 id="3-1-隔离级别"><a href="#3-1-隔离级别" class="headerlink" title="3.1 隔离级别"></a>3.1 隔离级别</h2><p>隔离性其实比想象得要复杂。在SQL标准中定义了四种隔离级别。</p>
<blockquote>
<p>提示：每种存储引擎实现得隔离级别不尽相同。</p>
</blockquote>
<h3 id="READ-UNCOMMITTED（未提交读）"><a href="#READ-UNCOMMITTED（未提交读）" class="headerlink" title="READ UNCOMMITTED（未提交读）"></a>READ UNCOMMITTED（未提交读）</h3><p>在READ UNCOMMITTED级别，事务中的修改，即使没有提交，对其它事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读（Dirty Read）。这个级别会导致很多问题，从性能上讲，READ UNCOMMITTED不会比其它的级别好太多，但却缺乏其它级别的很多好处，除非真的有非常必要的理由，在实际应用中一般很少使用。</p>
<h3 id="READ-COMMITTED（提交读）"><a href="#READ-COMMITTED（提交读）" class="headerlink" title="READ COMMITTED（提交读）"></a>READ COMMITTED（提交读）</h3><p>大多数数据库系统的默认隔离级别都是READ COMMITTED（但MySQL不是）。READ COMMITTED满足前面提到的隔离性的简单定义：一个事务开始时，只能“看见”已经提交的事务所做的修改。换句话说，一个事务从开始知道提交之前，所做的任何修改对其它事务都是不可见的。这个级别有时候也叫做<strong>不可重复读</strong>（nonrepeatable read），因为两次执行同样的查询，可能会得到不一样的结果。</p>
<h3 id="REPEATABLE-READ（可重复读）"><a href="#REPEATABLE-READ（可重复读）" class="headerlink" title="REPEATABLE READ（可重复读）"></a>REPEATABLE READ（可重复读）</h3><p>REPEATABLE READ解决了脏读的问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读（Phantom Read）的问题。所谓<strong>幻读，指的是当某个事务在读取某个范围的记录时，会产生幻行</strong>（Phantom Row）。InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC）解决了幻读的问题。</p>
<p>可重复读是MySQL的默认事务隔离级别。</p>
<h3 id="SERIALIZABLE（可串行化）"><a href="#SERIALIZABLE（可串行化）" class="headerlink" title="SERIALIZABLE（可串行化）"></a>SERIALIZABLE（可串行化）</h3><p>SERIALIZABLE是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读的问题，简单来说，SERIALIZABLE会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用问题。实际应用中也很少用到这个隔离级别，只有在非常需要确保数据的一致性并且可以接受没有并发的情况下，才考虑。</p>
<table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th align="center">脏读可能性</th>
<th align="center">不可重复读可能性</th>
<th align="center">幻读可能性</th>
<th align="center">加锁读</th>
</tr>
</thead>
<tbody><tr>
<td align="left">READ UNCOMMITTED</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="left">READ COMMITTED</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="left">REPEATABLE READ</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="left">SERIALIZABLE</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
</tbody></table>
<h2 id="3-2-死锁"><a href="#3-2-死锁" class="headerlink" title="3.2 死锁"></a>3.2 死锁</h2><p>死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。例如，设想下面两个事务同时处理StockPrice表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 事务1</span><br><span class="line">START TRANSACTION;</span><br><span class="line">UPDATE StockPrice SET `close` = 45.50 WHERE stock_id = 4 AND `date` = &#x27;2021-12-17&#x27;;</span><br><span class="line">UPDATE StockPrice SET `close` = 19.80 WHERE stock_id = 3 AND `date` = &#x27;2021-12-18&#x27;;</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line"># 事务2</span><br><span class="line">START TRANSACTION;</span><br><span class="line">UPDATE StockPrice SET high = 20.12 WHERE stock_id = 3 AND `date` = &#x27;2021-12-18&#x27;;</span><br><span class="line">UPDATE StockPrice SET high = 47.20 WHERE stock_id = 4 AND `date` = &#x27;2021-12-17&#x27;;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<p>如果凑巧，两个事务都执行了第一条UPDATE语句，更新了一行数据，同时也锁定了该行数据，接着每个事务都尝试去执行第二条UPDATE语句，却发现已经被对方锁定，然后两个事务都等待对方释放锁，同时又持有对方需要的锁，陷入死循环。</p>
<p>为了解决这种问题，数据库系统实现了各种死锁检测和死锁超时机制。锁的行为和顺序适合存储引擎相关的。以同样的顺序执行语句，有些存储引擎会产生死锁，有些不会。死锁的产生有双重原因：有些是因为真正的数据冲突，这种通常很难避免，但有些完全是由于存储引擎的实现方式导致的。</p>
<p>死锁发生以后，只有部分或者完全回滚其中一个事务，才能打破死锁。对于事务型的系统，这是无法避免的，所以应用程序在设计时必须考虑如何处理死锁。大多数情况下只需要重新执行因死锁回滚的事务即可。</p>
<h2 id="3-3-事务日志"><a href="#3-3-事务日志" class="headerlink" title="3.3 事务日志"></a>3.3 事务日志</h2><p>事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说快得多。事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现的，我们通常称之为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。</p>
<p>如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。</p>
<h2 id="3-4-MySQL中的事务"><a href="#3-4-MySQL中的事务" class="headerlink" title="3.4 MySQL中的事务"></a>3.4 MySQL中的事务</h2><p>MySQL提供了两种事务型的存储引擎：InnoDB和NDB Cluster。另外还有一些第三方存储引擎也支持事务，比较知名的包括XtraDB和PBXT。</p>
<h3 id="自动提交（AUTOCOMMIT）"><a href="#自动提交（AUTOCOMMIT）" class="headerlink" title="自动提交（AUTOCOMMIT）"></a>自动提交（AUTOCOMMIT）</h3><p>MySQL默认采用自动提交模式。也就是说，如果不是显式的开始一个事务，则每个查询都被当作一个事务执行提交操作。在当前连接中，可以通过设置 autocommit 变量来启用或禁用自动提交模式：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211217232445701.png" alt="image-20211217232445701"></p>
<p>1或者ON表示启用，0或者OFF表示禁用。当autocommit=0时，所有的查询都是在一个事务中，知道显式执行commit提交或者rollback回滚，该事务结束，同时又开始另一个新事务。修改autocommit对非事务型的表，比如MyISAM或者内存表，不会有任何影响。对这类表来说，没有commit或者rollback的概念，也可以说是相当于一直处于autocommit启用的模式。</p>
<p>MySQL可以通过执行 set transaction isolation level 命令来设置隔离级别。新的隔离级别会在下一个事务开始的时候生效：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211217233445478.png" alt="image-20211217233445478"></p>
<p>MySQL能够识别所有的4个ANSI隔离级别，InnoDB引擎也支持所有的隔离级别。</p>
<h3 id="在事务中混合使用存储引擎"><a href="#在事务中混合使用存储引擎" class="headerlink" title="在事务中混合使用存储引擎"></a>在事务中混合使用存储引擎</h3><p>MySQL服务器层部管理事务，事务是由下层的存储引擎实现的。所以在同一个事务中，使用多种存储引擎是不可靠的。</p>
<p>如果在事务中混合使用了事务型和非事务型的表，在正常提交的情况下不会有什么问题。</p>
<p>但如果该事务需要回滚，非事务型的表上的变更就无法撤销，这会导致数据库处于不一致的状态，这种情况很难修复，事务的最终结果将无法确定。所以，为每张表选择合适的存储引擎非常重要。</p>
<h3 id="隐式和显式锁定"><a href="#隐式和显式锁定" class="headerlink" title="隐式和显式锁定"></a>隐式和显式锁定</h3><p>InnoDB采用的是两阶段锁定协议（two-phase locking protocol）。在事务执行过程中，随时都可以执行锁定，锁只有在执行commit或者rollback的时候才会释放，并且所有锁是在同一时刻被释放。前面描述的锁定都是隐式锁定，InnoDB会根据隔离级别在需要的时候自动加锁。</p>
<p>另外，InnoDB也支持通过特定的语句进行显式锁定，这些语句不属于SQL规范：</p>
<ul>
<li>SELECT … LOCK IN SHARE MODE</li>
<li>SELECT … FOR UPDATE</li>
</ul>
<p>MySQL也支持LOCK TABLES和UNLOCK TABLES语句，这是在服务器层实现的，和存储引擎无关。它们有自己的用途，但并不能替代事务处理。如果应用需要用到事务，还是应该选择事务型存储引擎。</p>
<blockquote>
<p>警告：LOCK TABLES和事务之间相互影响的话，情况会变得非常复杂，在某些MySQL版本中甚至会产生无法预料的结果。因此，建议除了事务中禁用了autocommit，可以使用LOCK TABLES之外，其它任何时候都不要显式执行LOCK TABLES，不管使用什么存储引擎。</p>
</blockquote>
<h1 id="4-多版本并发控制"><a href="#4-多版本并发控制" class="headerlink" title="4. 多版本并发控制"></a>4. 多版本并发控制</h1><p>MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般都同时实现了多版本并发控制（MVCC，Multiversion Concurrency Control）。不仅是MySQL，包括Oracle、PostgreSQL等其它数据库系统也都实现了MVCC，但各自的实现机制不尽相同，因为MVCC没有一个统一的实现标准。</p>
<p>可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。</p>
<p>MVCC的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p>
<p>前面说到不同存储引擎的MVCC实现是不同的，典型的有乐观并发控制和悲观并发控制。下面通过InnoDB的简化版行为来说明MVCC是如何工作的。</p>
<p>InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。下面看一下在REPEATABLE READ隔离级别下，MVCC具体如何操作。</p>
<ul>
<li><p>SELECT</p>
<ul>
<li>InnoDB会根据以下两个条件检查每行记录：<ul>
<li>InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</li>
<li>行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。</li>
</ul>
</li>
</ul>
</li>
<li><p>INSERT</p>
<ul>
<li>InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</li>
</ul>
</li>
<li><p>DELETE</p>
<ul>
<li>InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</li>
</ul>
</li>
<li><p>UPDATE</p>
<ul>
<li>InnoDB为插入一行新纪录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</li>
</ul>
</li>
</ul>
<p>保存这两个额外系统版本号就，使大多数读操作可以不用加锁。使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。不足是每行记录都需要额外空间，需要做更多的行检查工作，以及一些额外的维护工作。</p>
<p>MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作。其它两个隔离级别都和MVCC不兼容，因为READ UNCOMMITTED总是读取最新的数据行，而不是符合当前事务版本的数据行。而SERIALIZABLE则会对所有读取的行都加锁。</p>
]]></content>
  </entry>
  <entry>
    <title>磁盘调度算法</title>
    <url>/2021/12/17/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>一次磁盘读写操作的时间由寻找（寻道）时间、旋转延迟时间和传输时间决定。</p>
<p>磁盘请求队列中的请求顺序分别为55，58，39，18，90，160，150，38，184，磁头的初始位置是磁道100。</p>
<h1 id="1-先来先服务（FCFS）算法"><a href="#1-先来先服务（FCFS）算法" class="headerlink" title="1. 先来先服务（FCFS）算法"></a>1. 先来先服务（FCFS）算法</h1><p>根据进程请求访问磁盘的先后顺序进行调度，采用FCFS算法时磁头的运动过程如图所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">18-&gt;90:</span><br><span class="line">38-&gt;184:终点</span><br><span class="line">39-&gt;18:</span><br><span class="line">55-&gt;58:</span><br><span class="line">58-&gt;39:</span><br><span class="line">90-&gt;160:</span><br><span class="line">100-&gt;55:起点</span><br><span class="line">150-&gt;38:</span><br><span class="line">160-&gt;150:</span><br></pre></td></tr></table></figure>

<p>磁头共移动了：45 + 3 + 19 + 21 + 72 +70 + 10 + 112 + 146 = 498个磁道，平均寻找长度：498 / 9 = 55.3。</p>
<h1 id="2-最短寻找时间优先（SSTF）算法"><a href="#2-最短寻找时间优先（SSTF）算法" class="headerlink" title="2. 最短寻找时间优先（SSTF）算法"></a>2. 最短寻找时间优先（SSTF）算法</h1><p>选择调度处理的磁道是与当前磁头所在磁道距离最近的磁道，以便使每次的寻找时间最短。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">18-&gt;150:</span><br><span class="line">38-&gt;18:</span><br><span class="line">39-&gt;38:</span><br><span class="line">55-&gt;39:</span><br><span class="line">58-&gt;55:</span><br><span class="line">90-&gt;58:</span><br><span class="line">100-&gt;90:起点</span><br><span class="line">150-&gt;160:</span><br><span class="line">160-&gt;184:终点</span><br></pre></td></tr></table></figure>

<p>磁头共移动了：10 + 32 + 3 + 16 + 1 + 20 + 132 + 10 + 24  = 248个磁道，平均寻找长度：248 / 9 = 27.5。</p>
<h1 id="3-扫描（SCAN）算法（又称电梯调度算法）"><a href="#3-扫描（SCAN）算法（又称电梯调度算法）" class="headerlink" title="3. 扫描（SCAN）算法（又称电梯调度算法）"></a>3. 扫描（SCAN）算法（又称电梯调度算法）</h1><p>在磁头当前移动方向上选择与当前磁头所在磁道距离最近的请求作为下一次服务的对象。实际上就是在SSTF的基础上规定了磁头运动的方向。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">38-&gt;18:终点</span><br><span class="line">39-&gt;38:</span><br><span class="line">55-&gt;39:</span><br><span class="line">58-&gt;55:</span><br><span class="line">90-&gt;58:</span><br><span class="line">100-&gt;150:起点</span><br><span class="line">150-&gt;160:</span><br><span class="line">160-&gt;184:</span><br><span class="line">184-&gt;200:</span><br><span class="line">200-&gt;90:</span><br></pre></td></tr></table></figure>

<p>磁头共移动了：50 + 10 + 24 + 16 + 110 + 32 + 3 + 16 + 1 + 20 = 282个磁道，平均寻道长度：282 / 9 = 31.33。</p>
<h1 id="4-循环扫描（C-SCAN）算法"><a href="#4-循环扫描（C-SCAN）算法" class="headerlink" title="4. 循环扫描（C-SCAN）算法"></a>4. 循环扫描（C-SCAN）算法</h1><p>在SCAN的基础上规定磁头单向移动来提供服务，回返时直接快速移动至起始端而不服务任何请求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0-&gt;18:</span><br><span class="line">18-&gt;38:</span><br><span class="line">38-&gt;39:</span><br><span class="line">39-&gt;55:</span><br><span class="line">55-&gt;58:</span><br><span class="line">58-&gt;90:终点</span><br><span class="line">100-&gt;150:起点</span><br><span class="line">150-&gt;160:</span><br><span class="line">160-&gt;184:</span><br><span class="line">184-&gt;200:</span><br><span class="line">200-&gt;0:</span><br></pre></td></tr></table></figure>

<p>磁头共移动了：50 + 10 + 24 + 16 + 200 + 18 + 20 + 1 + 16 + 3 + 32 = 390个磁道，平均寻道长度：390 / 9 = 43.3。</p>
<h2 id="4-1-LOOK调度和C-LOOK调度"><a href="#4-1-LOOK调度和C-LOOK调度" class="headerlink" title="4.1 LOOK调度和C-LOOK调度"></a>4.1 LOOK调度和C-LOOK调度</h2><p>采用SCAN算法和C-SCAN算法时，磁头总是严格地遵循从盘面的一端到另一端，显然，在实际使用时还可以改进，即磁头移动只需要到达最远端的一个请求即可返回，不需要到达磁盘端点。这种形式的SCAN算法和C-SCAN算法称为LOOK调度和C-LOOK调度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Title:LOOK调度</span><br><span class="line">38-&gt;18:终点</span><br><span class="line">39-&gt;38:</span><br><span class="line">55-&gt;39:</span><br><span class="line">58-&gt;55:</span><br><span class="line">90-&gt;58:</span><br><span class="line">100-&gt;150:起点</span><br><span class="line">150-&gt;160:</span><br><span class="line">160-&gt;184:</span><br><span class="line">184-&gt;90:</span><br></pre></td></tr></table></figure>

<p>磁头共移动了：50 + 10 + 24 + 94 + 32 + 3 + 16 + 1 + 20 = 250个磁道，平均寻道长度：250 / 9 = 27.8。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Title:C-LOOK调度</span><br><span class="line">18-&gt;38:</span><br><span class="line">38-&gt;39:</span><br><span class="line">39-&gt;55:</span><br><span class="line">55-&gt;58:</span><br><span class="line">58-&gt;90:终点</span><br><span class="line">100-&gt;150:起点</span><br><span class="line">150-&gt;160:</span><br><span class="line">160-&gt;184:</span><br><span class="line">184-&gt;18:</span><br></pre></td></tr></table></figure>

<p>磁头共移动了：50 + 10 + 24 + 166 + 32 + 3 + 16 + 1 + 20 = 416个磁道，平均寻道长度：416 / 9 = 46.2。</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>FCFS算法</td>
<td>公平、简单</td>
<td>平均寻道距离大，仅应用在磁盘I/O比较少的场合</td>
</tr>
<tr>
<td>SSTF算法</td>
<td>性能比FCFS好</td>
<td>不能保证平均寻道时间最短，可能出现“饥饿”现象</td>
</tr>
<tr>
<td>SCAN算法</td>
<td>寻道性能较好，可避免“饥饿”现象</td>
<td>不利于远离磁头一端的访问请求</td>
</tr>
<tr>
<td>C-SCAN算法</td>
<td>消除了对两端磁道请求的不公平</td>
<td>——</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>进程调度算法</title>
    <url>/2021/12/17/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>操作系统中存在许多种调度算法，有的调度算法适用于作业调度，有的调度算法适用于进程调度，有的两者皆适用。</p>
<h1 id="1-先来先服务（FCFS）调度算法"><a href="#1-先来先服务（FCFS）调度算法" class="headerlink" title="1. 先来先服务（FCFS）调度算法"></a>1. 先来先服务（FCFS）调度算法</h1><ul>
<li><p>算法思想</p>
<p>主要从“公平”的角度考虑（类似生活中排队买东西）。</p>
</li>
<li><p>算法规则</p>
<p>按照作业/进程到达的先后顺序进行服务。</p>
</li>
<li><p>用于作业/进程调度</p>
<p>用于作业调度时，考虑的是哪个作业先到达后备队列；</p>
<p>用于进程调度时，考虑的是哪个进程先到达就绪队列。</p>
</li>
<li><p>是否可抢占</p>
<p>非抢占式算法。</p>
</li>
<li><p>优缺点</p>
<ul>
<li>公平、算法实现简单。</li>
<li>排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即，<strong>FCFS算法对长作业有利，对短作业不利。</strong></li>
</ul>
</li>
<li><p>是否会导致饥饿</p>
<p>不会。</p>
</li>
</ul>
<h1 id="2-短作业优先（SJF）调度算法"><a href="#2-短作业优先（SJF）调度算法" class="headerlink" title="2. 短作业优先（SJF）调度算法"></a>2. 短作业优先（SJF）调度算法</h1><ul>
<li><p>算法思想</p>
<p>追求最少的平均等待时间，最少的平均周转时间、最少的平均带权周转时间。</p>
</li>
<li><p>算法规则</p>
<p>最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）。</p>
</li>
<li><p>用于作业/进程调度</p>
<p>既可用于作业调度，也可用于进程调度。用于进程调度时称为”短进程优先（SPF）“算法。</p>
</li>
<li><p>是否可抢占</p>
<p>SJF和SPF是<strong>非抢占式</strong>的算法。但是<strong>也有抢占式的版本——最短剩余时间优先算法</strong>（SRTN，Shortest Remaining Time Next）。</p>
</li>
<li><p>优缺点</p>
<ul>
<li>”最短的“平均等待时间、平均周转时间。</li>
<li>不公平。<strong>对短作业有利，对长作业不利</strong>。可能产生<strong>饥饿现象</strong>。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先。</li>
</ul>
</li>
<li><p>是否会导致饥饿</p>
<p>会，如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生”<strong>饥饿</strong>“现象，如果一直得不到服务，则称为”<strong>饿死</strong>“。</p>
</li>
</ul>
<h1 id="3-优先级调度算法"><a href="#3-优先级调度算法" class="headerlink" title="3. 优先级调度算法"></a>3. 优先级调度算法</h1><ul>
<li><p>算法思想</p>
<p>随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序。</p>
</li>
<li><p>算法规则</p>
<p>调度时选择优先级最高的作业/进程。</p>
</li>
<li><p>用于作业/进程调度</p>
<p>既可以用于作业调度，也可以用于进程调度。甚至，还会用于I/O调度中。</p>
</li>
<li><p>是否可抢占</p>
<p>抢占式、非抢占式都有。做题时的区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占。</p>
</li>
<li><p>优缺点</p>
<ul>
<li>用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活调整对各种作业/进程的偏好程度。</li>
<li>若源源不断有高优先级进程到来，则可能会导致饥饿。</li>
</ul>
</li>
<li><p>是否会导致饥饿<br>会</p>
</li>
<li><p>补充</p>
<ul>
<li>就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近对头的位置。</li>
<li>根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种：<ul>
<li>静态优先级：创建进程时确定，之后一直不变。</li>
<li>动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。</li>
</ul>
</li>
<li>如何合理地设置各类进程的优先级？<ul>
<li>通常：系统进程优先级高于用户进程，前台进程高于后台进程。</li>
<li>OS更偏好I/O型进程（或称I/O繁忙型进程）。</li>
<li>与I/O型进程相对的是计算型进程（或称CPU繁忙型进程）。</li>
</ul>
</li>
<li>如果采用的是动态优先级，什么时候应该调整？<ul>
<li>可以从追求公平、提升资源利用率等角度考虑。</li>
<li>如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级。</li>
<li>如果某进程占用处理机运行了很长时间，则可适当降低其优先级。</li>
<li>如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="4-高响应比优先调度算法"><a href="#4-高响应比优先调度算法" class="headerlink" title="4. 高响应比优先调度算法"></a>4. 高响应比优先调度算法</h1><ul>
<li><p>算法思想</p>
<p>要综合考虑作业/进程的等待时间和要求服务的时间。</p>
</li>
<li><p>算法规则</p>
<p>在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务。</p>
<ul>
<li>响应比 = (等待时间 + 要求服务时间) / 要求服务时间</li>
</ul>
</li>
<li><p>用于作业/进程调度</p>
<p>既可用于作业调度，也可用于进程调度。</p>
</li>
<li><p>是否可抢占</p>
<p>非抢占式算法，因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比。</p>
</li>
<li><p>优缺点</p>
<p>综合考虑了等待时间和运行时间（要求服务时间）；</p>
<p>等待时间相同时，要求服务时间短的优先（SJF的优点）；</p>
<p>要求服务时间相同时，等待时间长的优先（FCFS的优点）；</p>
<p>对于长作业来说，随着等待时间越来越久，其响应比也会也来越大，从而避免了长作业饥饿的问题。</p>
</li>
<li><p>是否会导致饥饿</p>
<p>不会。</p>
</li>
</ul>
<h1 id="5-时间片轮转调度算法"><a href="#5-时间片轮转调度算法" class="headerlink" title="5. 时间片轮转调度算法"></a>5. 时间片轮转调度算法</h1><ul>
<li><p>算法思想</p>
<p>公平的、轮流为各个进程服务，让每个进程在一定时间间隔内都可以得到响应。</p>
</li>
<li><p>算法规则</p>
<p>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</p>
</li>
<li><p>用于作业/进程调度</p>
<p>用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）。</p>
</li>
<li><p>是否可抢占</p>
<p>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式算法。由时钟装置发出的时钟中断来通知CPU时间片已到。</p>
</li>
<li><p>优缺点</p>
<ul>
<li>公平；响应快，适用于分时操作系统。</li>
<li>由于高频率的进程切换，因此有一定的开销；不区分任务的紧急程度。</li>
</ul>
</li>
<li><p>是否会导致饥饿</p>
<p>不会。</p>
</li>
<li><p>补充</p>
<ul>
<li>时间片太大，使得每个进程可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。</li>
<li>时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的</li>
</ul>
</li>
</ul>
<h1 id="6-多级反馈队列调度算法（融合了前几种算法的优点）"><a href="#6-多级反馈队列调度算法（融合了前几种算法的优点）" class="headerlink" title="6. 多级反馈队列调度算法（融合了前几种算法的优点）"></a>6. 多级反馈队列调度算法（融合了前几种算法的优点）</h1><ul>
<li><p>算法思想</p>
<p>对其它调度算法的折中权衡。</p>
</li>
<li><p>算法规则</p>
<ul>
<li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。</li>
<li>新进程到达时先进入第一级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾。</li>
<li>只有第k级队列为空时，才会为k + 1级队头的进程分配时间片。</li>
</ul>
</li>
<li><p>用于作业/进程调度</p>
<p>用于进程调度。</p>
</li>
<li><p>是否可抢占</p>
<p>抢占式算法。在k级队列的进程运行过程中，若更上级的队列中进入了一个新的进程，则由于新进程处于优先级最高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。</p>
</li>
<li><p>优缺点</p>
<p>对各类型进程相对公平（FCFS的优点）；每个新到达的进程都可以很快得到相应（RR的优点）；短进程只用较少的时间就可完成（SJF的优点）；不必实现估计进程的运行时间（避免用户作假）；可灵活的调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程（扩展：可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级）。</p>
</li>
<li><p>是否会导致饥饿</p>
<p>会。</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/16/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>网络应用是计算机网络存在的理由，如果我们不能构想出任何有用的应用，也就没有任何必要去设计支持它们的网络协议了。</p>
<p>研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序。当研发新应用程序时，你需要编写将在多台端系统上运行的软件。例如，该软件能够用C、Java或Python来编写。重要的是，你不需要写在网络核心设备如路由器或链路层交换机上运行的软件。即使你要为网络核心设备写应用程序软件，你也不能做到这一点。网络核心设备并不在应用层上起作用，而仅在较低层起作用，特别是位于网络层及下面层次。这种基本设计，也即将应用软件限制在端系统的方法，促进了大量的网络应用程序的迅速研发和部署。</p>
<h1 id="1-网络应用程序体系结构"><a href="#1-网络应用程序体系结构" class="headerlink" title="1. 网络应用程序体系结构"></a>1. 网络应用程序体系结构</h1><p>从应用程序研发者的角度看，网络体系结构是固定的，并为应用程序提供了特定的服务集合。在另一方面，应用程序体系结构由应用程序研发者设计，规定了如何在各种端系统上组织该程序。在选择应用程序体系结构时，应用程序研发者很可能利用现代网络应用程序中所使用的两种主流体系结构之一：客户-服务器体系结构或对等（P2P）体系结构。</p>
<h2 id="1-1-客户-服务器体系结构"><a href="#1-1-客户-服务器体系结构" class="headerlink" title="1.1 客户-服务器体系结构"></a>1.1 客户-服务器体系结构</h2><p>在客户-服务器体系结构中，有一个总是打开的主机称为服务器，它服务于来自许多其它称为客户的主机的请求。一个经典例子是Web应用程序，其中总是打开的Web服务器服务于来自浏览器的请求。当Web服务器接收到来自某客户对某对象的请求时，它向该客户发送所请求的对象作为响应。</p>
<p>这种体系结构有两种典型特征：</p>
<ul>
<li>客户相互之间不直接通信。</li>
<li>服务器具有固定的、周知的地址，该地址称为IP地址。</li>
</ul>
<p>因为服务器具有固定的、周知的地址，并且因为该服务器总是打开的，客户总是能够通过向该服务器的IP地址发送分组来与其联系。</p>
<p>在一个客户-服务器应用中，常常会出现一台单独的服务器主机跟不上它所有客户请求的情况。为此，配备大量主机的<strong>数据中心</strong>常被用于创建强大的虚拟服务器。一个数据中心能够有数十万台服务器，它们必须要供电和维护。此外，服务提供商必须支付不断出现的互联和带宽费用，以发送和接收到达/来自数据中心的数据。</p>
<h2 id="1-2-P2P体系结构"><a href="#1-2-P2P体系结构" class="headerlink" title="1.2 P2P体系结构"></a>1.2 P2P体系结构</h2><p>在一个P2P体系结构中，对位于数据中心的专用服务器有最小的依赖。相反，应用程序在间断连接的主机对之间使用直接通信，这些主机对被称为<strong>对等方</strong>。这些对等方并不为服务提供商所有。因为这种对等方通信不必通过专门的服务器，该体系结构被称为对等方到对等方的。许多目前流行的、流量密集型应用都是P2P体系结构的。这些应用包括文件共享（例如BitTorrent）、对等方协助下载器（例如迅雷）等。某些应用具有混合的体系结构，它结合了客户-服务器和P2P的元素。</p>
<p>P2P体系结构的最引人入胜的特性之一是它们的自扩展性。例如，在一个P2P文件共享应用中，尽管每个对等方都由于请求文件产生工作量，但每个对等方通过向其它对等方分发文件也为系统增加服务能力。P2P也是成本有效的，因为它们通常不需要庞大的服务器基础设施和服务器带宽。然后，未来P2P应用面临三个主要挑战：</p>
<ul>
<li>ISP友好。大多数住宅ISP已经受制于“非对称的”带宽应用，也就是说，下载比上载要多得多。但是P2P视频流和文件分发应用改变了从服务器到住宅ISP的上载流量，因而给ISP带来了巨大压力。未来P2P应用需要设计对ISP友好的模式。</li>
<li>安全性。因为它们的高度分布和开放特性，P2P应用给安全带来挑战。</li>
<li>激励。未来P2P应用的成功也取决于说服用户自愿向应用提供带宽、存储和计算自愿，这对激励设计带来挑战。</li>
</ul>
<h1 id="2-进程通信"><a href="#2-进程通信" class="headerlink" title="2. 进程通信"></a>2. 进程通信</h1><p>在OS的术语中，进行通信的实际上是进程而不是程序。一个进程可以被认为是运行在端系统中的一个程序。当进程运行在相同的端系统上时就，它们使用进程间通信机制相互通信。进程间通信的规则由端系统上的OS确定。</p>
<p>在两个不同端系统上的进程，通过跨越计算机网络交换<strong>报文</strong>而相互通信。发送进程生成并向网络中发送报文；接收进程接收这些报文并可能通过将报文发送回去进行响应。</p>
<h2 id="2-1-客户和服务器进程"><a href="#2-1-客户和服务器进程" class="headerlink" title="2.1 客户和服务器进程"></a>2.1 客户和服务器进程</h2><p>网络应用程序由成对的进程组成，这些进程通过网络相互发送报文。我们通常将这两个进程之一标识为客户，另一个进程标识为服务器。对于Web而言，浏览器是一个客户进程，Web服务器是一台服务器进程。对于P2P文件共享，下载文件的对等方标识为客户，上载文件的对等方标识为服务器。</p>
<p>在有些情况下，一个进程能够既是客户又是服务器。例如，在P2P文件共享系统中，一个进程既能上载又能下载文件。无论如何，在任何给定的一对进程之间的通信会话场景中，我们仍能将一个进程表示为客户，另一个进程标识为服务器。我们定义客户和服务器进程如下：</p>
<blockquote>
<p>在给定的一对进程之间的通信会话场景中，发起通信（即在该会话开始时发起与其它进程的联系）的进程被标识为<strong>客户</strong>，在会话开始时等待联系的进程是<strong>服务器</strong>。</p>
</blockquote>
<h2 id="2-2-进程与计算机网络之间的接口"><a href="#2-2-进程与计算机网络之间的接口" class="headerlink" title="2.2 进程与计算机网络之间的接口"></a>2.2 进程与计算机网络之间的接口</h2><p>进程通过一个称为<strong>套接字</strong>的软件接口向网络发送报文和从网络接收报文。我们考虑一个类比来帮助我们理解进程和套接字。进程可类比于一座房子，而它的套接字可以类比于它的们。当一个进程想向位于另外一台主机上的另一个进程发送报文时，它把报文推出该门（套接字）。该发送进程假定该门到另外一侧之间有运输的基础设施，该设施将把报文传送到目的进程的门口。一旦该报文抵达目的主机，它通过接收进程的门（套接字）传递，然后接收进程对该报文进行处理。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211219132923950.png" alt="image-20211219132923950"></p>
<p>如图显示了两个经过因特网通信的进程之间的套接字通信。如该图所示，套接字是同一台主机内应用层与运输层之间的接口。由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的<strong>应用程序编程接口</strong>（Application Programming Interface，API）。应用程序开发者可以控制套接字在应用层端的一切，但是对该套接字的运输层端几乎没有控制权。应用程序开发者对于运输层的控制仅限于：</p>
<ol>
<li>选择运输层协议；</li>
<li>也许能设定几个运输层参数，如最大缓存和最大报文段长度等。</li>
</ol>
<p>一旦应用程序开发者选择了一个运输层协议，则应用程序就建立在由该协议提供的运输层服务之上。</p>
<h2 id="2-3-进程寻址"><a href="#2-3-进程寻址" class="headerlink" title="2.3 进程寻址"></a>2.3 进程寻址</h2><p>为了向特定目的地发送邮政邮件，目的地需要有一个地址。类似地，在一台主机上运行的进程为了向另一台主机上运行的进程发送分组，接收进程需要有一个地址。为了标识该接收进程，需要定义两种信息：</p>
<ol>
<li>主机的地址；</li>
<li>定义在目的主机中的接收进程的标识符。</li>
</ol>
<p>在因特网中，主机由其IP地址标识。在这里，我们只要知道IP地址是一个32比特的量且它能够唯一地标识该主机即可。除了知道报文发送的目的地的主机地址之外，发送进程还必须指定运行在主机上的接收进程（更具体的说，接收套接字）。因为一般而言一台主机能够运行许多网络应用，这些信息是需要的。<strong>目的地端口号</strong>用于这个目的。</p>
<h1 id="3-可供应用程序使用的运输服务"><a href="#3-可供应用程序使用的运输服务" class="headerlink" title="3. 可供应用程序使用的运输服务"></a>3. 可供应用程序使用的运输服务</h1><p>包括因特网在内的很多网络提供了不止一种运输层协议。当开发一个应用时，必须选择一种可用的运输层协议。一个运输层协议能够为调用它的应用程序提供以下四个方面的服务：可靠数据传输、吞吐量、定时和安全性。</p>
<h2 id="3-1-可靠数据传送"><a href="#3-1-可靠数据传送" class="headerlink" title="3.1 可靠数据传送"></a>3.1 可靠数据传送</h2><p>分组在计算机网络中可能丢失，因此，必须做一些工作以确保由应用程序的一端发送的数据正确、完全地交付给该应用程序的另一端。如果一个协议提供了这样的确保数据交付服务，就认为提供了<strong>可靠数据传输</strong>。运输层协议能够潜在地向应用程序提供的一个重要服务是进程到进程的可靠数据传输。当一个运输协议提供这种服务时，发送进程只要将数据传递给套接字，就可以完全相信该数据能无差错地到达接收进程。</p>
<p>当一个运输层协议不提供可靠数据传输时，由发送进程发送的某些数据可能不能够到达接收进程。这可能能被<strong>容忍丢失的应用</strong>所接受，如交谈式音频/视频，它们能够承受一定量的数据丢失。在这些多媒体应用中，丢失的数据引起播放的音频/视频出现小干扰，而不是致命的损伤。</p>
<h2 id="3-2-吞吐量"><a href="#3-2-吞吐量" class="headerlink" title="3.2 吞吐量"></a>3.2 吞吐量</h2><p>在沿着一条网络路径上的两个进程之间的通信会话场景中，可用吞吐量就是发送进程能够向接收进程交付比特的速率。因为其它会话将共享沿着该网络路径的带宽，并且因为这些会话将会到达和离开，该可用吞吐量将随时间波动。这些观察导致另一种自然的服务，即<strong>运输层协议能够以某种特定的速率提供确保的可用吞吐量</strong>。</p>
<p>具有吞吐量要求的应用程序被称为<strong>带宽敏感的应用</strong>。许多当前的多媒体应用是带宽敏感的，尽管某些多媒体应用程序可能采用自适应编码技术对数字语音或视频以与当前可用带宽相匹配的速率进行编码。</p>
<p>带宽敏感的应用具有特定的吞吐量要求，而弹性应用能够根据情况或多或少地利用可供使用的吞吐量。当然，吞吐量越多越好。</p>
<h2 id="3-3-定时"><a href="#3-3-定时" class="headerlink" title="3.3 定时"></a>3.3 定时</h2><p>运输层协议也能提供定时保证。如同具有吞吐量保证那样，定时保证能够以多种形式实现。一个保证的例子如：发送方注入进套接字中的每个比特到达接收方的套接字不迟于100ms。这种服务将对交互式实时应用程序有吸引力，如因特网电话、虚拟环境、电话会议和多方游戏，所有这些服务为了有效性而要求数据交付有严格的时间限制。对于非实时的应用，较低的时延总比较高的时延好，但对端到端的时延没有严格的约束。</p>
<h2 id="3-4-安全性"><a href="#3-4-安全性" class="headerlink" title="3.4 安全性"></a>3.4 安全性</h2><p>最后，运输协议能够为应用程序提供一种或多种安全性服务。例如，在发送主机中，运输协议能够加密由发送进程传输的所有数据，在接收主机中，运输层协议能够在将数据交付给接收进程之前解密这些数据。这种服务将在发送和接收进程之间提供机密性，以防该数据以某种方式在这两个进程之间被观察到。运输协议还能提供除了机密性以外的其它安全性服务，包括数据完整性和端点鉴别。</p>
<h1 id="4-因特网提供的运输服务"><a href="#4-因特网提供的运输服务" class="headerlink" title="4. 因特网提供的运输服务"></a>4. 因特网提供的运输服务</h1><p>因特网为应用程序提供两个运输层协议，即UDP和TCP。每个协议为调用它们的应用程序提供了不同的服务集合。</p>
<table>
<thead>
<tr>
<th align="left">应用</th>
<th align="center">数据丢失</th>
<th align="left">带宽</th>
<th align="left">时间敏感</th>
</tr>
</thead>
<tbody><tr>
<td align="left">文件传输</td>
<td align="center">不能丢失</td>
<td align="left">弹性</td>
<td align="left">不</td>
</tr>
<tr>
<td align="left">电子邮件</td>
<td align="center">不能丢失</td>
<td align="left">弹性</td>
<td align="left">不</td>
</tr>
<tr>
<td align="left">Web文档</td>
<td align="center">不能丢失</td>
<td align="left">弹性（几kbps）</td>
<td align="left">不</td>
</tr>
<tr>
<td align="left">因特网电话/视频会议</td>
<td align="center">容忍丢失</td>
<td align="left">音频（几dbps<del>1Mbps）<br />视频（10kbps</del>5Mbps）</td>
<td align="left">是，100ms</td>
</tr>
<tr>
<td align="left">存储音频/视频</td>
<td align="center">容忍丢失</td>
<td align="left">同上</td>
<td align="left">是，几秒</td>
</tr>
<tr>
<td align="left">交互式游戏</td>
<td align="center">容忍丢失</td>
<td align="left">几kbps~10kbps</td>
<td align="left">是，100ms</td>
</tr>
<tr>
<td align="left">即时讯息</td>
<td align="center">不能丢失</td>
<td align="left">弹性</td>
<td align="left">是和不是</td>
</tr>
</tbody></table>
<h2 id="4-1-TCP服务"><a href="#4-1-TCP服务" class="headerlink" title="4.1 TCP服务"></a>4.1 TCP服务</h2><p>TCP服务模型包括面向连接服务和可靠数据传输服务。当某个应用程序调用TCP作为其运输协议时，该应用程序就能获得来自TCP的这两种服务。</p>
<ul>
<li>面向连接的服务：在应用层数据报文开始流动之前，TCP让客户和服务器互相交换运输层控制信息。这个所谓的握手过程提示客户和服务器，使它们为大量分组的到来做好准备。在握手阶段，一个TCP连接就在两个进程的套接字之间建立了。这条连接是全双工的，即连接双方的进程可以在此连接上同时进行报文收发。当应用程序结束报文发送时，必须拆除该连接。</li>
<li>可靠的数据传送服务：通信进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据。当应用程序的一段将字节流传进套接字时，它能够依靠TCP将相同的字节流交付给接收方的套接字，而没有字节的丢失和冗余。</li>
</ul>
<p>TCP协议还具有拥塞控制机制，这种服务不一定能为通信进程带来直接好处，但能为因特网带来整体好处。当发送方和接收方之间的网络出现拥塞时，TCP的拥塞控制机制会抑制发送进程。TCP拥塞控制也试图限制每个TCP连接，使它们达到公平共享网络带宽的目的。</p>
<blockquote>
<div aliqn="center">
    <font color="bule">TCP安全</font>
</div>

<p>无论TCP还是UDP都没有提供任何加密机制，这就是说发送进程传进其套接字的数据，与经网络传送到目的进程的数据相同。因此，举例来说如果某发送进程以明文方式发送了一个口令进入它的套接字，该明文口令将经过发送放于接收方之间的所有链路传送，这就可能在任何中间链路被嗅探和发现。因为隐私和其它安全问题对许多应用而言已经称为至关重要的问题，所以因特网界已经研制了TCP的加强版本，称为<strong>安全套接字层（Secure Sockets Layer，SSL）</strong>。用SSL加强后的TCP不仅能够做传统的TCP所能做的一切，而且提供了关键的进程到进程的安全性服务，包括加密、数据完整性和端点鉴别。</p>
</blockquote>
<h2 id="4-2-UDP服务"><a href="#4-2-UDP服务" class="headerlink" title="4.2 UDP服务"></a>4.2 UDP服务</h2><p>UDP是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。UDP是无连接的，因此在两个进程通信前没有握手过程。UDP协议提供一种不可靠数据传送服务，也就是说，当进程将一个报文发送进UDP套接字时，UDP协议并不保证该报文将到达接收进程。不仅如此，到达接收进程的报文也可能是乱序到达的。</p>
<p>UDP没有包括拥塞控制机制，所以UDP的发送端可以用它选定的任何速率向其下层注入数据。（然而，值得注意的是实际端到端吞吐量可能小于这种速率，这可能是因为中间链路的带宽受限或因为拥塞而造成的。）</p>
<h2 id="4-3-因特网运输协议所不提供的服务"><a href="#4-3-因特网运输协议所不提供的服务" class="headerlink" title="4.3 因特网运输协议所不提供的服务"></a>4.3 因特网运输协议所不提供的服务</h2><p>在我们对TCP和UDP的简要概述中，明显地缺少了对吞吐量或定时保证的讨论，即这些服务目前的因特网运输协议并没有提供。当然，这并不意味着时间敏感应用不能运行在今天的因特网上。这些应用经常工作的相当好，因为它们已经被设计成尽最大可能对付这种保证的缺乏。总之，今天的因特网通常能够为时间敏感应用提供满意的服务，但它不能提供任何定时或贷款保证。</p>
<p>表中指出了一些流行的因特网应用所使用的运输协议。可以看到，电子邮件、远程终端访问、Web、文件传输都是用了TCP。这些应用选择TCP的最主要原因是TCP提供了可靠数据传输服务，确保所有数据最终到达目的地。因为因特网电话应用通常能够忍受某些丢失但要求达到一定的最小速率才能有效工作，所以因特网电话应用的开发者通常愿意将该应用运行在UDP上，从而设法避开TCP的拥塞控制机制和分组开销。但因为许多防火墙被配置成阻挡UDP流量，所以因特网电话应用通常设计成如果UDP通信失败就使用TCP作为备份。</p>
<table>
<thead>
<tr>
<th>应用</th>
<th>应用层协议</th>
<th>支撑的运输协议</th>
</tr>
</thead>
<tbody><tr>
<td>电子邮件</td>
<td>SMTP[RFC 5321]</td>
<td>TCP</td>
</tr>
<tr>
<td>远程终端访问</td>
<td>Telnet[RFC 854]</td>
<td>TCP</td>
</tr>
<tr>
<td>Web</td>
<td>HTTP[RFC 26116]</td>
<td>TCP</td>
</tr>
<tr>
<td>文件传输</td>
<td>FTP[RFC 959]</td>
<td>TCP</td>
</tr>
<tr>
<td>流式多媒体</td>
<td>HTTP（如YouTube）</td>
<td>TCP</td>
</tr>
<tr>
<td>因特网电话</td>
<td>SIP[RFC 3261]、RTP[RFC 3550]或专用的（如Skype）</td>
<td>UDP或TCP</td>
</tr>
</tbody></table>
<h1 id="5-应用层协议"><a href="#5-应用层协议" class="headerlink" title="5. 应用层协议"></a>5. 应用层协议</h1><p>上面我们知道了通过把报文发送进套接字使网络进程间实现相互通信。但是如何构造这些报文？在这些报文中的各个字段的含义是什么？进程何时发送这些报文？这些问题将我们带进应用层协议的范围。<strong>应用层协议</strong>定义了运行在不同端系统上的应用程序进程如何相互传递报文。特别是应用层协议定义了：</p>
<ul>
<li>交换的报文类型，例如请求报文和响应报文。</li>
<li>各种报文类型的语法，如报文中的各个字段及这些字段是如何描述的。</li>
<li>字段的语义，即这些字段中包含的信息的含义。</li>
<li>一个进程何时以及如何发送报文，对报文进行响应的规则。</li>
</ul>
<p>有些应用层协议是由RFC文档定义的，因此它们位于公共域中。例如，Web的应用层协议HTTP。还有很多别的应用层协议是专用的，有意不为公共域使用。例如，Skype使用了专用的应用层协议。</p>
<p>区分网络应用和应用层协议是很重要的。应用层协议只是网络应用的一部分。看一个例子，Web是一种客户-服务器应用，它允许客户按照需求从Web服务器获得文档。该Web应用有很多组成部分，包括文档格式的标准、Web浏览器、Web服务器，以及一个应用层协议。Web的应用层协议是HTTP，它定义了在浏览器和Web服务器之间传输的报文格式和序列。因此，HTTP只是Web应用的一个部分（尽管是重要部分）。</p>
]]></content>
  </entry>
  <entry>
    <title>Checkpoint技术</title>
    <url>/2021/12/16/checkpoint%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p>缓冲池的设计目的为了协调CPU速度与磁盘速度的鸿沟。因此页的操作首先都是在缓冲池完成的。如果一条DML语句，如Update或Delete改变了页中的记录，那么此时页是脏的，即缓冲池中的页的版本要比磁盘的新。数据库需要将新版本的页从缓冲池刷新到磁盘。</p>
]]></content>
  </entry>
  <entry>
    <title>目标文件里有什么(上)</title>
    <url>/2021/12/16/%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E9%87%8C%E6%9C%89%E4%BB%80%E4%B9%88-%E4%B8%8A/</url>
    <content><![CDATA[<p>编译器编译源代码后生成的文件叫做<strong>目标文件</strong>，那么目标文件里面到底存放的是什么？我们的源代码在经过编译以后这么存储？</p>
<p>目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号有些地址还没有被调整。其实它本身就是按照可执行文件格式存储的，只是跟真正的可执行文件在结构上稍有不同。</p>
<h1 id="目标文件的格式"><a href="#目标文件的格式" class="headerlink" title="目标文件的格式"></a>目标文件的格式</h1>]]></content>
  </entry>
  <entry>
    <title>编写你的第一个网页</title>
    <url>/2021/12/16/%E7%BC%96%E5%86%99%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BD%91%E9%A1%B5/</url>
    <content><![CDATA[<p>首先看我们要达到的效果：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211216144422561.png" alt="image-20211216144422561"></p>
<h1 id="Step1："><a href="#Step1：" class="headerlink" title="Step1："></a>Step1：</h1><p>打开记事本：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211216144631408.png" alt="image-20211216144631408"></p>
<p>写入内容：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211216144920953.png" alt="image-20211216144920953"></p>
<p>保存：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211216144842325.png" alt="image-20211216144842325"></p>
<p>打开我们保存的index.html，我们看到的效果如下：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211216145309783.png" alt="image-20211216145309783"></p>
<h1 id="Step2"><a href="#Step2" class="headerlink" title="Step2:"></a>Step2:</h1><p>我们再用记事本打开刚才的index.html，现在双击它会使用你电脑的默认浏览器打开，可以右键index.html，在打开方式里面找到记事本打开即可（打开方式里面没有继续点击更多方式找到记事本即可）。在index.html加入一些标签：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211216145807312.png" alt="image-20211216145807312"></p>
<p>这是我们再双击index.html看到的效果如下：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211216151412732.png" alt="image-20211216151412732"></p>
<h1 id="Step3："><a href="#Step3：" class="headerlink" title="Step3："></a>Step3：</h1><p>尽管现在我们看到的效果很接近我们想要的效果，但这还并不是一个网页，我们再用记事本打开index.html，加入以下标签：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211216150157188.png" alt="image-20211216150157188"></p>
<p>这是我们看到的效果就是我们想要的效果了（PS：虽然这还并不是一个标准的HTML网页），我们的第一个网页就到此结束了！</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211216150133366.png" alt="image-20211216150133366"></p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><blockquote>
<p>每次修改文件后记得Ctrl + S保存文件，不然无法显示修改后的效果。</p>
</blockquote>
<p>完整源代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>编写你的第一个HTML网页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h1</span>&gt;</span>回乡偶书二首<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h2</span>&gt;</span>其一<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h2</span>&gt;</span>贺知章<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span>&gt;</span>少小离家老大回，<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span>&gt;</span>乡音无改鬓毛衰。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span>&gt;</span>儿童相见不相识，<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span>&gt;</span>笑问客从何处来。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>我们把类似于&lt;html&gt;这样的东西称为标签</p>
<ul>
<li><p>所有标签以”/“结束</p>
</li>
<li><p>标签分为单标签和双标签</p>
</li>
<li><pre><code class="html">&lt;a/&gt;    &lt;!--这是一个单标签--&gt;
&lt;a&gt;&lt;/a&gt; &lt;!--这是一个双标签--&gt;
</code></pre>
</li>
<li><p>每一个网页有且仅有一个&lt;html&gt;标签</p>
</li>
<li><p>每个html标签下有一个head头部标签和body身体标签</p>
</li>
</ul>
</li>
<li><p>h1标签表示这是一个一级标题，类似的还有h2、h3、h4、h5、h6</p>
</li>
<li><p>p标签表示这是一个段落标签</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>模块拼装——静态链接</title>
    <url>/2021/12/16/%E6%A8%A1%E5%9D%97%E6%8B%BC%E8%A3%85%E2%80%94%E2%80%94%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<p>链接器年龄比编译器长</p>
<p>计算机的程序开发并非从一开始就有着这么复杂的自动化编译、链接过程。原始的链接概念远在高级程序语言发明之前就已经存在了，在最开始的时候，程序员（当时的程序员概念跟现在相差很大了）先把一个程序在纸上写好，当然当时没有很高级的语言，用的都是机器语言，甚至连汇编语言都没有。当程序要被运行时，程序员人工将他写的程序写入存储设备上，最原始的存储设备之一就是纸带，即在纸带上打相应的孔。</p>
<p>现在我们考虑一个问题，程序并不是一写好就永远不变化的，它可能会经常被修改。当我们需要修改的时候，程序员需要人工重新计算每个子程序或跳转的目标地址。当程序修改的时候，这些位置都要重新计算，十分繁琐和耗时，并且容易出错。这种重新计算各个目标的地址过程叫做重定位（Relocation）。</p>
<p>程序设计的模块化是人们一直在追求的目标，因为当一个系统十分复杂的时候，我们不得不将一个复杂的系统逐步分割成小的系统以达到各个突破的目的。一个复杂的软件也如此，人们把每个源代码模块独立地编译，然后按照需要将它们”组装“起来，这个组装模块的过程就是链接（Linking）。链接的主要内容就是把各个模块之间相互引用的部分都处理好，使得各个模块之间能够正确地衔接。链接过程主要包括了地址和空间分配（Address and Storage Allocation）、符号决议（Symbol Resolution）和重定位（Relocation）等这些步骤。</p>
<blockquote>
<p>符号决议有时候也被叫做符号绑定（Symbol Binding）、名称绑定（Name Binding）、名称决议（Name Resolution），甚至还有叫做地址绑定（Address Binding）、指令绑定（Instruction Binding）的，大体上它们的意思都一样，但从细节角度来区分，它们之间还是存在一定的区别的，比如“决议”更倾向于静态链接，而“绑定”更倾向于动态链接，即它们所使用的范围不一样。在静态链接，我们将统一称为符号决议。</p>
</blockquote>
<p>最基本的静态链接过程如图所示。每个模块的源代码文件经过编译器编译成目标文件，目标文件和库一起链接形成最终可执行文件。而最常见的库就是运行时库（Runtime Library），它是支持程序运行的基本函数的集合。库其实是一组目标文件的包，就是一些最常用的代码编译成目标文件后打包存放。</p>
<blockquote>
<p>我们认为对于Object文件没有一个很合适的中文名称，把它叫做中间目标文件比较合适，简称为目标文件，很多时候我们也把目标文件称为模块。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>编译器做了什么</title>
    <url>/2021/12/15/%E7%BC%96%E8%AF%91%E5%99%A8%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>从最直观的角度来讲，编译器就是将高级语言翻译成机器语言的一个工具。编译过程一般可以分为6步：<strong>扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化</strong>。整个过程如图所示。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211215105442117.png" alt="image-20211215105442117"></p>
<p>我们结合图来描述从源代码（Source Code）到最终目标代码（Final Target Code）的过程。以一段很简单的C语言的代码为例子来讲述这个过程。比如我们有一行C语言的源代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">array</span>[index] = (index + <span class="number">4</span>) * (<span class="number">2</span> + <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>CompilerExpression.c</p>
<h2 id="1-词法分析"><a href="#1-词法分析" class="headerlink" title="1. 词法分析"></a>1. 词法分析</h2><p>首先源代码程序被输入到<strong>扫描器（Scanner）</strong>，扫描器的任务很简单，它只是简单地进行<strong>词法分析</strong>，运用一种类似于有限状态机的算法可以很轻松地将源代码的字符序列分割成一系列的<strong>记号（Token）</strong>。比如上面的那行程序，总共包含了28个非空字符，经过扫描以后，产生了16个记号，如表所示：</p>
<table>
<thead>
<tr>
<th>记号</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>array</td>
<td>标识符</td>
</tr>
<tr>
<td>[</td>
<td>左方括号</td>
</tr>
<tr>
<td>index</td>
<td>标识符</td>
</tr>
<tr>
<td>]</td>
<td>右方括号</td>
</tr>
<tr>
<td>=</td>
<td>赋值</td>
</tr>
<tr>
<td>(</td>
<td>左圆括号</td>
</tr>
<tr>
<td>index</td>
<td>标识符</td>
</tr>
<tr>
<td>+</td>
<td>加号</td>
</tr>
<tr>
<td>4</td>
<td>数字</td>
</tr>
<tr>
<td>)</td>
<td>右圆括号</td>
</tr>
<tr>
<td>*</td>
<td>乘号</td>
</tr>
<tr>
<td>(</td>
<td>左圆括号</td>
</tr>
<tr>
<td>2</td>
<td>数字</td>
</tr>
<tr>
<td>+</td>
<td>加号</td>
</tr>
<tr>
<td>6</td>
<td>数字</td>
</tr>
<tr>
<td>)</td>
<td>右圆括号</td>
</tr>
</tbody></table>
<p>词法分析产生的记号一般可以分为如下几类：<strong>关键字、标识符、字面量（包含数字、字符串等）和特殊符号（如加号、等号）</strong>。在识别记号的同时，扫描器也完成了其它工作。比如将标识符存放到符号表，将数字、字符串常量存放到文字表等，以备后面的步骤使用。</p>
<p>有一个叫<strong>lex</strong>的程序可以实现词法扫描，它会<strong>按照用户之前描述好的词法规则将输入的字符串分割成一个个记号</strong>。因为这样一个程序的存在，编译器的开发者就无需为每个编译器开发一个独立的词法扫描器，而是根据需要改变词法规则就可以了。</p>
<p>另外对于一些有预处理的语言，比如C，它的宏替换和文件包含等工作一般不归入编译器的范围而交给一个独立的预处理器。</p>
<h2 id="2-语法分析"><a href="#2-语法分析" class="headerlink" title="2. 语法分析"></a>2. 语法分析</h2><p>接下来<strong>语法分析器（Grammar Parser）</strong>将对由扫描器产生的记号进行语法分析，从而产生语法树（Syntax Tree）。整个分析过程采用了<strong>上下文无关语法（Context-free Grammar）</strong>的分析手段。简单地讲，由语法分析器生成的<strong>语法树就是以表达式（Expression）为节点的树</strong>。上面例子中的语句经过语法分析器以后形成如图所示的语法树：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211216121146991.png" alt="image-20211216121146991"></p>
<p>从图中可以看到，整个语句被看作是一个赋值表达式；赋值表达式左边是一个数组表达式，右边是一个乘法表达式；数组表达式又由两个符号表达式组成，等等。符号和数字是最小的表达式，它们不是由其它的表达式来组成的，所以它们通常作为整个语法树的叶节点。在<strong>语法分析的同时，很多运算符号的优先级和含义也被确定下来了</strong>。另外，有些<strong>符号具有多重含义</strong>，比如星号*在C语言中可以表示乘法表达式，也可以表示对指针取内容的表达式，所以<strong>语法分析阶段必须对这些内容进行区分</strong>。如果出现了表达式不合法，比如各种括号不匹配、表达式中缺少操作等等，编译器就会报告语法分析阶段的错误。</p>
<p>正如前面词法分析有lex一样，语法分析也有一个现成的工具叫<strong>yacc（Yet Another Compiler Compiler）</strong>。它也像lex一样，可以<strong>根据用户给定的规则对输入的记号序列进行解析，从而构建出一颗语法树</strong>，对于不同的编程语言，编译器的开发者只须改变语法规则，而无需为每个编译器编写一个语法分析器，所以它又被称为“编译器编译器（Compiler Compiler）”。</p>
<h2 id="3-语义分析"><a href="#3-语义分析" class="headerlink" title="3. 语义分析"></a>3. 语义分析</h2><p>接下来进行的是语义分析，由<strong>语义分析器（Semantic Analyser）</strong>来完成。语法分析仅仅是完成了对表达式的语法层面的分析，但是它并不了解<strong>这个语句是否真正有意义</strong>。比如C语言里面两个指针做乘法运算是没有意义的，但是这个语句在语法上是合法的。<strong>编译器所能分析的语义是静态语义（Static Semantic）</strong>，所谓<strong>静态语义是指在编译器可以确定的语义，与之对应的动态语义（Dynamic Semantic）就是只有在运行期才能确定的语义。</strong></p>
<p><strong>静态语义通常包括声明和类型的匹配，类型的转换</strong>。比如当一个浮点型的表达式赋值给一个整型的表达式时，其中隐含了一个浮点型到整型转换的过程，语义分析过程中需要完成这个步骤。比如将一个浮点型赋值给一个指针的时候，语义分析程序会发现这个类型不匹配，编译器将会报错。动态语义一般指在运行期出现的语义相关的问题，比如将0作为除数。</p>
<p>经过语义分析阶段以后，整个语法树的表达式都被标识了类型，如果有些类型需要做隐式转换，语义分析程序会在语法树中插入相应的转换节点。上面描述的语法树在经过语义分析阶段以后就成了如图所示的形式：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211216124101744.png" alt="image-20211216124101744"></p>
<p>可以看到，每个表达式（包括符号和数字）都被表示了类型。我们例子中几乎所有表达式都是整型的，所以无须做转换，整个分析过程十分顺利。语义分析器还对符号表里的符号类型也做了更新。</p>
<h2 id="4-中间语言生成"><a href="#4-中间语言生成" class="headerlink" title="4. 中间语言生成"></a>4. 中间语言生成</h2><p>现代的编译器有着很多层次的优化，往往在源码级别会有一个优化过程。我们这里所描述的<strong>源码级优化器（Source Code Optimizer）</strong>在不同编译器可能会有不同的定义或有一些其它的差异。在上例中，（2+6）这个表达式可以被优化掉，因为它的值在编译器就可以被确定。类似的还有很多其它复杂的优化过程，经过优化的语法树如图所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211216124147236.png" alt="image-20211216124147236"></p>
<p>我们看到（2+6）这个表达式被优化成8。其实直接在语法树上做优化比较困难，所以源代码优化器往往将整个语法树转换成<strong>中间代码（Intermediate Code）</strong>，<strong>它是语法树的顺序表示</strong>，其实它已经非常接近目标代码了。但是它<strong>一般跟目标机器和运行时环境是无关的</strong>，比如它不包含数据的尺寸、变量地址和寄存器的名字等。中间代码有很多种类型，在不同的编译器中有着不同的形式，比较常见的有：<strong>三地址码（Three-address Code）和P-代码（P-Code）</strong>。我们就拿最常见的三地址码来作为例子，最基本的三地址码是这样的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = y op z</span><br></pre></td></tr></table></figure>

<p>这个三地址码表示将变量y和z进行op操作以后，赋值给x。这里op操作可以是算数运算，比如加减乘除等，也可以是其它人任何可以应用到y和z的操作。三地址码也得名于此，因为一个三地址码语句里面有三个变量地址。我们上面的语法树可以被翻译成三地址码后是这样的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">t1 = <span class="number">2</span> + <span class="number">6</span></span><br><span class="line">t2 = index + <span class="number">4</span></span><br><span class="line">t3 = t2 * t1</span><br><span class="line"><span class="built_in">array</span>[index] = t3</span><br></pre></td></tr></table></figure>

<p>我们可以看到，为了使所有的操作都符合三地址码形式，这里利用了几个临时便变量。在三地址码的基础上进行优化时，优化程序会将2+6的结果计算出来，得到t1 = 6。经过优化的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">t2 = index + <span class="number">4</span></span><br><span class="line">t2 = t2 * <span class="number">8</span></span><br><span class="line"><span class="built_in">array</span>[index] = t2</span><br></pre></td></tr></table></figure>

<p>中间代码使得编译器可以被分成<strong>前端和后端</strong>。编译器<strong>前端负责产生机器无关的中间代码</strong>，编译器<strong>后端将中间代码转换成目标机器代码</strong>。这样对于一些可以跨平台的编译器而言，它们可以针对不同的平台使用同一个前端和针对不同机器平台的数个后端。</p>
<h2 id="5-目标代码生成与优化"><a href="#5-目标代码生成与优化" class="headerlink" title="5. 目标代码生成与优化"></a>5. 目标代码生成与优化</h2><p>源代码级优化器产生中间代码标志着下面的过程都属于编辑器后端<strong>。编译器后端主要包括代码生成器（Code Generator）和目标代码优化器（Target Code Optimizer）</strong>。</p>
<p>代码生成器将中间代码转换成目标机器代码，这个过程十分依赖于目标机器，因为不同的机器有着不同的字长、寄存器、整数数据类型和浮点数数据类型等。对于上面例子中的中间代码，代码生成器可能会生成下面的代码序列（我们用x86汇编语言来表示，并且假设index的类型为int型，array的类型为int型数组）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl index, %ecx				; value of index to ecx</span><br><span class="line">addl $4, %ecx					; ecx = ecx + 4</span><br><span class="line">mull $8, %ecx					; ecx = ecx * 8</span><br><span class="line">movl index, %eax				; value of index to eax</span><br><span class="line">movl %ecx, array(, eax, 4)		; array[index] = ecx</span><br></pre></td></tr></table></figure>

<p>最后目标代码优化器对上述的目标代码进行优化，比如选择合适的寻址方式、使用位移来代替乘法运算、删除多余的指令等。上面的例子中，乘法由一条相对复杂的<strong>基址比例变址寻址（Base Index Scale Addressing）</strong>的lea指令完成，随后由一条mov指令完成最后的赋值操作，这条mov指令的寻址方式与lea是一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl index, %edx</span><br><span class="line">leal 32(, %edx, 8), %eax</span><br><span class="line">movl %eax, array(, %edx, 4)</span><br></pre></td></tr></table></figure>

<p>现代的编译器有着异常复杂的结构，这是因为现代高级编程语言本身非常复杂，另外现代的计算机CPU相当复杂，为了支持这些复杂性，编译器的机器指令优化过程也变得十分复杂。使得编译过程更为复杂的是有些编译器支持多种硬件平台，即允许编译器编译出多种目标CPU的代码。比如著名的GCC编译器就支持几乎所有CPU平台，这也导致了编译器的指令生成过程更为复杂。</p>
<p>经过这些扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化，编译器忙活了这么多个步骤之后，源代码终于被编译成了目标代码。但是这个目标代码中有一个问题是：index和array的地址还没有确定。如果我们要把目标代码使用汇编器编译成真正能够在机器上执行的指令，那么index和array的地址应该从哪儿得到？如果index和array定义在跟上面的源代码同一个编译单元里面，那么编译器可以为index和array分配空间，确定它们的地址；那如果是定义在其它的程序模块呢？</p>
<p>这个看似简单的问题引出了一个很大的话题：目标代码中有变量定义在其它模块，该怎么办？事实上，定义其它模块的全局变量和函数在最终运行时的绝对地址都要在最终链接的时候才能确定。所以现<strong>代的编译器可以将一个源代码文件编译成一个未链接的目标文件，然后由链接器最终将这些目标文件链接起来形成可执行文件</strong>。</p>
]]></content>
  </entry>
  <entry>
    <title>编译和链接</title>
    <url>/2021/12/14/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<p>对于平常的应用程序开发，我们很少需要关注编译和链接过程，因为通常的开发环境都是流行的集成开发环境（IDE），比如Visual Studio、IDEA等。这样的IDE一般都将编译和链接的过程一步完成，通常将这种编译和链接合并到一起的过程称为构建（Build）。即使使用命令行来编译一个源代码文件，简单的一句”gcc hello.c“命令就包含了非常复杂的过程。</p>
<h1 id="被隐藏了的过程"><a href="#被隐藏了的过程" class="headerlink" title="被隐藏了的过程"></a>被隐藏了的过程</h1><p>C语言的经典，”HelloWorld“程序几乎是每个程序员闭着眼睛都能写出的，编译运行通过一气呵成，基本成了程序入门和开发环境测试的默认的标准。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Linux下，当我们使用GCC来编译HelloWorld程序时，只须使用最简单的命令：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211214232500974.png" alt="image-20211214232500974"></p>
<p>事实上，上述过程可以分解为4个步骤，分别是预处理（Prepressing）、编译（Compilation）、汇编（Assembly）和链接（Linking），如图所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211214233130580.png" alt="image-20211214233130580"></p>
<h2 id="1-预编译"><a href="#1-预编译" class="headerlink" title="1. 预编译"></a>1. 预编译</h2><p>首先是源代码文件hello.c和相关的头文件，如stdio.h等被与编译器cpp预编译成一个.i文件。第一步预编译的过程相当于如下命令（-E表示只进行预编译）：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211214233646816.png" alt="image-20211214233646816"></p>
<p>预编译过程主要处理那些源代码文件中的以”#“开始的预编译命令。比如”#include“、”#define“等，主要处理规则如下：</p>
<ul>
<li>将所有的”#define“删除，并且展开所有的宏定义。</li>
<li>处理所有条件预编译指令，比如”#if“、”#ifdef“、”#elif“、“#else”、“#endif”。</li>
<li>处理“#include”预编译指令，将被包含的文件插入到该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其它文件。</li>
<li>删除所有的注释。</li>
<li>添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。</li>
<li>保留所有的#pragma编译器指令，因为编译器需要使用它们。</li>
</ul>
<p>经过预编译后的.i文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到.i文件中。所以当我们无法判断宏定义是否正确或头文件包含是否正确时，可以查看预编译后的文件来确定问题。</p>
<h2 id="2-编译"><a href="#2-编译" class="headerlink" title="2. 编译"></a>2. 编译</h2><p>编译过程就是把与处理完的文件进行一系列词法分析、语法分析、语义分析及优化后产生相应的汇编代码文件，这个过程往往是我们所说的整个程序构建的核心部分，也是最复杂的部分之一。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211214234539174.png" alt="image-20211214234539174"></p>
<p>现在版本的GCC把预编译和编译两个步骤合并成一个步骤，使用一个叫cc1的程序来完成这两个步骤。这个程序位于/usr/lib/gcc/x86_64-linux-gnu/9/cc1”，我们也可以直接调用ccl来完成它：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211214235219782.png" alt="image-20211214235219782"></p>
<p>对于C语言的代码来说，这个预编译和编译的程序是cc1，对于C++来说，有对应的程序叫做cc1plus；Objective-C是cc1obj；Java是jc1。所以实际上gcc这个命令只是这些后台程序的包装，它会根据不同的参数要求去调用预编译和编译程序cc1、汇编器as、链接器ld。</p>
<h2 id="3-汇编"><a href="#3-汇编" class="headerlink" title="3. 汇编"></a>3. 汇编</h2><p>汇编器是将汇编代码转变成机器可以执行的指令，每个汇编语句几乎都对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译就可以了。这个汇编过程我们可以用汇编器as来完成：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211214235945685.png" alt="image-20211214235945685"></p>
<p>或者：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211215000126851.png" alt="image-20211215000126851"></p>
<p>或者使用gcc命令从C源代码文件开始，经过预编译、编译和汇编直接输出目标文件：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211215000221604.png" alt="image-20211215000221604"></p>
<h2 id="4-链接"><a href="#4-链接" class="headerlink" title="4. 链接"></a>4. 链接</h2><p>链接通常是一个让人比较费解的过程，为什么汇编器不直接输出可执行文件而是输出一个目标文件呢？链接过程到底包含了什么内容？为什么要链接？下面让我们来看看怎么样调用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ld -static /usr/lib/crtl.o /usr/lib/crti.o /usr/lib/gcc/x86_64-linux-gnu/9/crtbeginT.o -L /usr/lib/gcc/x86_64-linux-gnu/9/ -L /usr/lib -L /lib hello.o --start-group -lgcc -lgcc_eh -lc --end-group /usr/lib/gcc/x86_64-linux-gnu/9/crtend.o /usr/lib/crtn.o</span><br></pre></td></tr></table></figure>

<p>如果把所有的路径都省略掉，那么上面的命令就是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ld -staic crtl.o crti.o crtbeginT.o hello.o -start-group -lgcc -lgcc_eh -lc -end-group crtend.o crtn.o</span><br></pre></td></tr></table></figure>

<p>可以看到，我们需要将一大堆文件连接起来才可以得到“a.out”，即最终的可执行文件。至于crtl.o、crti.o、crtbeginT.o、crtend.o、crtn.o这些文件是什么？它们做什么用的？-lgcc -lgcc_eh -lc这些都是什么参数？为什么要使用它们？为什么要将它们和hello.o链接起来才可以得到可执行文件？等等。这里不做详细赘述。</p>
]]></content>
  </entry>
  <entry>
    <title>InnoDB体系架构</title>
    <url>/2021/12/14/InnoDB%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211214221614973.png" alt="image-20211214221614973"></p>
<p>图中显示了InnoDB的存储引擎的体系结构，InnoDB存储引擎有多个内存块，可以认为这些内存块组成了一个大的内存池，负责如下工作：</p>
<ul>
<li>维护所有进程/线程需要访问的多个内部数据结构。</li>
<li>缓存磁盘上的数据，方便快速地读取，同时在对磁盘文件的数据修改之前在这里缓存。</li>
<li>重做日志缓冲。</li>
</ul>
<p>后台线程的主要作用是负责刷新内存池中的数据，保证缓冲池的内存缓存的是最近的数据。此外将已修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下InnoDB能恢复到正常运行状态。</p>
<h1 id="1-后台进程"><a href="#1-后台进程" class="headerlink" title="1. 后台进程"></a>1. 后台进程</h1><p>InnoDB存储引擎是多线程的模型，因此其后台有多个不同的后台线程，负责处理不同的任务。</p>
<h2 id="1-1-Master-Thread"><a href="#1-1-Master-Thread" class="headerlink" title="1.1 Master Thread"></a>1.1 Master Thread</h2><p>Master Thread是一个非常核心的后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（INSERT BUFFER）、UNDO页的回收等。</p>
<h2 id="1-2-IO-Thread"><a href="#1-2-IO-Thread" class="headerlink" title="1.2 IO Thread"></a>1.2 IO Thread</h2><p>在InnoDB存储引擎中大量使用了AIO（Async IO）来处理写IO请求，这样可以极大提高数据库的性能。而IO Thread的工作主要是负责这些IO请求的回调处理。</p>
<p>在InnoDB1.0版本之前共有4个IO Thread，分别是write、read、insert buffer和log IO thread。在Linux平台下，IO Thread的数量不能进行调整，但是在Windows平台下可以通过参数innodb_file_io_threads来增大IO Thread。从InnoDB 1.0x版本开始，read thread和write thread分别增大到了4个，并且不再使用innodb_file_io_threads参数，而是分别使用innodb_read_threads和innodb_write_io_threads参数进行设置：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211216200735287.png" alt="image-20211216200735287"></p>
<p>可以通过命令show engine innodb status来观察InnoDB中的IO Thread：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show engine innodb status;</span><br><span class="line"></span><br><span class="line">| Type   | Name | Status</span><br><span class="line"></span><br><span class="line">| InnoDB |      |</span><br><span class="line">=====================================</span><br><span class="line">2021-12-16 20:08:28 0x5d40 INNODB MONITOR OUTPUT</span><br><span class="line">=====================================</span><br><span class="line">Per second averages calculated from the last 26 seconds</span><br><span class="line">......</span><br><span class="line">--------</span><br><span class="line">FILE I/O</span><br><span class="line">--------</span><br><span class="line">I/O thread 0 state: wait Windows aio (insert buffer thread)</span><br><span class="line">I/O thread 1 state: wait Windows aio (log thread)</span><br><span class="line">I/O thread 2 state: wait Windows aio (read thread)</span><br><span class="line">I/O thread 3 state: wait Windows aio (read thread)</span><br><span class="line">I/O thread 4 state: wait Windows aio (read thread)</span><br><span class="line">I/O thread 5 state: wait Windows aio (read thread)</span><br><span class="line">I/O thread 6 state: wait Windows aio (write thread)</span><br><span class="line">I/O thread 7 state: wait Windows aio (write thread)</span><br><span class="line">I/O thread 8 state: wait Windows aio (write thread)</span><br><span class="line">I/O thread 9 state: wait Windows aio (write thread)</span><br><span class="line">......</span><br><span class="line">----------------------------</span><br><span class="line">END OF INNODB MONITOR OUTPUT</span><br><span class="line">============================</span><br><span class="line"></span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到IO Thread 0为insert buffer thread。IO Thread 1为log thread。之后就是根据参数innodb_read_threads和innodb_write_io_threads来设置的读写线程，并且读线程的ID总是小于写线程的。</p>
<h2 id="1-3-Purge-Thread"><a href="#1-3-Purge-Thread" class="headerlink" title="1.3 Purge Thread"></a>1.3 Purge Thread</h2><p>事务被提交后，其所使用的undolog可能不再需要，因此需要PurgeThread来回收已经使用并分配的undo页。</p>
<p>从InnoDB 1.2版本开始，InnoDB支持多个Purge Thread，这样做的目的是为了进一步加快undo页的回收。同时由于Purge Thread需要离散地读取undo页，这样也能更进一步利用磁盘的随机读取性能。如用户可以设置4个Purge Thread：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211216201354742.png" alt="image-20211216201354742"></p>
<h2 id="1-4-Page-Cleaner-Thread"><a href="#1-4-Page-Cleaner-Thread" class="headerlink" title="1.4 Page Cleaner Thread"></a>1.4 Page Cleaner Thread</h2><p>Page Cleaner Thread是在InnoDB 1.2.x版本中引入的。其作用是将之前版本中脏页的刷新操作都放入到单独的线程中来完成。而其目的是为了减轻原Master Thread的工作以及对于用户查询线程的阻塞，进一步提高InnoDB存储引擎的性能。</p>
<h1 id="2-内存"><a href="#2-内存" class="headerlink" title="2. 内存"></a>2. 内存</h1><h2 id="2-1-缓冲池"><a href="#2-1-缓冲池" class="headerlink" title="2.1 缓冲池"></a>2.1 缓冲池</h2><p>InnoDB存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理。因此可将其视为基于磁盘的数据库系统（Disk-base Database）。在数据库系统中，由于CPU速度与磁盘速度之间的鸿沟，基于磁盘的数据库系统通常使用缓冲池技术来提高数据库的整体性能。</p>
<p>缓冲池简单来说就是一块内存区域，通过内存速度来弥补磁盘速度慢对数据库性能的影响。在数据库中进行读取页的操作，首先将从磁盘读到的页存放到缓冲池中，这个过程称为将页”FIX“在缓冲池中。下一次再读相同的页时，首先判断缓冲池中是否有该页。若在，称该页在缓冲池中被命中，直接读取该页；否则，读取磁盘上的页。</p>
<p>对于数据库中页的的修改操作，则首先刷新在缓冲池中的页，然后再以一定频率刷新的磁盘上。需要注意的是，页从缓冲池刷新到磁盘上并不是在页每次发生修改时，而是通过一种称为Checkpoint的机制刷新会磁盘。同样也是为了提高数据库的整体性能。</p>
<p>对于InnoDB存储引擎而言，其缓冲池的配置通过参数innodb_buffer_pool_size来设置：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211216204300389.png" alt="image-20211216204300389"></p>
<p>具体来看，缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲（insert buffer）、自适应哈希索引（adaptive hash index）、InnoDB存储的锁信息（lock info）、数据字典信息（data dictionary）等。不能简单认为：缓冲池只是缓冲索引页和数据页，它们只是占缓冲池很大的一部分而已。如图显示了InnoDB存储引擎中内存的结构情况：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211216205758868.png" alt="image-20211216205758868"></p>
<p>从InnoDB 1.0.x版本开始，允许有多个缓冲池实例。每个页根据哈希值平均分配到不同缓冲池实例中。这样做的好处是减少数据库内部的资源竞争，增加数据库的并发处理能力。可以通过参数innodb_buffer_pool_instances来进行配置，该值默认为1：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211216210013503.png" alt="image-20211216210013503"></p>
<p>在配置文件中将innodb_buffer_pool_instances设置为大于1的值就可以得到多个缓冲池实例。再通过show engine innodb status可以观察到如下的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show engine innodb status;</span><br><span class="line">......</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 137297920</span><br><span class="line">Dictionary memory allocated 99230</span><br><span class="line">Buffer pool size   8192</span><br><span class="line">Free buffers       7680</span><br><span class="line">Database pages     510</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 476, created 34, written 36</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 510, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">......</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<p>从MySQL 5.6版本开始，还可以通过information_schema架构下的表INNODB_BUFFER_POOL_STATS来观察缓冲的状态：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211216212001753.png" alt="image-20211216212001753"></p>
<h2 id="2-2-LRU-List、Free-List和Flush-List"><a href="#2-2-LRU-List、Free-List和Flush-List" class="headerlink" title="2.2 LRU List、Free List和Flush List"></a>2.2 LRU List、Free List和Flush List</h2><p>在上面的介绍中，我们知道了缓冲池是一个很大的内存区域，里面存放着各种类型的页。那么InnoDB是如何对这么大的内存区域进行管理的呢？</p>
<p>通常来说，数据库中的缓冲池是通过LRU（Latest Recent Used，最近最少使用）算法来进行管理的。即最频繁使用的页在LRU列表的前面。当缓冲池不能存放新读取到的页时，将首先释放LRU列表中尾端的页。</p>
<p>在InnoDB存储引擎中，缓冲池中页的大小默认为16KB，同样使用LRU算法对缓冲池进行管理。稍有不同的是对传统的LRU算法做了一些优化。在InnoDB中，LRU列表中还加入了midpoint位置。新读取到的页，虽然是最新访问的页，但并不是直接放入LRU的首部，而是放入LRU列表的midpoint位置。这个算法在InnoDB存储引擎下称为midpoint insertion strategy。在默认配置下，该位置在LRU列表长度的5/8处。midpoint位置可由参数innodb_old_blocks_pct控制：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211216220939693.png" alt="image-20211216220939693"></p>
<p>在这里，参数的值为37，表示新读取的页插入到LRU列表尾端的37%的位置（差不多3/8的位置）。在InnoDB存储引擎中，把midpoint之后的列表称为old列表，之前的列表称为new列表。可以简单地理解为new列表中的页都是最为活跃的热点数据。</p>
<p>那为什么不采用原始的LRU算法，直接放到首部呢？这是因为若直接将读取到的页放入首部，那么某些SQL操作可能会使缓冲池中的页被刷新出，从而影响缓冲池的效率。常见的这类操作为索引或数据的扫描操作。这类操作需要访问表中的许多页，甚至是全部的页，而这些页通常来说又仅在这次查询操作中需要，并不是活跃的热点数据。</p>
<p>为了解决这个问题，InnoDB引入了另一个参数innodb_old_blocks_time来进一步管理LRU列表，表示页读取到mid位置后需要等待多久才会被加入到LRU列表的热端。因此当需要执行上述所说的SQL操作时，可以通过下面的方法尽可能使LRU列表中热点数据不被刷出：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211216222024115.png" alt="image-20211216222024115"></p>
<p>如果用户预估自己活跃的热点数据不止63%，那么在执行SQL语句前，还可以通过下面语句来减少热点页可能被刷出的概率：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211216222130553.png" alt="image-20211216222130553"></p>
<p>LRU列表用来管理已经读取的页，但当数据库刚启动时，LRU列表是空的。这时页都存放在Free列表中。当需要从缓冲池中分页时，首先从Free列表中查找是否有可用的空闲页，若有则将该页从Free列表中删除，放入到LRU中。否则，根据LRU算法，淘汰LRU末尾的页，将该内存空间分配给新的页。当页从LRU列表的old部分加入到new部分时，称此时发生的操作为page made young，而因为innodb_old_blocks_time的设置而导致页没有从old部分移动到new部分的操作称为page not made young。可以通过show engine innodb status来观察LRU列表及Free列表的使用情况和运行状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show engine innodb status;</span><br><span class="line">| InnoDB |      |</span><br><span class="line">=====================================</span><br><span class="line">2021-12-16 22:26:24 0x5d40 INNODB MONITOR OUTPUT</span><br><span class="line">=====================================</span><br><span class="line">Per second averages calculated from the last 34 seconds</span><br><span class="line">......</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">......</span><br><span class="line">Buffer pool size   8192</span><br><span class="line">Free buffers       7680</span><br><span class="line">Database pages     510</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 476, created 34, written 36</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 510, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">......</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<p>通过命令可以看到：当前Buffer pool size共有8192个页，即8192*16K，总共0.125GB的缓冲池。Free buffers表示当前Free列表中页的数量，Database pages表示LRU列表中页的数量。可能的情况是Free buffers与Database pages的数量之和不等于Buffer pool size。就像上图所示的那样，因为缓冲池中的页还可能会被分配给自适应哈希索引、lock信息、Insert Buffer等页，而这部分页不需要LRU算法进行维护，因此不存在于LRU列表中。</p>
<p>pages made young显示了LRU列表中页移动到前端的次数，因为该服务器在运行阶段没有改变innodb_old_blocks_time的值，因此not young为0。youngs/s、non-youngs/s表示每秒这两类操作的次数。</p>
<p>从InnoDB 1.2版本开始，还可以通过表innodb_buffer_pool_stats来观察缓冲池的运行状态：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211216224427564.png" alt="image-20211216224427564"></p>
<p>此外，还可以通过表innodb_buffer_page_lru来观察每个LRU列表中每个页的具体信息，例如通过下面的语句可以看到缓冲池LRU列表中space为443的表的页类型：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211216225001890.png" alt="image-20211216225001890"></p>
<p>InnoDB存储引擎从1.0.x版本开始支持压缩页的功能，即将原本16KB的页压缩为1KB、2KB、4KB和8KB。而由于页的大小发生了变化，LRU列表也有了些许的改变。对于非16KB的页，是通过unzip_LRU列表进行管理的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show engine innodb status;</span><br><span class="line">| InnoDB |      |</span><br><span class="line">=====================================</span><br><span class="line">2021-12-16 22:26:24 0x5d40 INNODB MONITOR OUTPUT</span><br><span class="line">=====================================</span><br><span class="line">Per second averages calculated from the last 34 seconds</span><br><span class="line">......</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">......</span><br><span class="line">LRU len: 510, unzip_LRU len: 0</span><br><span class="line">......</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到LRU列表中一共有510个页，而unzip_LRU列表中没有页。这里需要注意的是，LRU中的页包含了unzip_LRU列表中的页。</p>
<p>对于压缩页的表，每个表的压缩比率可能各不相同。可能存在有的表页大小为8KB，有的表页大小为2KB的情况。unzip_LRU是怎样从缓冲池中分配内存的呢？</p>
<p>首先，在unzip_LRU列表中对不同压缩页大小的页进行分别管理。其次，通过伙伴算法进行内存的分配。例如对需要从缓冲池中申请页为4KB的大小，其过程如下：</p>
<ol>
<li>检查4KB的unzip_LRU列表，检查是否有可用的空闲页；</li>
<li>若有，则直接使用；</li>
<li>否则，检查8KB的unzip_LRU列表；</li>
<li>若能够得到空闲页，将页分成2个4KB页，再进行存放；</li>
<li>不能，从LRU列表中申请一个16KB的页，将页分为一个8KB和两个4KB的页，分别存放到对应的unzip_LRU列表中。</li>
</ol>
<p>同样，可以通过information_schema架构下的表innodb_buffer_page_lru来观察unzip_LRU列表中的页：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211216230809187.png" alt="image-20211216230809187"></p>
<p>在LRU列表中的页被修改后，称该页为脏页（dirty page），即缓冲池中的页和磁盘上的页数据产生了不一致。这时数据库会通过checkpoint机制将脏页刷新回磁盘，而Flush列表中的页即为脏页列表。需要注意的是，脏页既存在于LRU列表中，也存在于Flush列表中。LRU列表用来管理缓冲池中也的可用性，Flush列表用来管理将也刷新回磁盘，二者互不影响。</p>
<p>同LRU列表一样，Flush列表也可以通过命令show engine innodb status来查看，前面例子中Modified db pages 0就显示了脏页的数量。information_schema架构下并没有类似innodb_buffer_page_lru的表来显示脏页的数量及脏页的类型，但正如前面说的，脏页同样存在于LRU列表中，我们可以通过加入oldest_modification大于0的SQL查询条件：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211216231543226.png" alt="image-20211216231543226"></p>
<p>可以看到当前没有脏页。</p>
<h2 id="2-3-重做日志缓冲"><a href="#2-3-重做日志缓冲" class="headerlink" title="2.3 重做日志缓冲"></a>2.3 重做日志缓冲</h2><p>在上面的图中可以看到，InnoDB存储引擎的内存区域除了有缓冲池外，还有重做日志缓冲（redo log buffer）。InnoDB首先将重做日志信息先放入到这个缓冲区，然后按一定频率将其刷新到重做日志文件。重做日志缓冲一般不需要设置得很大，因为一般情况下每一秒钟会将重做日志缓冲刷新到日志文件，因此用户只需要保证每秒产生得事务量在这个缓冲大小即可。该值可由innodb_log_buffer_size控制，默认为16MB。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211216232025773.png" alt="image-20211216232025773"></p>
<p>在通常情况下，16MB的重做日志缓冲池足以满足绝大部分的应用，因为重做日志在下列三种情况下会将重做日志缓冲中的内容刷新到外部磁盘的重做日志文件中。</p>
<ul>
<li>Master Thread每一秒将重做日志缓冲刷新到重做日志文件；</li>
<li>每个事务提交时会将重做日志缓冲刷新到重做日志文件；</li>
<li>当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件。</li>
</ul>
<h2 id="2-4-额外的内存池"><a href="#2-4-额外的内存池" class="headerlink" title="2.4 额外的内存池"></a>2.4 额外的内存池</h2><p>在InnoDB存储引擎中，对内存的管理是通过一种称为内存堆（heap）的方式进行的。在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。例如，分配了缓冲池（innodb_buffer_pool），但是每个缓冲池中的帧缓冲（frame buffer）还有对应的缓冲控制对象，这些对象记录了一些诸如LRU、锁、等待等信息，而这个对象的内存需要从额外内存池中申请。因此，在申请了很大的InnoDB缓冲池时，也应考虑相应地增加这个值。</p>
]]></content>
  </entry>
  <entry>
    <title>什么是因特网</title>
    <url>/2021/12/14/%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%A0%E7%89%B9%E7%BD%91/</url>
    <content><![CDATA[<p>在这里，我们使用一种特定的计算机网络，即公共因特网，作为讨论计算机网络及其协议的主要载体。关于什么是因特网这个问题，可以从两种方式来回答：其一，我们能够描述因特网的具体构成，即构成因特网的基本硬件和软件组件；其二，我们能够根据分布式应用提供服务的联网基础设施来描述因特网。</p>
<h1 id="1-具体构成描述"><a href="#1-具体构成描述" class="headerlink" title="1. 具体构成描述"></a>1. 具体构成描述</h1><p>因特网是一个世界范围的计算机网络，即它是一个互联了遍及全世界的数以亿计的计算设备的网络。所有这些设备都成为主机（host）或端系统（end system）。</p>
<p>端系统通过通信链路（communication link）和分组交换机（packet switch）连接到一起。不同的链路能够以不同的速率传输数据，链路的传输速率以比特/秒度量（bit/s，或bps）。当一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节。由此形成的信息包用计算机网络的术语来说称为分组（packet）。这些分组通过网络发送到目的端系统，在那里被装配成初始数据。</p>
<p>分组交换机从它的一条入通信链路接收到达的分组，并从它的一条出通信链路转发该分组。现在，市面上最著名的两种分组交换机类型是路由器（router）和链路层交换机（link-layer switch）。链路层交换机通常用于接入网中，而路由器通常用于网络核心中。从发送端系统到接收端系统，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的路径（route或path）。</p>
<p>端系统通过因特网服务提供商（Internet Service Provider，ISP）接入因特网，包括如本地电缆或电话公司那样的住宅区ISP、公司ISP、大学ISP等等。每个ISP是一个由多个分组交换机和多段通信链路组成的网络。</p>
<p>端系统、分组交换机和其它因特网部件都要运行一系列协议（protocol），这些协议控制因特网中信息的接收和发送。TCP（Transmission Control Protocol，传输控制协议）和IP（Internet Protocol，网际协议）是因特网中两个最为重要的协议。IP协议定义了路由器和端系统之间发送和接收的分组格式。因特网的主要协议统称为TCP/IP。</p>
<p>鉴于因特网协议的重要性，每个人就各个协议及其作用取得一致认识是很重要的，这样人们就能够创造协同工作的系统和产品。这正是标准发挥作用的地方。因特网标准由因特网工程任务组研发（Internet Engineering Task Force，IETF）。IETF的标准文档称为请求评论（Request For Comment，RFC）。RFC最初是作为普通的请求评论，以解决因特网先驱者们面临的网络和协议问题。</p>
<h1 id="2-服务描述"><a href="#2-服务描述" class="headerlink" title="2. 服务描述"></a>2. 服务描述</h1><p>我们从为应用程序提供服务的基础设施的角度来描述因特网。这些应用程序包括电子邮件、Web冲浪、即时讯息、社交网络等。这些应用程序称为分布式应用程序（distributed application），因为它们涉及多台相互交换数据的端系统。重要的是，因特网应用程序运行在端系统上，即它们并不运行在网络核心中的分组交换机中。尽管分组交换机促进端系统之间的数据交换，但它们并不关心作为数据的源或宿的应用程序。</p>
<p>与因特网相连的端系统提供了一个应用程序编程接口（Application Programming Interface，API），该API规定了运行在一个端系统上的软件请求因特网基础设施向运行在另一个端系统上的特定目的地软件交付数据的方式。因特网API是一套发送软件必须遵循的规则集合，因此因特网能够将数据交付给目的地。</p>
<blockquote>
<p>PS：关于什么是分组交换？什么是TCP/IP？什么是路由器？因特网正在使用什么样的通信链路？什么是分布式应用程序？一个烤箱或天气传感器怎样与因特网相连？将在后面解释这些重要的术语和问题。</p>
</blockquote>
<h1 id="3-什么是协议"><a href="#3-什么是协议" class="headerlink" title="3. 什么是协议"></a>3. 什么是协议</h1><p>下面考虑计算机网络中另一个重要的时髦术语：协议。什么是协议？协议是用来干什么的？</p>
<h2 id="3-1-人类活动的类比"><a href="#3-1-人类活动的类比" class="headerlink" title="3.1 人类活动的类比"></a>3.1 人类活动的类比</h2><p>我们先通过与某些人类活动进行类比，来更好的理解计算机网络协议的概念。考虑当你想要向某人询问时间的时候要怎么做？如图显示了一种典型的交互过程。人类协议要求一方首先进行问候，以开始和另一个人进行通信。对“你好”的典型响应是返回一个“你好”报文，隐含着你能继续向我询问时间。同样的，如果对我们回答“不要烦我”诸如此类的话则表示了一个勉强的或不能进行的通信。在这个情况下，按照人类协议，发话者也许不能够询问时间了。在某些时候，我们的“你好”得不到任何回答，那么，发话者通常会放弃向这个人询问时间。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20220112210944423.png" alt="image-20220112210944423"></p>
<p>如果人们使用了不同的协议（比如一个人讲礼貌，而另一个人不讲礼貌，或者一个人知道时间的概念，另一个不知道），该协议就不能互动，因而不能完成有用的工作。在网络中这个道理同样成立。即为了完成一项工作，要求两个（或多个）通信实体运行相同的协议。</p>
<h2 id="3-2-网络协议"><a href="#3-2-网络协议" class="headerlink" title="3.2 网络协议"></a>3.2 网络协议</h2><p> 网络协议类似于人类协议，除了交换报文和采取动作的实体是某些设备的硬件或软件组件。在因特网中，凡是涉及两个或多个远程通信实体的所有活动都受协议的制约。</p>
<p>我们以一个计算机网络协议为例，当你向一个Web服务器发出请求时所发生的情况。首先，你的计算机将向该Web服务器发送一条连接请求报文，并等待回答。该Web服务器将最终能接收到连接请求报文，并返回一条连接响应报文。得知请求该Web文档正常以后，计算机则在一条GET报文中发送要从这台Web服务器上取回的网页的名字。最后，Web服务器向计算机返回该Web网页（文件）。</p>
<p>从上面的例子中我们可以看见，报文的交换以及发送和接收这些报文时所采取的动作是定义一个协议的关键元素：</p>
<blockquote>
<p>一个<strong>协议</strong>定义了在两个或多个通信实体之间交换的报文格式和次序，以及报文发送和/接收一条报文或其它事件所采取的动作。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>最快最简单的排序——桶排序</title>
    <url>/2021/12/14/%E6%9C%80%E5%BF%AB%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E6%A1%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>生活中，排序可以说是无处不在。站队的时候会按身高排序，考试的时候按分数排序，购物的时候按价格排序……</p>
<p>我们来看一个具体需求：现在需要向控制台输入五个成绩（满分10分），并将成绩按从大到小排列后输出到控制台。（输入成绩5、3、5、2、8）</p>
<p>在这里我们只需要借助一个一维数组就可以解决问题。首先申请一个大小为11的数组 int arr[11]。刚开始的时候，我们将arr[0] ~ arr[10]都初始化为0，表示这些分数还都没有人得过。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211214203726463.png" alt="image-20211214203726463"></p>
<p>下面开始处理每个人的分数，第一个人5分，我们将相对应的a[5]的值在原来的基础上加一，即a[5] = 1，表示5分出现过一次。同理类似，最后得到下列结果：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211214203657932.png" alt="image-20211214203657932"></p>
<p>接下来，我们只需要将出现过的分数打印出来即可，出现几次打印几次，具体如下：</p>
<p>a[0] = 0，表示“0”没有出现过，不打印。</p>
<p>a[1] = 0，表示“1”没有出现过，不打印。</p>
<p>a[2] = 1，表示“2”出现过一次，打印2。</p>
<p>a[3] = 1，表示“3”出现过一次，打印3。</p>
<p>a[4] = 0，表示“4”没有出现过，不打印。</p>
<p>a[5] = 2，表示“5”出现过两次，打印5、5。</p>
<p>a[6] = 0，表示“6”没有出现过，不打印。</p>
<p>a[7] = 0，表示“7”没有出现过，不打印。</p>
<p>a[8] = 1，表示“8”出现过一次，打印8。</p>
<p>a[9] = 0，表示“9”没有出现过，不打印。</p>
<p>a[10] = 0，表示“10”没有出现过，不打印。</p>
<p>最终屏幕输出“2 3 5 5 8”，完整代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化数据</span></span><br><span class="line">  <span class="keyword">int</span> arr[<span class="number">11</span>];</span><br><span class="line">  <span class="keyword">int</span> i, j, t;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">    arr[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环读入五个成绩</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    arr[t]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将结果输出到控制台</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= arr[i]; j++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211214204358363.png" alt="image-20211214204358363"></p>
<p>这种排序方法暂且叫它”桶排序“。因为其实真正的桶排序要比这个复杂一点，目前这个算法已经能够满足我们的需求了。</p>
<p>这个算法就好比有11个桶，编号从0~10。每出现一个数，就在对应编号的桶中放一个小旗子，最后只要数一下每个桶中有几个小旗子就OK了。</p>
<p>这样，如果我们需要对数据范围在0~1000的整数进行排序，我们需要1001个桶，来表示0-1000之间每个数出现的次数。</p>
<p>现在来说一下时间复杂度的问题。代码中第8行的循环一共循环了m次（m为桶的个数），第13行的代码循环了n次（n为待排序数的个数），第19行和20行一共循环了m+n次。所以整个排序算法一共执行了m+n+m+n次。用大O表示该算法的时间复杂度为O(M+N)。</p>
<p>这是一个非常快的排序算法。桶排序从1956年就开始被使用，该算法的基本思想是由E.J.Issac和R.C.Singleton提出来的。然而，我们现在实现的并非真正的桶排序算法，真正的桶排序算法要比这个更加复杂！</p>
]]></content>
  </entry>
  <entry>
    <title>永远的HelloWorld</title>
    <url>/2021/12/14/%E6%B0%B8%E8%BF%9C%E7%9A%84HelloWorld/</url>
    <content><![CDATA[<p>毫无疑问，“HelloWorld”对于程序员来说简直是如雷贯耳。下面是一个C语言的HelloWorld程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于下面这些问题，你的脑子里能够马上反应出一个清晰又明确的答案吗？</p>
<ul>
<li>程序为什么要被编译器编译了之后才可以运行？</li>
<li>编译器在把C语言程序转换成可以执行的机器码的过程中做了什么，怎么做的？</li>
<li>最后编译出来的可执行文里面是什么？除了机器码还有什么？它们怎么存放的，怎么组织的？</li>
<li>/#include&lt;stdio.h&gt;是什么意思？把stdio.h包含进来意味着什么？C语言库又是什么？它怎么实现的？</li>
<li>不同的编译器（Microsoft VC、GCC）和不同的硬件平台（x86、SPARC、MIPS、ARM），以及不同的OS（Windows、Linux、UNIX、Solaris），最终编译出来的结果一样吗？为什么？</li>
<li>HelloWorld程序是怎么运行起来的？OS是怎么装载它的？它从哪儿开始执行，到哪儿结束？main函数之前发生了什么？main函数结束以后又发生了什么？</li>
<li>如果没有OS，HelloWorld可以运行吗？如果要在一台没有OS的机器上运行HelloWorld需要什么？应该怎么实现？</li>
<li>printf是怎么实现的？它为什么可以有不定数量的参数？为什么它能够在终端上输出字符串？</li>
<li>HelloWorld程序在运行时，它在内存中是什么样子的？</li>
</ul>
<p>在接下来的“程序员的自我修养”系列将逐个解决这些问题！</p>
<h2 id="1-万变不离其宗"><a href="#1-万变不离其宗" class="headerlink" title="1. 万变不离其宗"></a>1. 万变不离其宗</h2><p>对于系统程序开发者来说，计算机多如牛毛的硬件设备中，有三个部件最为关键，它们分别是<strong>中央处理器CPU、内存和I/O控制芯片</strong>，这三个部件几乎就是计算机的核心了；对于普通应用程序开发者来说，它们似乎除了要关心CPU以外，其它的硬件细节基本不用关心，对于一些高级平台的开发者来说，连CPU都不需要关心，因为这些平台为它们提供了一个通用的抽象的计算机，它们只要关心这个抽象的计算机就可以了。</p>
]]></content>
  </entry>
  <entry>
    <title>InnoDB存储引擎概述</title>
    <url>/2021/12/14/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>InnoDB存储引擎最早由Innobase Oy公司（06年被Oracle公司收购）开发，被包括在MySQL数据库所有的二进制发行版本中，从MySQL5.5版本开始是默认的表存储引擎（之前的版本InnoDB存储引擎仅在Windows下为默认的存储引擎）。该存储引擎是第一个完整支持ACID事务的MySQL存储引擎（BDB是第一个支持事务的MySQL存储引擎，现在已经停止开发），其特点是行锁设计、支持MVCC、支持外键、提供一致性非锁定读，同时被设计用来最有效地利用以及使用内存和CPU。</p>
<p>Heikki Tuuri是InnoDB存储引擎的创始人，和著名的Linux创始人Linus是芬兰赫尔辛基大学校友。在1990年获得了赫尔辛基大学的数学逻辑博士学位后，他于1995年成立Innobase Oy公司并担任CEO。</p>
<p>InnoDB存储引擎已经被许多大型网站使用，如用户熟知的Google、Facebook、YouTube，在网络游戏领域有魔兽世界、Second Life、神兵玄奇等。</p>
<p>从MySQL数据库的官方手册可得知，著名的Internet新闻站点Slashdot.org运行在InnoDB上。Mytrix、Inc在InnoDB上存储超过</p>
]]></content>
  </entry>
  <entry>
    <title>连接MySQL</title>
    <url>/2021/12/13/%E8%BF%9E%E6%8E%A5MySQL/</url>
    <content><![CDATA[<p>连接MySQL操作是一个连接进程和MySQL数据库实例进行通信。从程序设计的角度来说，<strong>本质上是进程通信</strong>。如果对进程通信比较了解，可以知道常用的进程通信方式有管道、命名管道、命名字、TCP/IP套接字、UNIX域套接字。MySQL数据库提供的连接方式从本质上看都是上述提及的进程通信方式。</p>
<h2 id="1-TCP-IP"><a href="#1-TCP-IP" class="headerlink" title="1. TCP/IP"></a>1. TCP/IP</h2><p>TCP/IP套接字方式是MySQL数据库在任何平台下都提供的连接方式，也是网络中使用的最多的一种方式。这种方式在TCP/IP连接上建立一个基于网络的连接请求，一般情况下客户端（client）在一台服务器上，而MySQL实例（server）在另一台服务器上，这两台机器通过一个TCP/IP网络连接。例如，用户可以在Windows服务器下请求一台远程Linux服务器下的MySQL实例，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211213234830324.png" alt="image-20211213234830324"></p>
<p>这里我连的localhost本地的MySQL，如果要连接远程服务器只需要把localhost改成对应IP。</p>
<p>这里需要注意的是，在通过TCP/IP连接到MySQL实例时，MySQL数据库会先检查一张权限视图，用来判断发起请求的客户端IP是否允许连接到MySQL实例。该视图在mysql架构下，表名为user，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211213235547816.png" alt="image-20211213235547816"></p>
<h2 id="2-命名管道和共享内存"><a href="#2-命名管道和共享内存" class="headerlink" title="2. 命名管道和共享内存"></a>2. 命名管道和共享内存</h2><p>在Windows 2000、Windows XP、Windows 2003和Windows Vista以及在此之上的平台上，如果两个需要进程通信的进程在同一台服务器上，那么可以使用命名管道，Microsoft SQL Server数据库默认安装后的本地连接也是使用命名管道。在MySQL数据库中须在配置文件中启用 –enable-named-pipe 选项。在MySQL4.1之后的版本中，MySQL还提供了共享内存的连接方式，这是通过在配置文件中添加 –shared-memory实现的。如果想使用共享内存的方式，在连接时，MySQL客户端还必须使用 –protocol=memory选项。</p>
<h2 id="3-UNIX域套接字"><a href="#3-UNIX域套接字" class="headerlink" title="3. UNIX域套接字"></a>3. UNIX域套接字</h2><p>在Linux和UNIX环境下，还可以使用UNIX域套接字。UNIX域套接字其实不是一个网络协议，所以只能在MySQL客户端和数据库实例在一台服务器上的情况下使用。用户可以在配置文件中指定套接字文件的路径，如 –socket=/tmp/mysql.sock。当数据库实例启动后 ，用户可以通过下列命令来进行UNIX域套接字文件的查找：</p>
<p>在知道了UNIX域套接字文件的路径后，就可以使用该方式进行连接了，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211214001744968.png" alt="image-20211214001744968"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -S /tmp/mysql.sock</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>工厂方法模式</title>
    <url>/2021/12/12/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>工厂方法模式定义了一个用户创建对象的接口，让子类决定实例化哪一个类。工厂方法模式使一个类的实例化延迟到其子类。</p>
<p>在看到工厂方法时可能有这样的疑问：</p>
<ul>
<li>为什么要创建一个对象的接口？</li>
<li>为什么要把类实例化延迟到其子类？</li>
</ul>
<p>我们看一个具体实例：比如某人有一个习惯，在睡前吃一个水果，无论什么水果都行。水果本身是一个抽象的概念，比如有苹果、葡萄等。此人的习惯是任意水果都行，所以它不关心是哪一种水果的具体实现，如果让他执行每晚固定吃水果的程序时都确定哪一种水果，这是不现实的，每天家里能有的水果是不可知的，这就是工厂方法模式要解决的问题。</p>
<p>在编程活动中，对于一个大型的软件工程，一个行之有效的方案就是进行模块式的分解。每一个模块由大量的代码构成，此模块的功能被其它模块使用，使用的方式就是：</p>
<ul>
<li>实例化此模块</li>
<li>调用此模块功能</li>
</ul>
<p>注意这两个步骤中的第一步，在复杂的应用中会产生严重的副作用。模块的接口虽然不易变，但是各种具体实现的类及其需求是经常变化的。比如编码客户端的时候设计的用户按钮是方形的，但是交付客户的时候客户的需求改成了圆形，程序中创建的按钮有数万个，更改程序时就成了非常麻烦的事。</p>
<p>以上各种情形下所出现的棘手问题都可以由工厂方法模式解决。</p>
<h2 id="1-商品上架遇到的问题"><a href="#1-商品上架遇到的问题" class="headerlink" title="1. 商品上架遇到的问题"></a>1. 商品上架遇到的问题</h2><p>超市中有很多种商品，每种商品上架时都需要合适的货架来摆放。</p>
<p>现在我们使用软件实现商品上架，在以下的设计中，基本思路是为商品选择货架，而不是为货架选择商品，这是根据需求决定的设计方式。商品上架的流程是先拿到商品对象，创建一个可以容纳的货架空间，最后讲商品放入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleShelf</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name  = <span class="string">&quot;普通货架类&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Goods goods)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 打印货架名，货架类信息，所放商品信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;(&quot;</span> + <span class="keyword">this</span> + <span class="string">&quot;)&quot;</span> + <span class="string">&quot;上摆放了：&quot;</span> + goods.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleShelfClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到商品</span></span><br><span class="line">        Goods goods = <span class="keyword">new</span> Goods(<span class="string">&quot;巧克力&quot;</span>);</span><br><span class="line">        <span class="comment">// 得到货架</span></span><br><span class="line">        SampleShelf shelf = <span class="keyword">new</span> SampleShelf();</span><br><span class="line">        <span class="comment">// 上架</span></span><br><span class="line">        shelf.put(goods);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到商品</span></span><br><span class="line">        Goods goods1 = <span class="keyword">new</span> Goods(<span class="string">&quot;方便面&quot;</span>);</span><br><span class="line">        <span class="comment">// 得到货架</span></span><br><span class="line">        SampleShelf shelf1 = <span class="keyword">new</span> SampleShelf();</span><br><span class="line">        <span class="comment">// 上架</span></span><br><span class="line">        shelf1.put(goods1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211213221122918.png" alt="image-20211213221122918"></p>
<p>从代码和结果可以看出，我们需要商品就实例化一个商品，需要货架就实例化一个货架，从结果也可以看出，两个商品分别取得了不同的货架进行存放。</p>
<p>但是我们设想一下在这个系统设计出来以后有可能发生的事情：</p>
<ul>
<li>货架的使用应该具有可复用性，即如果一个货架没有装满的话，还可以用来装其它的货物。由于使用程序来装货物，所以货物不应该知道货架的细节。</li>
<li>每一种货物所摆放的货架是有要求的，不能任意用一种货架。</li>
<li>当使用代码大量增加时，如果再想做统一的操作，将会增加大量代码。</li>
<li>未来将会增加货架的种类，在此系统中，增加货架的种类势必增加货架类和改变使用的代码，使用代码和特定的货架是紧密耦合的。</li>
</ul>
<p>由以上的研究可以发现，简单的设计在需求的复杂性提高了后会出现问题，而工厂方法模式就是解决创建类问题的一种方法。</p>
<h2 id="2-简单工厂模式"><a href="#2-简单工厂模式" class="headerlink" title="2. 简单工厂模式"></a>2. 简单工厂模式</h2><p>一个具体工厂通过条件语句创建多个产品，产品的创建逻辑集中在一个工厂类上。客户端通过传递不同的参数给工厂，实现创建不同产品的目的。增减新产品时，需要修改工厂类、增加产品类，这不符合OCP原则。</p>
<p>先看一下通常所见到的代码初步设计类图：</p>
<p><img src="C:/Users/pengbin007/AppData/Roaming/Typora/typora-user-images/image-20211213202048185.png" alt="image-20211213202048185"></p>
<p>这个图使用的结构类似于上面的商品上架的代码，这种设计所能造成的缺点我们已经讨论过了，下面看一下由此图进行的模式演化：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211213202557212.png" alt="image-20211213202557212"></p>
<p>由图可见，设计中加入了一个抽象的层次Auto类，加入此抽象层次的好处是显而易见的，它帮助架构降低了Client类和各种具体车型之间的耦合度，而且符合了开-闭原则，如果以后需要加入其它车型，设计将变得很容易。</p>
<p>但是，此设计的缺点也是存在的，它并没有将客户端的构建具体依赖对象的代码和客户端的使用代码完全分开，这样就会对扩展性和功能性设计造成麻烦，请思考以下问题：</p>
<ul>
<li>客户所用的任何一部车都需要在使用前登记。</li>
<li>如果Car类车型没有了，使用Truck车型替代。</li>
<li>公司的Car类车全部换为SuperCar。</li>
</ul>
<p>如果采用简单工厂模式，则可以解决以上问题，如图：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211213203646066.png" alt="image-20211213203646066"></p>
<p>图中各种元素如下：</p>
<ul>
<li>产品接口：Auto此接口用于描述各种具体的产品。</li>
<li>具体产品：Car、Bus、Truck。</li>
<li>静态工厂类：StaticFactory类中具有静态的工厂方法。</li>
<li>客户类：Client类调用静态工厂生产各种Auto的实现对象。</li>
</ul>
<p>具体代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用静态工厂创建对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Auto auto1 = StaticFactory.createAuto(<span class="number">1</span>);</span><br><span class="line">        auto1.run();</span><br><span class="line"></span><br><span class="line">        Auto auto2 = StaticFactory.createAuto(<span class="number">2</span>);</span><br><span class="line">        auto2.run();</span><br><span class="line"></span><br><span class="line">        Auto auto3 = StaticFactory.createAuto(<span class="number">4</span>);</span><br><span class="line">        auto3.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticFactory</span> <span class="keyword">extends</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Auto <span class="title">createAuto</span><span class="params">(<span class="keyword">int</span> autoId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(autoId) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Bus();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Truck();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;没有这种车型&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Auto</span> <span class="keyword">extends</span> <span class="title">StaticFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Auto</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setName(<span class="string">&quot;轿车&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;启动&quot;</span> + <span class="keyword">this</span>.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Auto</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setName(<span class="string">&quot;巴士&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;启动&quot;</span> + <span class="keyword">this</span>.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Truck</span> <span class="keyword">extends</span> <span class="title">Auto</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Truck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setName(<span class="string">&quot;卡车&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;启动&quot;</span> + <span class="keyword">this</span>.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211213204023931.png" alt="image-20211213204023931"></p>
<p>经过了以上的简单工厂模式的设计，可以发现它有以下几个方面的优点：</p>
<ol>
<li>用代码和具体使用类的耦合度降低。</li>
<li>令创建与使用的代码相分离，可以独立地变化，易于维护和扩展。</li>
<li>可以通过外部配置的方法将耦合度进一步降低。</li>
</ol>
<h2 id="3-工厂方法模式"><a href="#3-工厂方法模式" class="headerlink" title="3. 工厂方法模式"></a>3. 工厂方法模式</h2><p>简单工厂模式虽然有一定的优点，但是还是存在下面的不足：</p>
<ul>
<li><p>工厂实现的产品抽象，不具备复杂性。</p>
</li>
<li><p>工厂不具备抽象性。</p>
</li>
</ul>
<p>为了解决这些问题，GoF的设计模式中提出了工厂方法模式。解决方法就是将各种产品使用不同的工厂生产，各种工厂中的创建方法可以互相独立地改变，并将这些工厂类抽象出一个共同的父类，如下图：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211213210920006.png" alt="image-20211213210920006"></p>
<p>工厂方法和简单工厂的区别在于其对工厂也做了一层抽象，不同的工厂负责生产不同的产品。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用静态工厂创建对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Factory factory;</span><br><span class="line">        Auto auto;</span><br><span class="line"></span><br><span class="line">        factory = <span class="keyword">new</span> BusFactory();</span><br><span class="line">        auto = factory.createAuto();</span><br><span class="line">        auto.run();</span><br><span class="line"></span><br><span class="line">        factory = <span class="keyword">new</span> CarFactory();</span><br><span class="line">        auto = factory.createAuto();</span><br><span class="line">        auto.run();</span><br><span class="line"></span><br><span class="line">        factory = <span class="keyword">new</span> TruckFactory();</span><br><span class="line">        auto = factory.createAuto();</span><br><span class="line">        auto.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">extends</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> Auto <span class="title">createAuto</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Auto <span class="title">createAuto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Truck();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Auto <span class="title">createAuto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TruckFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Auto <span class="title">createAuto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211213211500428.png" alt="image-20211213211500428"></p>
<p>以上就是工厂方法模式的简单实现，分析其实现可以发现简单工厂模式的两种主要缺点已经被解决了，现在我们看工厂方法能实现而简单工厂不能实现的情况：</p>
<ul>
<li>对每一种生产出的产品实例做不同的操作。</li>
<li>增加一种完全不同类型的产品。</li>
<li>在不修改原有工厂类的情况下增加对新产品的支持。</li>
</ul>
<h2 id="4-使用工厂方法模式解决商品上架问题"><a href="#4-使用工厂方法模式解决商品上架问题" class="headerlink" title="4. 使用工厂方法模式解决商品上架问题"></a>4. 使用工厂方法模式解决商品上架问题</h2><p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211213214955812.png" alt="image-20211213214955812"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bed</span> <span class="keyword">extends</span> <span class="title">Goods</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.setName(<span class="string">&quot;双人床&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.setWidth(<span class="number">300</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shelf</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String shelfName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxWidth;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getShelfName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shelfName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShelfName</span><span class="params">(String shelfName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.shelfName = shelfName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxWidth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxWidth</span><span class="params">(<span class="keyword">int</span> maxWidth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxWidth = maxWidth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Goods goods)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;将&quot;</span> + goods.getName() + <span class="string">&quot;放入&quot;</span> + <span class="keyword">this</span>.getShelfName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallShelf</span> <span class="keyword">extends</span> <span class="title">Shelf</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SmallShelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.setShelfName(<span class="string">&quot;一种90cm的小货架&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.setMaxWidth(<span class="number">90</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigShelf</span> <span class="keyword">extends</span> <span class="title">Shelf</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BigShelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.setShelfName(<span class="string">&quot;一种200cm的大货架&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.setMaxWidth(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ShelfFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxWidth;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxWidth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxWidth</span><span class="params">(<span class="keyword">int</span> maxWidth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxWidth = maxWidth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> Shelf <span class="title">createShelf</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallShelfFactory</span> <span class="keyword">extends</span> <span class="title">ShelfFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SmallShelfFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.setMaxWidth(<span class="keyword">new</span> SmallShelf().getMaxWidth());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shelf <span class="title">createShelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SmallShelf();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigShelfFactory</span> <span class="keyword">extends</span> <span class="title">ShelfFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BigShelfFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.setMaxWidth(<span class="keyword">new</span> BigShelf().getMaxWidth());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shelf <span class="title">createShelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigShelf();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaceGoodsHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">placeGoods</span><span class="params">(Goods goods)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;ShelfFactory&gt; shelfFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        shelfFactories.add(<span class="keyword">new</span> SmallShelfFactory());</span><br><span class="line">        shelfFactories.add(<span class="keyword">new</span> BigShelfFactory());</span><br><span class="line"></span><br><span class="line">        Shelf shelf;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(ShelfFactory shelfFactory : shelfFactories) &#123;</span><br><span class="line">            <span class="keyword">if</span>(shelfFactory.getMaxWidth() &gt;= goods.getWidth()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    shelf = shelfFactory.createShelf();</span><br><span class="line">                    shelf.put(goods);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;没有找到符合&quot;</span> + goods.getName() + <span class="string">&quot;尺寸的货架&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Goods&gt; goods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        goods.add(<span class="keyword">new</span> Phone());</span><br><span class="line">        goods.add(<span class="keyword">new</span> TV());</span><br><span class="line">        goods.add(<span class="keyword">new</span> Bed());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;init already&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Goods good : goods) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                PlaceGoodsHelper.placeGoods(good);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;放置货物完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211213215148107.png" alt="image-20211213215148107"></p>
<p>到此，我们已经可以使用工厂方法模式完全解决商品上架的问题了，但是，由于篇幅原因，有一些因素没有完全考虑到，读者可以自行扩展。部分扩展如下：</p>
<ul>
<li>考虑一个货架可以放多个货物的情况。</li>
<li>考虑商品防止的优先级的问题。</li>
<li>考虑更多类型的货架，如不同的形状和材质的货架。</li>
<li>考虑货物体积与货架空间相互作用引发的最优化放置问题。</li>
</ul>
<p>完整代码见我的码云仓库：<a href="https://gitee.com/pengzong888/blog">https://gitee.com/pengzong888/blog</a></p>
<h2 id="5-工厂方法模式的使用范围"><a href="#5-工厂方法模式的使用范围" class="headerlink" title="5. 工厂方法模式的使用范围"></a>5. 工厂方法模式的使用范围</h2><ul>
<li>当客户程序不需要知道要使用对象的创建过程时。</li>
<li>客户程序使用的对象存在变动的可能，或者根本就不知道使用哪一个具体的对象时。</li>
<li>当客户想分离对象的创建和使用代码时。</li>
<li>当客户想集中管理创建代码时。</li>
<li>当客户需要使用的对象种类非常多，并且有扩展需求时。</li>
</ul>
<p>其优点在于分担了对象承受的压力，使结构变得灵活起来，并且符合开-闭原则。同样的可以看出工厂方法的加入，使得对象的数量成倍增长。当产品种类非常多时，会出现大量的与之对应的工厂对象，这不是我们希望的。</p>
<h2 id="6-简单工厂与其它模式的区别"><a href="#6-简单工厂与其它模式的区别" class="headerlink" title="6. 简单工厂与其它模式的区别"></a>6. 简单工厂与其它模式的区别</h2><ul>
<li>工厂方法模式与简单工厂模式在结构上的不同不是很明显。工厂方法模式的核心是一个抽象工厂类，而简单工厂模式把核心放在一个具体类上。</li>
<li>工厂方法模式之所以有一个别名叫多态性工厂模式是因为，具体工厂类都有共同的接口，或者有共同的抽象父类。</li>
<li>当系统扩展需要添加新的产品对象时，仅仅需要添加一个具体对象以及一个具体工厂对象，原有工厂对象不需要进行任何修改，也不需要修改客户端，这很好地符合了”开放——封闭“原则。而简单工厂模式在添加新产品对象后不得不修改工厂方法，扩展性不好。</li>
<li>工厂方法模式退化后可以演变成简单工厂模式。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>页面置换算法(下)</title>
    <url>/2021/12/12/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-%E4%B8%8B/</url>
    <content><![CDATA[<h2 id="1-工作集页面置换算法"><a href="#1-工作集页面置换算法" class="headerlink" title="1. 工作集页面置换算法"></a>1. 工作集页面置换算法</h2><p>在单纯的分页系统里，刚启动进程时，在内存中并没有页面。CPU试图取第一条指令时就会产生缺页中断，使OS装入含有第一条指令的页面。其它由访问全局数据和堆栈引起的缺页中断通常会紧接着发生。一段时间以后，进程需要的大部分页面已经在内存了，进程开始在较少缺页中断的情况下运行。这个策略称为<strong>请求调页</strong>（demand paging），因为页面是在需要时被调入的，而不是预先装入。</p>
<p>一个进程当前正在使用的页面的集合称为<strong>工作集</strong>（denning）。如果整个工作集都被装入到了内存中，那么进程在运行到下一运行阶段之前，不会产生很多缺页中断。若内存太小无法容纳下整个工作集，那么进程的运行过程中会产生大量的缺页中断，导致运行速度变得很缓慢，因为通常只需要几个纳秒就能执行完一条指令，而通常需要十毫米才能从磁盘上读入一个页面。若每执行几条指令程序就发生一次缺页中断，那么就称这个程序发生了<strong>颠簸</strong>。</p>
<p>在多道程序设计系统中，经常会把进程转移到磁盘上，这样可以让其它的进程有机会占有CPU。有一个问题是：<strong>当该进程再次调回来以后应该怎么办</strong>？从技术角度上讲，并不需要做什么。该进程会一直中断知道它的工作集全部被装入内存。然而，每次装入一个进程时都要产生多次缺页中断，速度显然太慢了，并且由于CPU需要几毫米时间处理一个缺页中断，因此有相当多的CPU时间也被浪费掉了。</p>
<p>所以不少分页系统都会设法跟踪进程的工作集，以确保在让进程运行以前，它的工作集就已在内存中了。该方法称为<strong>工作集模型</strong>，其目的在于大大减少缺页中断率。在进程运行前预先装入其工作集页面也称为<strong>预先调页</strong>。请注意工作集是随着时间变化的。</p>
<p>为了实现工作集模型，OS必须跟踪哪些页面在工作集中。通过这些信息可以直接推导出一个合理的页面置换算法：当发生缺页中断时，淘汰一个不在工作集中的页面。为了实现该算法，就需要一种精确的方法确定哪些页面在工作集中。根据定义，<strong>工作集就是最近k次内存访问所使用过的页面集合</strong>（有些设计者使用最近k次页面集合，但选择是任意的）。为了实现工作集算法，必须预先选定k的值，一定那选定某个值，每次内存访问之后，最近k次内存访问所使用过的页面的集合就是唯一的确定的了。</p>
<p>当然，有了工作集的定义并不意味着存在一种有效的方法能够在程序运行期间及时的计算出工作集，假设有一个长度为k的移位寄存器，每进行一次内存访问就把寄存器左移一位，并在最右端插入所访问过的页面号。理论上，当缺页中断发生时，读出移位寄存器并进行排序，然后删除重复页面，就是工作集了。但是，维护移位寄存器并在缺页中断时处理它所需的开销很大，因此该技术从来没有被使用过。</p>
<p>作为替代，可以使用几种近似的方法。一种常见的近似方法就是，不是向后找最近k次的内存访问，而是考虑其执行时间。例如，我们现在这样定义：工作集是过去10ms中的内存访问所用到的页面集合。实际上，这样的模型很适合并且更容易实现。要注意到，每个进程只计算它自己的执行时间。因此，如果一个进程在T时刻开始，在（T+100）ms的时刻使用了40msCPU时间，对工作集而言，它的时间就是40ms。一个进程从它开始执行到当前所实际使用的CPU时间总数通常称作<strong>当前实际运行时间</strong>。通过这个近似的方法，<strong>进程的工作集可以被称为在过去的t秒实际运行时间中它所访问过的页面的集合</strong>。</p>
<h2 id="2-工作集时钟页面置换算法"><a href="#2-工作集时钟页面置换算法" class="headerlink" title="2. 工作集时钟页面置换算法"></a>2. 工作集时钟页面置换算法</h2><h2 id="3-页面置换算法小结"><a href="#3-页面置换算法小结" class="headerlink" title="3. 页面置换算法小结"></a>3. 页面置换算法小结</h2>]]></content>
  </entry>
  <entry>
    <title>页面置换算法</title>
    <url>/2021/12/11/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>当发生缺页中断时，操作系统必须在内存中选择一个页面将其换出内存，以便为即将调入的页面腾出空间。如果要换出的页面在内存驻留期间已经被修改过，就必须把它写回磁盘以更新该页面在磁盘上的副本，如果没有，则不需要回写（磁盘上的副本就是最新的）。直接用调入的页面覆盖被淘汰的页面就可以了。</p>
<p>缺页中断发生时，虽然可以随机选择一个页面进行置换，但是如果我们每次选择的都是不常使用的页面可以提升系统性能（不用回写，并且能避免其在短时间内又被置换回来）。”页面置换“问题在计算机设计的其它领域中也同样发生。例如，多数计算机把最近使用过的32字节或64字节的存储块保存在一个或多个告诉缓存中。另外一个例子是Web服务器。服务器可以把经常访问的一些Web页面存放在存储器的高速缓存中。</p>
<h2 id="1-最优页面置换算法（OPT，Optimal）"><a href="#1-最优页面置换算法（OPT，Optimal）" class="headerlink" title="1. 最优页面置换算法（OPT，Optimal）"></a>1. 最优页面置换算法（OPT，Optimal）</h2><p>很容易就可以描述出最好的页面置换算法，虽然<strong>此算法不可能实现</strong>。该算法是这样工作的：在缺页中断发生时，有些页面在内存中，其中有一个页面将很快被访问，其它页面则可能要到10、100或1000条指令后才会被访问，每个页面都可以用在该页面首次被访问前所要执行的指令数作为标记。</p>
<p>最优页面置换算法规定应该置换标记最大的页面。如果一个页面在800万条指令内不会被使用，另外一个600万条，则置换前一个页面，从而把因需要调入这个页面而发生的缺页中断推迟到将来，越久越好。计算机也像人一样，希望把不愉快的事情尽可能往后拖延。</p>
<p>这个算法唯一的问题就是无法实现。当缺页中断发生时，<strong>OS无法知道各个页面下一次将在什么时候被访问</strong>。当然，通过首先在仿真程序上运行程序，跟踪所有页面的访问情况，然后在第二次运行时利用第一次收集的信息是可以实现的。<strong>用这种方式，可以通过最优页面置换算法对其它可实现算法的性能进行比较</strong>。如果OS达到的页面置换性能只比最优算法差1%，那么即使花费大量的精力来寻找更好的算法最多也只能换来1%的性能提高。</p>
<p>假定系统为某进程分配了三个物理块，并考虑有页面号引用串7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1。那么采用OPT算法时的情况如下表：</p>
<table>
<thead>
<tr>
<th align="center">访问页面</th>
<th>7</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>0</th>
<th>3</th>
<th>0</th>
<th>4</th>
<th>2</th>
<th>3</th>
<th>0</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>2</th>
<th>0</th>
<th>1</th>
<th>7</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td align="center">物理块1</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>2</td>
<td></td>
<td>2</td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td>7</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">物理块2</td>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td></td>
<td>0</td>
<td></td>
<td>4</td>
<td></td>
<td></td>
<td>0</td>
<td></td>
<td></td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">物理块3</td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
<td></td>
<td>3</td>
<td></td>
<td>3</td>
<td></td>
<td></td>
<td>3</td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">缺页否</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>缺页率：45%</p>
<h2 id="2-最近未使用页面置换算法（NRU，Not-Recently-Used）"><a href="#2-最近未使用页面置换算法（NRU，Not-Recently-Used）" class="headerlink" title="2. 最近未使用页面置换算法（NRU，Not Recently Used）"></a>2. 最近未使用页面置换算法（NRU，Not Recently Used）</h2><p>为了让OS能够收集有用的统计信息，在大部分具有虚拟内存的计算机中，系统为每一页面设置了两个状态位。当页面被访问（读或写）时设置R位；当页面被写入（即修改）时设置M位。这些位包含在页表项中，每次访问内存时更新这些位，因此由硬件来设置这些位是必要的。</p>
<p>如果硬件没有这些位，可以用OS的缺页中断和时钟中断机制进行以下的模拟：当启动一个进程时，将其所有的页面都标记为不在内存中；一旦访问任何一个页面都会引发一次缺页中断，此时OS就可以设置R位，修改页表项使其指向正确的页面，并设为READ ONLY模式。然后重新启动引起缺页中断的指令；如果随后对该页面的修改又引起了缺页中断，则OS设置这个页面的M位，并将其改为READ/WRITE模式。</p>
<p>可以用R位和M位来构造一个简单的页面置换算法：当启动一个进程时，它的所有页面的两个位都由OS设为0，R位被定期清零（比如在每次时钟中断时），以区别最近没有被访问的页面和被访问的页面。</p>
<p>当发生缺页中断时，OS检查所有的页面并根据它们当前的R位和M位的值，将它们分成以下四类：</p>
<ul>
<li>第0类：没有被访问，没有被修改</li>
<li>第1类：没有被访问，已经被修改</li>
<li>第2类：已经被访问，没有被修改</li>
<li>第3类：已经被访问，已经被修改</li>
</ul>
<p>尽管第1类看起来似乎不可能，但是一个第3类的页面在它的R位被时钟中断清零后就成了第1位。时钟中断不清零M位是因为在决定一个页面是否要写回磁盘需要用到这个位。</p>
<p>NRU算法随机地从类编号最小的非空类中挑选一个页面淘汰。这个算法隐含的意思是，在最近一个时钟滴答中淘汰一个没有被访问的已修改页面要比淘汰一个被频繁使用的”干净“页面好。NRU的主要优点是易于理解和能够有效地被实现，虽然它的性能不是最好的，但是已经够用了。</p>
<h2 id="3-先进先出页面置换算法（FIFO）"><a href="#3-先进先出页面置换算法（FIFO）" class="headerlink" title="3. 先进先出页面置换算法（FIFO）"></a>3. 先进先出页面置换算法（FIFO）</h2><p>由OS维护一个所有当前在内存中的页面的链表，最新进入的页面放在表尾，最早的放在表头。当发生缺页中断时，淘汰表头的页面并把新调入的页面加到表尾。</p>
<table>
<thead>
<tr>
<th align="center">访问页面</th>
<th>7</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>0</th>
<th>3</th>
<th>0</th>
<th>4</th>
<th>2</th>
<th>3</th>
<th>0</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>2</th>
<th>0</th>
<th>1</th>
<th>7</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td align="center">物理块1</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>2</td>
<td></td>
<td>2</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>0</td>
<td></td>
<td></td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
<td>7</td>
<td>7</td>
<td>7</td>
</tr>
<tr>
<td align="center">物理块2</td>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td></td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td align="center">物理块3</td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
<td></td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>3</td>
<td></td>
<td></td>
<td>3</td>
<td>2</td>
<td></td>
<td></td>
<td>2</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td align="center">缺页否</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<p>缺页率：75%</p>
<h2 id="4-第二次机会页面置换算法"><a href="#4-第二次机会页面置换算法" class="headerlink" title="4. 第二次机会页面置换算法"></a>4. 第二次机会页面置换算法</h2><p>FIFO算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：检查最老页面的R位。如果R位是0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是1，就将R位清零，并把该页面放到链表尾端，然后继续搜索。这就是第二次机会算法。</p>
<p>第二次机会算法就是寻找一个在最近的时钟间隔内没有被访问过的页面。如果所有的页面都被访问过了，该算法就简化为纯粹的FIFO算法。</p>
<h2 id="5-时钟页面置换算法（CLOCK）"><a href="#5-时钟页面置换算法（CLOCK）" class="headerlink" title="5.时钟页面置换算法（CLOCK）"></a>5.时钟页面置换算法（CLOCK）</h2><p>尽管第二次机会算法是一个比较合理的算法，但它经常要在链表中移动页面，既降低了效率又不是很有必要。一个更好的办法是<strong>把所有的页面都保存在一个类似钟面的环形链表中</strong>，一个表针指向最老的页面。当发生缺页中断时，算法首先检查表针指向的页面，如果它的R为是0就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；如果是1就清除R为并把表针前移一个位置。重复这个过程知道找到了一个R位为0的页面为止。这就是时钟算法。</p>
<h2 id="6-最近最少使用页面置换算法（LRU）"><a href="#6-最近最少使用页面置换算法（LRU）" class="headerlink" title="6.最近最少使用页面置换算法（LRU）"></a>6.最近最少使用页面置换算法（LRU）</h2><p>对最优算法的一个很好的近似是基于这样的观察：在前面几条指令中频繁使用的页面很可能在后面的几条指令中被使用。反过来说，已经很久没有使用的页面很有可能在未来较长一段时间内仍然不会被使用。这一思想提示了一个可实现的算法：<strong>在缺页中断时，置换未使用时间最长的页面</strong>。这一策略称为LRU（Least Recently Used）页面置换算法。</p>
<p>虽然LRU在理论上可以实现，但代价很高。为了完全实现LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的在表尾。困难的是在每次访问内存时都必须更新整个链表。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常耗时的操作，即使使用硬件实现也一样费时（假设有这样的硬件）。</p>
<table>
<thead>
<tr>
<th align="center">访问页面</th>
<th>7</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>0</th>
<th>3</th>
<th>0</th>
<th>4</th>
<th>2</th>
<th>3</th>
<th>0</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>2</th>
<th>0</th>
<th>1</th>
<th>7</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td align="center">物理块1</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>2</td>
<td></td>
<td>2</td>
<td></td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>0</td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td>1</td>
<td></td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">物理块2</td>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td></td>
<td>0</td>
<td></td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>3</td>
<td></td>
<td></td>
<td>3</td>
<td></td>
<td>0</td>
<td></td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">物理块3</td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
<td></td>
<td>3</td>
<td></td>
<td>3</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td>2</td>
<td></td>
<td>7</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">缺页否</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>缺页率：60%</p>
<p>还是有一些使用特殊硬件实现LRU的方法。首先考虑一个最简单的方法，这个方法要求硬件有一个64位计数器C，它在每条指令执行完后自动加1，每个页表项必须有一个足够容纳这个计数器值的域。在每次访问内存后，将当前的C值保存到被访问页面的页表项中。一旦发生缺页中断，OS就检查所有页表项中计数器的值，找到值最小的一个页面，这个页面就是最近最少使用的页面。</p>
<h2 id="7-用软件模拟LRU"><a href="#7-用软件模拟LRU" class="headerlink" title="7. 用软件模拟LRU"></a>7. 用软件模拟LRU</h2><p>LRU算法在理论上可以实现的，但是在实际操作中的硬件很难实现。因此，我们希望能用一种软件的方式来实现，这就是<strong>NFU（Not Frequently Used，最不常用）算法。该算法将每一个页面与一个初值为0的软件计数器相关联，每次时钟中断时，由OS扫描内存中所有页面，将每个页面的R位加到它的计数器上。这个计数器大体上跟踪了每个页面被访问的频繁程度。发生缺页中断时，则置换计数器值最小的页面</strong>。</p>
<p>NFU的主要问题是它从来不忘记任何事情。比如，在一个多次(扫描)编译器中，第一次被频繁使用的页面在程序进入第二次扫描的时候，其计数器的值可能依旧很高。实际上，如果第一次扫描的执行时间恰好是各次扫描中最长的，含有以后各次扫描代码的页面的计数器可能总是比含有第一次扫描代码的页面的计数器小，结果是OS将置换有用的页面而不是不再使用的页面。</p>
<p>幸运的是只要最一点修改就能很好的模拟LRU。其修改分为两部分：首先，在R位被加进之前先将计数器右移一位，其次；将R位加到计数器最左端而不是最右端。修改以后的<strong>老化（aging）算法</strong>，下图解释了它是如何工作的。假设在第一个时钟滴答后，页面0~5的R位的值分别是1、0、1、0、1、1。换句话说，在时钟滴答0到时钟滴答1之间，访问了页0、2、4、5，它们的R位设置为1，而其他的设为0。对应的6个计数器右移并把R位插入左端后的值如图(a)所示。</p>
<p><img src="C:/Users/pengbin007/AppData/Roaming/Typora/typora-user-images/image-20211212002429361.png" alt="image-20211212002429361"></p>
<p>发生缺页中断时，将置换计数器值最小的页面。如果一个页面在前面4个时钟滴答中都没有访问过，那么它的计数器最前面应该有4个连续的0，因此它的值肯定要比在前面三个时钟滴答中都没有被访问过的页面的计数器小。</p>
<p>该算法与LRU由两个区别。如图e中的页面3和5，它们都连续两个时钟滴答没有被访问过了，而在这两个时钟滴答之前都被访问过了。根据LRU，如果必须置换一个页面，则应该二选一。但是，我们不知道在时钟滴答1到时钟滴答2期间它们中的哪个页面是后被访问到的。因为在每个时钟滴答中只记录了一位，所以无法区分在一个时钟滴答中哪个页面在较早的时间被访问哪个较晚，因此，我们所能做的就是置换页面3，原因是页面5在更往前的两个时钟滴答中也被访问过而3没有。</p>
<p>LRU和老化算法的第二个区别是老化算法的计数器只有有限位数（本例中是8位），这就限制了其对以往页面的记录。如果两个页面的计数器都是0，我们只能在两个页面中随机选一个进行置换。实际上，有可能其中一个页面上次被访问是在9个时钟滴答以前，另一个页面是在1000个时钟滴答以前，而我们却无法看到这些。在实践中，如果时钟滴答是20ms，8位一般是够用的。加入一个页面已经有160ms没有被访问过，那么它可能并不重要。</p>
]]></content>
  </entry>
  <entry>
    <title>指令级并行原理</title>
    <url>/2021/12/11/%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="1-名词"><a href="#1-名词" class="headerlink" title="1. 名词"></a>1. 名词</h2><h3 id="Clock-Cycle-Time"><a href="#Clock-Cycle-Time" class="headerlink" title="Clock Cycle Time"></a>Clock Cycle Time</h3>]]></content>
  </entry>
  <entry>
    <title>Java线程</title>
    <url>/2021/12/11/Java%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="1-创建和运行线程"><a href="#1-创建和运行线程" class="headerlink" title="1. 创建和运行线程"></a>1. 创建和运行线程</h2>]]></content>
  </entry>
  <entry>
    <title>进程 &amp; 线程</title>
    <url>/2021/12/10/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h2><p>进程是程序的依次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程——生命周期。</p>
<ul>
<li>程序由指令和数据组成，但这些指令要允许，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令允许过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理IO的。</li>
<li>当一个程序被允许，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li>
<li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程，也有的程序只能启动一个实例进程。</li>
<li><strong>进程作为资源分配的单位</strong>，系统在运行时会为每个进程分配不同的内存区域。</li>
</ul>
<h2 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h2><ul>
<li>一个进程内可以分为一到多个进程。</li>
<li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行。</li>
<li>若一个进程同一时间并行执行多个线程，就是支持多线程的。</li>
<li><strong>线程作为调度和执行的单位</strong>，每个线程拥有独立的运行栈和程序计数器，线程切换的开销小。</li>
<li>一个进程中的多个线程共享相同的内存单元/内存地址空间——它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。</li>
<li>在windows中进程是不活动的，只是作为线程的容器。</li>
</ul>
<h2 id="进程-amp-线程"><a href="#进程-amp-线程" class="headerlink" title="进程 &amp; 线程"></a>进程 &amp; 线程</h2><ul>
<li>线程基本上相互独立的，而线程存在于进程内，是进程的一个子集。</li>
<li>进程拥有共享的资源，如内存空间等，供其内部的线程共享。</li>
<li>进程间通信较为复杂：<ul>
<li>同一台计算机的进程通信称为IPC（Inter-precess communication）。</li>
<li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如HTTP。</li>
</ul>
</li>
<li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量。</li>
<li>线程更轻量，线程上下文切换成本一般要比进程上下文切换你低。</li>
</ul>
<h2 id="3-并行-amp-并发"><a href="#3-并行-amp-并发" class="headerlink" title="3. 并行 &amp; 并发"></a>3. 并行 &amp; 并发</h2><h3 id="3-1-单核CPU和多核CPU的理解"><a href="#3-1-单核CPU和多核CPU的理解" class="headerlink" title="3.1 单核CPU和多核CPU的理解"></a>3.1 单核CPU和多核CPU的理解</h3><ul>
<li>单核CPU：其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果有某个人不想交钱，那么收费人员可以把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费）。但是因为CPU时间单元特别短，因此感觉不出来。</li>
<li>如果是多核的话，才能更好的发挥出多线程的效率。</li>
<li>一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。</li>
</ul>
<h3 id="3-2-并行"><a href="#3-2-并行" class="headerlink" title="3.2 并行"></a>3.2 并行</h3><p>所谓并行，就是指多个CPU同时执行多个任务。单核CPU下，线程实际上还是<strong>串行执行</strong>的。操作系统中有个组件叫做任务调度器，将CPU的时间片分给不同的程序使用，只是由于CPU在线程之间的切换非常快，人类感觉是<strong>同步运行</strong>的。总结为一句话就是：<strong>微观串行，宏观并行</strong>。</p>
<h3 id="3-3-并发"><a href="#3-3-并发" class="headerlink" title="3.3 并发"></a>3.3 并发</h3><p>并发就是一个CPU（采用时间片）同时执行多个任务。比如：秒杀、多个人做同一件事。</p>
<p>并发是同一时间应对多件事情的能力，而并行是同一时间动手做多件事情的能力。</p>
<h2 id="4-应用"><a href="#4-应用" class="headerlink" title="4. 应用"></a>4. 应用</h2><h3 id="4-1-异步调用"><a href="#4-1-异步调用" class="headerlink" title="4.1 异步调用"></a>4.1 异步调用</h3><p>以调用方角度来讲，如果：</p>
<ul>
<li>需要等待结果返回，才能继续运行就是同步</li>
<li>不需要等待结果返回，就能继续运行就是异步</li>
</ul>
<p>多线程可以让方法执行变为异步的，比如说读取磁盘文件时，假设读取操作花费了5秒钟，如果没有线程调度机制的话，在这5秒内CPU被占用，不能处理其它事情，导致其它代码都得暂停。</p>
<p>Tomcat的异步servlet，它让用户线程处理耗时较长的操作，避免阻塞Tomcat的工作线程。</p>
<h3 id="5-2-提高效率"><a href="#5-2-提高效率" class="headerlink" title="5.2 提高效率"></a>5.2 提高效率</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gantt</span><br><span class="line">        dateFormat  </span><br><span class="line">        title 单道运行时三道程序时间关系图</span><br><span class="line">        section A</span><br><span class="line">        计算                      :2021-09-16,20d</span><br><span class="line">        I/O操作					: 30d</span><br><span class="line">        计算						: 10d</span><br><span class="line">    	section B</span><br><span class="line">    	</span><br><span class="line">        计算                      : 30d</span><br><span class="line">        I/O操作					: 50d</span><br><span class="line">        计算						: 20d</span><br><span class="line">    	section C</span><br><span class="line">        计算                      : 10d</span><br><span class="line">        I/O操作					: 20d</span><br><span class="line">        计算						: 10d</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gantt</span><br><span class="line">        dateFormat  </span><br><span class="line">        title 多道运行时三道程序时间关系图</span><br><span class="line">        section A</span><br><span class="line">        I/O操作					: 2021-09-16,30d</span><br><span class="line">        计算                      : 20d</span><br><span class="line">        计算						: 10d</span><br><span class="line">    	section B	</span><br><span class="line">        计算                      : 2021-09-16,30d</span><br><span class="line">        I/O操作					: 50d</span><br><span class="line">        计算						: 20d</span><br><span class="line">    	section C</span><br><span class="line">        计算						: 2021-11-15,10d</span><br><span class="line">        计算                      : 10d</span><br><span class="line">        I/O操作					: 20d</span><br></pre></td></tr></table></figure>

<p>单核CPU下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用CPU，不至于一个线程总是占用CPU，别的线程没法干活。</p>
<p>而在多核CPU中可以并行跑多个线程，但能否提高程序运行效率还是要分情况的：</p>
<ul>
<li>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分。</li>
<li>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义。</li>
</ul>
<p>IO操作不占用CPU，只是我们一般拷贝文件使用的阻塞IO，这是相当于线程虽然不用CPU，但需要一直等待IO结束，没能充分利用线程。所有才有后面的非阻塞IO和异步IO优化。</p>
]]></content>
  </entry>
  <entry>
    <title>乐观锁 &amp; 悲观锁</title>
    <url>/2021/12/10/%E4%B9%90%E8%A7%82%E9%94%81-%E6%82%B2%E8%A7%82%E9%94%81/</url>
    <content><![CDATA[<blockquote>
<p>乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能以偏概全的说一种人好于另外一种人。</p>
</blockquote>
<h2 id="1-两种锁的使用场景"><a href="#1-两种锁的使用场景" class="headerlink" title="1. 两种锁的使用场景"></a>1. 两种锁的使用场景</h2><ul>
<li><p><strong>悲观锁</strong></p>
<p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁、表锁、读锁、写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁的实现。</p>
</li>
<li><p><strong>乐观锁</strong></p>
<p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断以下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量。像数据库提供的write_condition机制，其实就是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p>
</li>
</ul>
<p>乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，所以一般多写场景下用悲观锁。</p>
<h2 id="2-乐观锁常见的两种实现方式"><a href="#2-乐观锁常见的两种实现方式" class="headerlink" title="2. 乐观锁常见的两种实现方式"></a>2. 乐观锁常见的两种实现方式</h2><h3 id="2-1-版本号机制"><a href="#2-1-版本号机制" class="headerlink" title="2.1 版本号机制"></a>2.1 版本号机制</h3><p>一般是在数据库表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<h3 id="2-2-CAS算法"><a href="#2-2-CAS算法" class="headerlink" title="2.2 CAS算法"></a>2.2 CAS算法</h3><p>即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数：</p>
<ul>
<li>需要读写的内存值 V</li>
<li>进行比较的值 A</li>
<li>拟写入的新值 B</li>
</ul>
<p>当且仅当V的值等于A时，CAS通过原子方式用新值来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</p>
<h2 id="3-乐观锁的缺点"><a href="#3-乐观锁的缺点" class="headerlink" title="3. 乐观锁的缺点"></a>3. 乐观锁的缺点</h2><h4 id="3-1-ABA问题"><a href="#3-1-ABA问题" class="headerlink" title="3.1 ABA问题"></a>3.1 ABA问题</h4><p>ABA问题是乐观锁一个常见的问题。如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它依然是A值，那我们就一定能说明它的值没有被其它线程修改过吗?</p>
<p>很明显这是不能保证的。因为在这段时间它的值可能被其它线程改为其它值，然后又改回A，那么CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的”ABA“问题。JDK1.5以后的AtomicStampedReference类就提供了这种能力，其中的compareAndSet方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211210142529751.png" alt="image-20211210142529751"></p>
<h4 id="3-2-循环时间开销大"><a href="#3-2-循环时间开销大" class="headerlink" title="3.2 循环时间开销大"></a>3.2 循环时间开销大</h4><p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令由两个作用，第一它可以延迟流水线执行指令（de-pipeline），使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>
<h4 id="3-3-只能保证一个共享变量的原子操作"><a href="#3-3-只能保证一个共享变量的原子操作" class="headerlink" title="3.3 只能保证一个共享变量的原子操作"></a>3.3 只能保证一个共享变量的原子操作</h4><p>CAS只对单个共享变量有效，当操作涉及跨多个共享变量时CAS无效。但是从JDK1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并称一个共享变量来操作。</p>
<h2 id="4-CAS与synchronized的使用场景"><a href="#4-CAS与synchronized的使用场景" class="headerlink" title="4.CAS与synchronized的使用场景"></a>4.CAS与synchronized的使用场景</h2><p>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般比较多）</p>
<p>对于资源竞争较少的情况，使用synchronized同步锁进行线程阻塞、唤醒切换以及用户态内核态间的切换操作额外浪费、消耗CPU资源；而CAS基于硬件实现、不需要进入内核、不需要切换线程、操作自旋几率较少，因此可以获得更高的性能。</p>
<p>对于资源竞争严重的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</p>
<blockquote>
<p>补充：Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为”<strong>重量级锁</strong>“。但是，在Java1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的<strong>偏向锁</strong>和<strong>轻量级锁</strong>以及其它<strong>各种优化</strong>之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠Lock-Free的队列，基本思路是：<strong>自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量</strong>。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突的情况下，性能远高于CAS。</p>
</blockquote>
<h2 id="5-使用MyBatisPlus乐观锁插件"><a href="#5-使用MyBatisPlus乐观锁插件" class="headerlink" title="5. 使用MyBatisPlus乐观锁插件"></a>5. 使用MyBatisPlus乐观锁插件</h2><h3 id="5-1-主要适用场景"><a href="#5-1-主要适用场景" class="headerlink" title="5.1 主要适用场景"></a>5.1 主要适用场景</h3><p>当要更新一条记录的时候，希望这条记录没有被别人更新。</p>
<p>实现方式：</p>
<ul>
<li>取出记录时，获取当前version</li>
<li>更新时，带上这个version</li>
<li>执行更新时，set version = newVersion where version = oldVersion</li>
<li>如果version不对，就更新不对</li>
</ul>
<h3 id="5-2-插件配置"><a href="#5-2-插件配置" class="headerlink" title="5.2 插件配置"></a>5.2 插件配置</h3><p>Spring XML：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.baomidou.mybatisplus.extension.plugins.OptimisticLockerInterceptor&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring Boot：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OptimisticLockerInterceptor <span class="title">optimisticLockerInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> OptimisticLockerInterceptor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-注解实体字段"><a href="#5-3-注解实体字段" class="headerlink" title="5.3 注解实体字段"></a>5.3 注解实体字段</h3><p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211210150455245.png" alt="image-20211210150455245"></p>
<p>需要为实体字段添加@Version注解（对应表中要有对应version字段）</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211210144526594.png" alt="image-20211210144526594"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Version</span></span><br><span class="line"><span class="keyword">private</span> Integer version;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-特别说明"><a href="#5-4-特别说明" class="headerlink" title="5.4 特别说明"></a>5.4 特别说明</h3><ul>
<li>支持的数据类型只有：int、Integer、long、Long、Date、Timestamp、LocalDateTime。</li>
<li>整数类型下newVersion = oldVersion + 1；</li>
<li>newVersion会回到entity中。</li>
<li>仅支持updateById(id)与update(entity, wrapper)方法。</li>
<li>在update(entity, wrapper)方法下，wrapper不能复用。</li>
</ul>
<h2 id="6-模拟CAS算法"><a href="#6-模拟CAS算法" class="headerlink" title="6. 模拟CAS算法"></a>6. 模拟CAS算法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCompareAndSwap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> CompareAndSwap cas = <span class="keyword">new</span> CompareAndSwap();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="keyword">int</span> expectedValue = cas.get();</span><br><span class="line">					<span class="keyword">boolean</span> b = cas.compareAndSet(expectedValue, (<span class="keyword">int</span>)(Math.random() * <span class="number">101</span>));</span><br><span class="line">					System.out.println(b);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompareAndSwap</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取内存值</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//比较</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">compareAndSwap</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> oldValue = value;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(oldValue == expectedValue)&#123;</span><br><span class="line">			<span class="keyword">this</span>.value = newValue;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> oldValue;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//设置</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> expectedValue == compareAndSwap(expectedValue, newValue);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Java中的锁——Lock接口和队列同步器</title>
    <url>/2021/12/09/Java%E4%B8%AD%E7%9A%84%E9%94%81%E2%80%94%E2%80%94Lock%E6%8E%A5%E5%8F%A3%E5%92%8C%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8/</url>
    <content><![CDATA[<h2 id="1-Lock接口"><a href="#1-Lock接口" class="headerlink" title="1. Lock接口"></a>1. Lock接口</h2><p>锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（有些锁允许并发访问，比如读写锁）。在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而Java5之后，并发包中新增了Lock接口用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式的获取和释放锁。虽然它缺少了隐式获取释放锁的便捷性，但是却拥有了锁获取和释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211210072342912.png" alt="image-20211210072342912"></p>
<p>看一个简单的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>锁也是一种资源，所以它的释放我们放在finally中，确保最终能够被释放。同时，防止锁被无故释放（放在try中，如果发生异常，在异常抛出的同时，也会导致锁无故释放）。</p>
<p>Lock接口提供的synchronized关键字所不具备的主要特性如下表：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>尝试非阻塞地获取锁</td>
<td>当前线程尝试获取锁，如果这一时刻锁没有被其它线程获取到，则成功获取并持有锁</td>
</tr>
<tr>
<td>能被中断地获取锁</td>
<td>与synchronized不同，获取到锁的线程能够被响应中断，当获取到锁的线程被中断时，中断异常将会别抛出，同时锁会被释放</td>
</tr>
<tr>
<td>超时获取锁</td>
<td>在指定的截止时间之前获取锁，如果截止时间到了仍旧无法获取锁，则返回</td>
</tr>
</tbody></table>
<p>Lock是一个接口，它定义了获取和释放锁的基本操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取锁，调用该方法当前线程将会获取锁，当锁获得后，从该方法返回</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 可以中断地获取锁，和lock()方法不同之处在于该方法会响应中断，即在锁的获取中可以中断当前线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">// 尝试非阻塞的获取锁，调用该方法后立刻返回，如果能够获取则返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 超时的获取锁，当前线程在以下三种情况下会返回：</span></span><br><span class="line"><span class="comment">// ①当前线程在超时时间内获得了锁</span></span><br><span class="line"><span class="comment">// ②当前线程在超时时间内被中断（抛异常InterruptedException）</span></span><br><span class="line"><span class="comment">// ③超时时间结束，返回false</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取等待通知组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件的wait()方法，而调用后，当前线程将释放锁</span></span><br><span class="line"><span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>Lock接口的实现基本都是通过聚合了一个同步器的子类来完成线程访问控制的。</p>
<h2 id="2-队列同步器"><a href="#2-队列同步器" class="headerlink" title="2. 队列同步器"></a>2. 队列同步器</h2><p>队列同步器AbstractQueuedSynchronizer(以下简称同步器)，是用来构建锁或者其它同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211210082331997.png" alt="image-20211210082331997"></p>
<p>同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。而子类推荐被定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211210084125565.png" alt="image-20211210084125565"></p>
<p>同步器是实现锁的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解二者之间的关系：锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。</p>
<h3 id="2-1-队列同步器的接口与示例"><a href="#2-1-队列同步器的接口与示例" class="headerlink" title="2.1 队列同步器的接口与示例"></a>2.1 队列同步器的接口与示例</h3><p>重写同步器指定方法时，需要使用同步器提供的如下3个方法来访问或修改同步状态：</p>
<blockquote>
<p>getState()：获取当前同步状态。</p>
<p>setState()：设置当前同步状态。</p>
<p>compareAndSetState(int expect, int update)：使用CAS设置当前状态，该方法能够保证状态设置的原子性。</p>
</blockquote>
<p>同步器可重写的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 独占式获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后再进行CAS设置同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 共享式获取同步状态，返回大于等于0的值，表示获取成功，反之，获取失败</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 共享式释放同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现自定义同步组件时，将会调用同步器提供的模板方法，部分方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 独占式获取同步状态，如果当前线程获取成功，则由该方法返回，否则，将会进入同步队列等待，该方法将会调用重写的tryAcquire(int arg)方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 与acquire(int arg)相同，但是该方法响应中断，当前线程未获取到同步状态而进入同步队列中，如果当前线程别中断，则该方法会抛出InterruptedException并返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 在acquireInterruptibly(int arg)基础上增加了超时限制，如果当前线程在超时时间内没有获取到同步状态，那么将会返回false，如果获取到了返回true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 独占式的释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式获取的主要区别是在同一时刻可以有多个线程获取到同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 与acquireShared(int arg)相同，该方法响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 在acquireSharedInterruptibly(int arg)基础上增加了超时限制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 共享式的释放同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 获取等待在同步队列上的线程集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>同步器提供的模板方法基本上分为3类：独占式获取与释放同步状态、共享式获取与释放同步状态和查询同步队列中的等待线程情况。自定义同步组件将使用同步器提供的模板方法来实现自己的同步语义。</p>
<p>我们先看一个独占锁的示例：</p>
]]></content>
  </entry>
  <entry>
    <title>Java内存模型的基础</title>
    <url>/2021/12/09/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>Java线程之间的通信对程序员完全透明，内存可见性问题很容易困扰Java程序员。</p>
<h2 id="1-并发编程模型的两个关键问题"><a href="#1-并发编程模型的两个关键问题" class="headerlink" title="1. 并发编程模型的两个关键问题"></a>1. 并发编程模型的两个关键问题</h2><ul>
<li><p>线程之间如何通信</p>
<p>通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。</p>
<p>在共享内存的并发模型里，线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过发送消息来显式进行通信。</p>
</li>
<li><p>线程之间如何同步</p>
<p>同步是指程序中用于控制不同线程间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p>
</li>
</ul>
<p>Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，这个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p>
<h2 id="2-Java内存模型的抽象结构"><a href="#2-Java内存模型的抽象结构" class="headerlink" title="2. Java内存模型的抽象结构"></a>2. Java内存模型的抽象结构</h2><p>在Java中，所有实例域、静态域和数组元素都存储在堆内存中，对内存在线程之间共享(下面用共享变量代指三者)。局部变量，方法定义参数和异常处理器参数不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p>
<p>Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都由一个私有的本地内存，本地内存中存储该线程已读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其它的硬件和编译器优化。Java内存模型的抽象示意图：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211209193054163.png" alt="image-20211209193054163"></p>
<p>从图中来看，如果线程A和线程B之间要通信的话，必须要经历下面两个步骤。</p>
<ol>
<li>线程A把本地内存A中更新过的共享变量刷新到主存中去。</li>
<li>线程B到主存中去读取线程A之前已经更新过的共享变量。</li>
</ol>
<p>线程之间通信如图：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211209194936096.png" alt="image-20211209194936096"></p>
<p>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证。</p>
<h2 id="3-从源代码到指令序列的重排序"><a href="#3-从源代码到指令序列的重排序" class="headerlink" title="3. 从源代码到指令序列的重排序"></a>3. 从源代码到指令序列的重排序</h2><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型。</p>
<ol>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应及其指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211209200421067.png" alt="image-20211209200421067"></p>
<p>在这些重排序中可能会导致对线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型的处理器重排序。</p>
<p>JMM属于语句级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<h2 id="4-并发编程模型的分类"><a href="#4-并发编程模型的分类" class="headerlink" title="4. 并发编程模型的分类"></a>4. 并发编程模型的分类</h2><p>我们先看一个处理器操作内存的执行结果：</p>
<table>
<thead>
<tr>
<th></th>
<th>Processor A</th>
<th>Processor B</th>
</tr>
</thead>
<tbody><tr>
<td>代码</td>
<td>a = 1; // A1<br />x = b; // A2</td>
<td>b = 2; // B1<br />y = a; // B2</td>
</tr>
<tr>
<td>运行结果</td>
<td>初始状态：a = b = 0</td>
<td>处理器允许执行后得到结果：x = y = 0</td>
</tr>
</tbody></table>
<p> 假设处理器A和处理器B按程序的顺序并行执行内存访问，最终可能得到x = y = 0的结果。具体原因如下图：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211209211248724.png" alt="image-20211209211248724"></p>
<p>在这里，处理器A和B可以同时把共享变量a和b写入自己的写缓冲区，然后从内存中读取另一个共享变量，最后才把自己写缓冲区中保存的脏数据刷新到内存中。所以这就得到了 x = y = 0 的结果。</p>
<p>从内存操作实际发生的顺序来看，直到处理器A执行A3来刷新自己的写缓冲区，写操作A1才算真正执行了。虽然执行顺序为：A1→A2，但内存操作实际发生顺序却是A2→A1。此时，处理器A的内存操作顺序被重排序了（B与A的情况一样）。</p>
<p>这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此都会允许对写-读操作进行重排序。</p>
<p>下表是常见处理器允许的重排序类型的列表</p>
<table>
<thead>
<tr>
<th align="center">处理器</th>
<th align="center">Load-Load</th>
<th align="center">Load-Store</th>
<th align="center">Store-Store</th>
<th align="center">Store-Load</th>
<th align="center">数据依赖</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SPARC-TSO</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">N</td>
</tr>
<tr>
<td align="center">x86</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">N</td>
</tr>
<tr>
<td align="center">IA64</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">N</td>
</tr>
<tr>
<td align="center">PowerPC</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">N</td>
</tr>
</tbody></table>
<p>从表中可以看出：常见的处理器都运行Store-Load重排序，而不允许对存在数据依赖的操作进行重排序。sparc-TSO和X86拥有相对较强的处理器内存模型，它们仅允许对写-读操作进行重排序（因为它们都使用了写缓冲区）。</p>
<p>为了保证内存可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为4类，如表所示。</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LoadLoad Barriers</td>
<td>Load1;LoadLoad;Load2</td>
<td>确保Load1数据的装载先于Load2及所有后续装载指令的装载</td>
</tr>
<tr>
<td>StoreStore Barriers</td>
<td>Store1;StoreStore;Store2</td>
<td>确保Store1数据对其它处理器可见(刷新到内存)先于Store2及所有后续存储指令的存储</td>
</tr>
<tr>
<td>LoadStore Barriers</td>
<td>Load1;LoadStore;Store2;</td>
<td>确保Load1数据装载先于Store2及所有后续的存储指令刷新到内存</td>
</tr>
<tr>
<td>StoreLoad Barriers</td>
<td>Store1;StoreLoad;Load2;</td>
<td>确保Store1数据对其它处理器变得可见(指刷新到内存)先于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令(存储和装载指令)完成之后，才执行该屏障之后的内存访问指令</td>
</tr>
</tbody></table>
<p>StoreLoad Barriers是一个”全能型“的屏障，它同时具有其它3个屏障的效果。现代的多处理器大多支持该屏障。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（Buffer Fully Flush）。</p>
<h2 id="5-happens-before简介"><a href="#5-happens-before简介" class="headerlink" title="5. happens-before简介"></a>5. happens-before简介</h2><p>从JDK5开始，Java使用新的JSR-133内存模型。JSR-133使用happens-before的概念来阐述操作之间的内存可见性。在JMM中如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。这里的两个操作既可以是在一个线程之内，也可以是在不同线程之间。</p>
<p>与程序员密切相关的happens-before规则如下：</p>
<ul>
<li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li>
<li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li>
<li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li>
<li>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>
</ul>
<blockquote>
<p>注意：两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。</p>
</blockquote>
<p>happens-before与JMM的关系如图所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211209215601271.png" alt="image-20211209215601271"></p>
<p>一个happens-before规则对应于一个或多个编译器和处理器重排序规则。对于Java程序员来说，happens-before规则简单易懂，它避免Java程序员为了理解JMM提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现方法。</p>
]]></content>
  </entry>
  <entry>
    <title>初见设计模式</title>
    <url>/2021/12/09/%E5%88%9D%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>设计模式最初是在建筑学中被提出的，建筑师克里斯托弗·亚历山大在1970年代编撰了一本汇集设计模式的书，但是设计模式的思想在建筑设计领域里的影响远没有后来在软件开发领域里传播的广泛和深远。</p>
<p>软件设计中的设计模式是在GoF（”四人帮“，指Gamma、Helm、Johnson &amp; Vlissides、Addison-Wesley四人）合著的《设计模式》一书中第一次提出的，随后被规范化。</p>
<h2 id="1-为什么要使用"><a href="#1-为什么要使用" class="headerlink" title="1. 为什么要使用"></a>1. 为什么要使用</h2><p>设计模式优点如下：</p>
<ul>
<li><strong>复用解决方案</strong></li>
<li><strong>设计模式将设计方法标准化</strong></li>
<li><strong>设计模式可以提高个人和团队的设计能力</strong></li>
<li><strong>设计模式使软件更容易修改和维护</strong></li>
</ul>
<h2 id="2-设计模式分类"><a href="#2-设计模式分类" class="headerlink" title="2. 设计模式分类"></a>2. 设计模式分类</h2><ul>
<li>创建型模式：用于创建对象。对象的创建会消耗掉系统的很多资源，所以单独对对象的创建进行研究，以便能够高效地创建对象就是创建型模式要探讨的问题。</li>
<li>结构型模式：用于构建类间的关系。如何设计对象的结构、继承和依赖关系会影响到后续程序的维护性，代码的健壮性、耦合性等。这些因素需要使用结构型模式来优化。</li>
<li>行为型模式：用于控制对象的行为。如果对象的行为设计的号，那么对象的行为就会更清晰，它们之间的协作效率就会更高。</li>
</ul>
<p>具体分类见下23种：</p>
<blockquote>
<ul>
<li>创建型模式<ul>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
<li>建造者模式</li>
<li>原型模式</li>
<li>单例模式</li>
</ul>
</li>
<li>结构型模式<ul>
<li>适配器模式</li>
<li>桥接模式</li>
<li>代理模式</li>
<li>外观模式</li>
<li>装饰模式</li>
<li>组合模式</li>
<li>享元模式</li>
</ul>
</li>
<li>行为型模式<ul>
<li>命令模式</li>
<li>观察者模式</li>
<li>责任链模式</li>
<li>迭代器模式</li>
<li>访问者模式</li>
<li>状态模式</li>
<li>备忘录模式</li>
<li>策略模式</li>
<li>调停者模式</li>
<li>模板方法模式</li>
<li>解释器模式</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="3-七大原则"><a href="#3-七大原则" class="headerlink" title="3. 七大原则"></a>3. 七大原则</h2><p>设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础。</p>
<h3 id="3-1-单一职责原则"><a href="#3-1-单一职责原则" class="headerlink" title="3.1 单一职责原则"></a>3.1 单一职责原则</h3><p>对类来说，即一个类应该只负责一项职责。如：类A负责两个不同职责1和2，当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1和A2。</p>
<p>注意事项和细节：</p>
<ul>
<li>降低类的复杂度，一个类只负责一项职责。</li>
<li>提高类的可读性，可维护性。</li>
<li>降低变更引起的风险。</li>
<li>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则。</li>
</ul>
<h3 id="3-2-接口隔离原则"><a href="#3-2-接口隔离原则" class="headerlink" title="3.2 接口隔离原则"></a>3.2 接口隔离原则</h3><p>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。</p>
<h3 id="3-3-依赖倒转原则"><a href="#3-3-依赖倒转原则" class="headerlink" title="3.3 依赖倒转原则"></a>3.3 依赖倒转原则</h3><ol>
<li>高层模块不应该依赖低层模块，二者都应该依赖其抽象。</li>
<li>抽象不应该依赖细节，细节应该依赖抽象。</li>
<li>依赖倒转的中心思想是面向接口编程。</li>
<li>依赖倒转原则的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在Java中，抽象是指接口或抽象类，细节就是具体的实现类。</li>
<li>使用接口或抽象类的目的是指定好规范，而不涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。</li>
</ol>
<p>依赖关系传递方式：</p>
<ul>
<li>接口传递</li>
<li>构造方法传递</li>
<li>setter方式传递</li>
</ul>
<p>注意事项和细节：</p>
<ul>
<li>低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好。</li>
<li>变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化。</li>
<li>继承时遵循里氏替换原则。</li>
</ul>
<h3 id="3-4-里氏替换原则"><a href="#3-4-里氏替换原则" class="headerlink" title="3.4 里氏替换原则"></a>3.4 里氏替换原则</h3><h4 id="3-4-1-OO中的继承性的思考和说明"><a href="#3-4-1-OO中的继承性的思考和说明" class="headerlink" title="3.4.1 OO中的继承性的思考和说明"></a>3.4.1 OO中的继承性的思考和说明</h4><ul>
<li>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</li>
<li>继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其它的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障。</li>
</ul>
<p>而在编程中，为了正确的使用继承，我们需要用到里氏替换原则。</p>
<h4 id="3-4-2-基本介绍"><a href="#3-4-2-基本介绍" class="headerlink" title="3.4.2 基本介绍"></a>3.4.2 基本介绍</h4><p>里氏替换原则在1988年，由麻省理工学院的一位姓里的女士提出的。</p>
<p>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。<strong>换句话说，所有引用基类的地方必须能透明地使用其子类的对象。</strong></p>
<p>在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。</p>
<p>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。</p>
<h3 id="3-5-开闭原则"><a href="#3-5-开闭原则" class="headerlink" title="3.5 开闭原则"></a>3.5 开闭原则</h3><p>开闭原则是编程中最基础、最重要的设计原则。一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。用抽象构建框架，用实现扩展细节。这样，当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p>
<p>我们在编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</p>
<h3 id="3-6-迪米特法则"><a href="#3-6-迪米特法则" class="headerlink" title="3.6 迪米特法则"></a>3.6 迪米特法则</h3><p>一个对象应该对其它对象保持最少的了解，但是，类与类关系越密切，耦合度越大。迪米特法则又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法，不对外泄露任何信息。迪米特法则还有个更简单的定义：只与直接的朋友通信。</p>
<p>所谓的直接的朋友就是：每个对象都会与其它对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称<strong>出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接朋友</strong>。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</p>
<p>迪米特法则的核心是降低类之间的耦合，但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系，并不是要求完全没有依赖关系。</p>
<h3 id="3-7-合成复用原则"><a href="#3-7-合成复用原则" class="headerlink" title="3.7 合成复用原则"></a>3.7 合成复用原则</h3><p>原则是尽量使用合成/聚合的方式，而不是使用继承。</p>
]]></content>
  </entry>
  <entry>
    <title>系统错误处理机制之——日志</title>
    <url>/2021/12/08/%E7%B3%BB%E7%BB%9F%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%B9%8B%E2%80%94%E2%80%94%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>每个Java程序员都很熟悉在有问题的代码中插入一些System.out.println方法调用来帮助观察程序运行的操作过程。当然，一旦发现问题的根源，就要将这些语句从代码中删去。如果接下来又出现了问题，就需要再插入几个调用println方法的语句。记录日志API就是为了解决这个问题而设计的。下面先讨论这些API的优点：</p>
<ul>
<li>可以很容易地取消全部日志记录，或者仅仅取消某个级别的日志，而且打开和关闭这个操作也很容易。</li>
<li>可以很简单地禁止日志记录的输出，因此，将这些日志代码留在程序中的开销很小。</li>
<li>日志记录器和处理器都可以对记录进行过滤。过滤器可以根据过滤实现器指定的标准丢弃那些无用的记录项。</li>
<li>日志记录可以采用不同的方式格式化，例如，纯文本或XML。</li>
<li>应用程序可以使用多个日志记录器，它们使用类似包名的这种具有层次结构的名字，例如，com.mycompany.myapp。</li>
<li>在默认情况下，日志系统的配置由配置文件控制。如果需要的话，应用程序可以替换这个配置。</li>
</ul>
<h2 id="1-基本日志"><a href="#1-基本日志" class="headerlink" title="1. 基本日志"></a>1. 基本日志</h2><p>要生成简单的日志记录，可以使用全局日志记录器(global logger)并调用其info方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/8 21:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Logger.getGlobal().info(<span class="string">&quot;File-&gt;Open menu item selected&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，这条记录将会显示以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">十二月 08, 2021 9:58:08 下午 com.atqingke.LoggerTest main</span><br><span class="line">信息: File-&gt;Open menu item selected</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>但是，如果在适当的地方(如main开始)调用：Logger.getGlobal().setLevel(Level.OFF); 将会取消所有日志。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211208220217166.png" alt="image-20211208220217166"></p>
<h2 id="2-高级日志"><a href="#2-高级日志" class="headerlink" title="2. 高级日志"></a>2. 高级日志</h2><p>在一个专业的应用程序中，不要将所有的日志都记录到一个全局日志记录器中，而是可以自定义日志记录器。可以调用getLogger方法创建或获取记录器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger myLogger = Logger.getLogger(<span class="string">&quot;com.atqingke&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：未被任何变量引用的日志记录器可能会被垃圾回收。为了防止这种情况发生，要像上面的例子中一样，用一个静态变量存储日志记录器的一个引用。</p>
</blockquote>
<p>与包名类似，日志记录器名也具有层次结构。事实上，与包名相比，日志记录器的层次性更强。对于包来说，一个包的名字与其父包的名字之间没有语义关系，但是日志记录器的父与子之间将共享某些属性。例如，如果对com.mycompany日志记录器设置了日志级别，它的子记录器也会继承这个级别。</p>
<p>通常，有以下7个日志记录器级别：</p>
<ul>
<li>SEVERE</li>
<li>WARNING</li>
<li>INFO</li>
<li>CONFIG</li>
<li>FINE</li>
<li>FINER</li>
<li>FINEST</li>
</ul>
<p>在默认情况下，只记录前三个级别。也可以设置其他的级别。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.setLevel(Level.FINE);</span><br></pre></td></tr></table></figure>

<p>现在，FINE和更高级别的记录都可以记录下来。另外，还可以使用Level.ALL开启所有级别的记录，或者使用Level.OFF关闭所有级别的记录。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211208222156636.png" alt="image-20211208222156636"></p>
<p>对于所有的级别有下面几种记录方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.warning(message);</span><br><span class="line">logger.fine(message);</span><br><span class="line">logger.log(Level.FINE, message); <span class="comment">// log方法指定级别</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：默认的日志配置记录了INFO或更高级别的所有记录，因此，应该使用CONFIG、FINE、FINER和FINEST级别来记录那些有助于诊断，但对于程序员又没有太大意义的调试信息。</p>
</blockquote>
<blockquote>
<p>警告：如果将日志级别设计为INFO或者更低，则需要修改日志处理器的配置。默认的日志处理器不会处理低于INFO级别的信息。</p>
</blockquote>
<h2 id="3-修改日志管理器配置"><a href="#3-修改日志管理器配置" class="headerlink" title="3. 修改日志管理器配置"></a>3. 修改日志管理器配置</h2><p>默认情况下，日志的配置文件存在于：jre/lib/loggin.properties。</p>
]]></content>
  </entry>
  <entry>
    <title>【Effective-Java】覆盖equals请遵守通用约定</title>
    <url>/2021/12/08/%E3%80%90Effective-Java%E3%80%91%E8%A6%86%E7%9B%96equals%E8%AF%B7%E9%81%B5%E5%AE%88%E9%80%9A%E7%94%A8%E7%BA%A6%E5%AE%9A/</url>
    <content><![CDATA[<p>尽管Object类是一个具体的类，但设计它主要是为了扩展。它的所有非final方法（equals、hashCode、toString、clone和finalize）都有明确的通用约定，因为它们设计成是要覆盖的。任何一个类，它在覆盖这些方法的时候，都有责任遵守这些通用约定；如果不能做到这一点，其它依赖于这些约定的类就无法结合该类一起正常运作。</p>
<span id="more"></span>

<h2 id="1-不需要覆盖equals的情况"><a href="#1-不需要覆盖equals的情况" class="headerlink" title="1. 不需要覆盖equals的情况"></a>1. 不需要覆盖equals的情况</h2><p>覆盖equals方法看起来非常简单，但是有许多覆盖方式会导致错误，并且后果严重。因此，我们先来看一下不需要覆盖equals方法的情况：</p>
<ol>
<li>类的每个实例本质上都是唯一的。</li>
<li>类没有必要提供“逻辑相等”的测试功能。</li>
<li>父类已经覆盖了equals，父类的行为对于这个类也是合适的。例如，大多数的Set都是从AbstractSet继承equals实现的，List实现从AbstractList继承equals实现的，Map从AbstractMap继承equals实现的。</li>
<li>类是私有的，或者是包级私有的，可以确定它的equals方法永远不会被调用。如果你非常想要规避风险，可以覆盖equals方法，以确保它不会被意外调用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(); <span class="comment">// Method is never called.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-什么时候覆盖equals"><a href="#2-什么时候覆盖equals" class="headerlink" title="2. 什么时候覆盖equals"></a>2. 什么时候覆盖equals</h2><p>如果类具有自己特有的“逻辑相等”概念（不同于对象等同的概念），而且父类还没有覆盖equals。这通常属于“值类”的情形。值类仅仅是一个表示值的类，例如Integer或者String。程序员在利用equals方法来比较值对象的引用时，希望知道它们在逻辑上是否相等，而不是想了解它们是否指向同一个对象。而为了满足程序员的要求，不仅必须重写equals方法，而且这样做也使得这个类的实例可以被用作映射表的键，或者集合的元素，使映射或者集合表现出预期的能力。</p>
<h2 id="3-必须遵守的通用约定"><a href="#3-必须遵守的通用约定" class="headerlink" title="3. 必须遵守的通用约定"></a>3. 必须遵守的通用约定</h2><p>在覆盖equals方法时，必须要遵守它的通用约定。下面是约定的内容，来自Object的规范。equals方法实现了等价关系，其属性如下：</p>
<ul>
<li>自反性（reflexive）：对于任何非null的引用值x，x.equals(x)必须返回true。</li>
<li>对称性（symmetric）：对于任何非null的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)必须返回true。</li>
<li>传递性（transitive）：对于任何非null的引用值x、y和z，如果x.equals(y)返回true，并且y.equals(z)也返回true，那么x.equals(z)也必须返回true。</li>
<li>一致性（consistent）：对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)就会一致地返回true，或者一致地返回false。</li>
<li>非空性（Non-nullity）：对于任何非null的引用值x，x.equals(null)必须返回false。</li>
</ul>
<h2 id="4-属性详解"><a href="#4-属性详解" class="headerlink" title="4. 属性详解"></a>4. 属性详解</h2><ul>
<li><p>自反性</p>
<p>这个要求仅仅说明对象必须等于其自身。</p>
</li>
<li><p>对称性</p>
<p>第二个要求是说，任何两个对象对于“它们是否相等”的问题都必须保持一致。与第一个要求不同，若无意中违反这一条，这种情形倒是不难想象。例如下面的类，它实现了一个区分大小写的字符串。字符串由toString保存，但在equals操作中被忽略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CaseInsensitiveString</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String s;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CaseInsensitiveString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = Objects.requireNonNull(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> CaseInsensitiveString)</span><br><span class="line">            <span class="keyword">return</span> s.equalsIgnoreCase(((CaseInsensitiveString) o).s);</span><br><span class="line">       	<span class="keyword">if</span>(o <span class="keyword">instanceof</span> String)</span><br><span class="line">            <span class="keyword">return</span> s.equalsIgnoreCase((String) o);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个类中，equals方法的意图非常好，它企图与普通的字符串对象进行互操作。假设我们有一个不区分大小写的字符串和一个普通的字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">    CaseInsensitiveString polish = <span class="keyword">new</span> CaseInsensitiveString(<span class="string">&quot;Polish&quot;</span>);</span><br><span class="line">    String s = <span class="string">&quot;polish&quot;</span>;</span><br><span class="line">    System.out.println(polish.equals(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果不出所料返回true。问题在于，虽然CaseInsensitiveString类中的equals方法知道普通字符串对象，但是，String类中的equals方法却并不知道不区分大小写的字符串。因此，s.equals(polish)返回false，显然违反了对称性。为了解决这个问题，只需把企图与String互操作的这段代码从equals方法中去掉就可以了。这样做之后，就可以重构该方法，使它变成一条单独的返回语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o <span class="keyword">instanceof</span> CaseInsensitiveString &amp;&amp; ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>传递性</p>
<p>equals约定的第三个要求是，如果一个对象等于第二个对象，而第二个对象又等于第三个对象，则第一个对象一定等于第三个对象。同样地，无意识地违反这条规则的情形也不难想象。我们有一个父类Point：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Point))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Point p = (Point) o;</span><br><span class="line">        <span class="keyword">return</span> p.x == x &amp;&amp; p.y == y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一个子类ColorPoint：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Color color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColorPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, Color color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y);</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们如果不给ColorPoint提供equals方法，直接从Point中继承过来，在equals作比较的时候颜色信息就被忽略掉了。虽然这样做不会违反equals约定，但是我们明显无法接受。假设我们在ColorPoint中也重写了equals方法，只有当它的参数是另一个有色点，并且具有同样的位置和颜色时，才返回true：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> ColorPoint))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.equals(o) &amp;&amp; ((ColorPoint) o).color == color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的问题在于，在比较普通点和有色点，以及相反的情形时，可能会得到不同的结果。前一种比较忽略了颜色信息，而后一种比较则总是返回false，因为参数类型不正确。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211208234254912.png" alt="image-20211208234254912"></p>
<p>为了修正这个问题，我们可以让ColorPoint在进行“混合比较”时忽略颜色信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Point))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> ColorPoint))</span><br><span class="line">        <span class="keyword">return</span> o.equals(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.equals(o) &amp;&amp; ((ColorPoint) o).color == color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法确实提供了对称性，但是却牺牲了传递性：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211208234815483.png" alt="image-20211208234815483"></p>
<p>此外，这种方法还可能导致无限递归问题：假设Point有两个子类：ColorPoint和SmellPoint，它们各自都带有这种equals方法。那么对colorPoint.equals(SmellPoint)的调用将会抛出StackOverflowError异常。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211208235227767.png" alt="image-20211208235227767"></p>
<p>如何解决这个问题呢？事实上，这是面向对象语言中关于等价关系的一个基本问题。<strong>我们无法在扩展可实例化的类的同时，既增加新的值组件，同时又保留equals约定</strong>，除非愿意放弃面向对象的抽象所带来的优势。而一种方法是在equals方法中用getClass测试代替instanceof测试，可以扩展可实例化的类和增加新的值组件，同时保留equals约定：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(o == <span class="keyword">null</span> || o.getClass() != getClass())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Point p = (Point) o;</span><br><span class="line">    <span class="keyword">return</span> p.x == x &amp;&amp; p.y == y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段程序只有当对象具有相同的实现类时，才能使对象等同。这也并不是我们想要的结果！</p>
<p>虽然没有一种令人满意的办法可以既扩展不可实例化的类，又增加值组件，但还是有一种不错的权宜之计：遵从“复合优先于继承”的建议。我们不再让ColorPoint扩展Point，而是在ColorPoint中加入一个私有的Point域，以及一个公有的试图方法，此方法返回一个与该有色点处在相同位置的普通Point对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Point point</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Color color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColorPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, Color color)</span> </span>&#123;</span><br><span class="line">		point = <span class="keyword">new</span> Point(x, y);</span><br><span class="line">        <span class="keyword">this</span>.color = Objects.requireNonNull(color);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Returns the point-view of this color point. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">asPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> point;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> ColorPoint))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ColorPoint cp = (ColorPoint) o;</span><br><span class="line">		<span class="keyword">return</span> cp.point.equals(point) &amp;&amp; cp.color.equals(color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java平台类库中，有一些类扩展了可实例化的类，并添加了新的值组件。例如，java.sql.Timestamp对java.util.Date进行了扩展，并增加了nanoseconds域。而在Timestamp中也告诉我们不要把这两个混用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This type is a composite of a &lt;code&gt;java.util.Date&lt;/code&gt; and a</span></span><br><span class="line"><span class="comment"> * separate nanoseconds value. Only integral seconds are stored in the</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;java.util.Date&lt;/code&gt; component. The fractional seconds - the nanos - are</span></span><br><span class="line"><span class="comment"> * separate.  The &lt;code&gt;Timestamp.equals(Object)&lt;/code&gt; method never returns</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;true&lt;/code&gt; when passed an object</span></span><br><span class="line"><span class="comment"> * that isn&#x27;t an instance of &lt;code&gt;java.sql.Timestamp&lt;/code&gt;,</span></span><br><span class="line"><span class="comment"> * because the nanos component of a date is unknown.</span></span><br><span class="line"><span class="comment"> * As a result, the &lt;code&gt;Timestamp.equals(Object)&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> * method is not symmetric with respect to the</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;java.util.Date.equals(Object)&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> * method.  Also, the &lt;code&gt;hashCode&lt;/code&gt; method uses the underlying</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;java.util.Date&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> * implementation and therefore does not include nanos in its computation.</span></span><br><span class="line"><span class="comment"> * &lt;P&gt;</span></span><br><span class="line"><span class="comment"> * Due to the differences between the &lt;code&gt;Timestamp&lt;/code&gt; class</span></span><br><span class="line"><span class="comment"> * and the &lt;code&gt;java.util.Date&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> * class mentioned above, it is recommended that code not view</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;Timestamp&lt;/code&gt; values generically as an instance of</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;java.util.Date&lt;/code&gt;.  The</span></span><br><span class="line"><span class="comment"> * inheritance relationship between &lt;code&gt;Timestamp&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> * and &lt;code&gt;java.util.Date&lt;/code&gt; really</span></span><br><span class="line"><span class="comment"> * denotes implementation inheritance, and not type inheritance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Timestamp</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">Date</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>最后注意，你可以在一个抽象类的子类中增加新的值组件且不违反equals约定。</p>
</li>
<li><p>一致性</p>
<p>第四个要求是，如果两个对象相等，它们就必须始终保持相等，除非其中有变化。换句话说，可变对象在不同时候可以与不同的对象相等，而不可变对象则不会这样。当你写一个类的受，应该仔细考虑它是否应该是不可变的。如果认为它应该是不可变的，就必须保证equals满足：相等的对象永远相等，不相等的对象永远不相等。</p>
<p>无论类是否是不可变的，都不要使equals方法依赖于不可靠的资源。如果违反了这条禁令，要想满足一致性的要求就十分困难了。例如，java.net.URL的equals方法依赖于对URL主机IP地址的比较。而将一个主机名转变成IP地址可能需要访问网络，随着时间的推移，就不能确保会产生相同的结果，即IP地址发生了变化。这样会导致URL的equals方法违反equals约定，在实践中可能引发一些问题。这种行为是一个大错误且不应被模仿。遗憾的是，因为兼容性要求，这样行为无法被改变。</p>
</li>
<li><p>非空性</p>
<p>通用约定不允许抛出NullPointerException异常。许多类的equals都通过一个显式的null测试来防止这种情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(o == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这项测试是不必要的。为了测试其参数的等同性，equals方法必须先把参数转换成适当的类型，以便可以调用它的访问方法，或者访问它的域。在进行转换之前，必须使用instanceof操作符，检查参数类型是否正确：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> MyType))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    MyType mt = (MyType) o;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果漏掉这一步，并且传递的参数是错误的类型，会抛出ClassCastException异常，违反了约定。但是，如果instanceof的第一个操作数为null，那么，不管第二个操作数是哪种类型，instanceof都应该返回false。因此，如果把null传给equals，类型检查就会返回false，所以不需要显式的null检查。</p>
</li>
</ul>
<p>结合所有这些要求，得出了以下实现高质量equals方法的诀窍：</p>
<blockquote>
<ol>
<li>使用==操作符检查“参数是否为这个对象的引用”。</li>
<li>使用instanceof操作符检查”参数是否为正确的类型“。</li>
<li>把参数转换成正确的类型。</li>
<li>对于该类中的每个”关键“域，检查参数中的域是否与该对象中对应的域相匹配。</li>
<li>覆盖equals时总要覆盖hashCode。</li>
<li>不要企图让equals方法过于智能。</li>
<li>不要将equals声明中的Object对象替换为其它的类型。（那样做的话就不是Override重写了）</li>
</ol>
</blockquote>
<p>对于既不是float也不是double类型的基本类型域，可以使用==进行比较；对于对象引用域，可以递归调用equals方法；对于float域，可以使用Float.compare(float, float)方法；对于double域，则使用Double.compare(double, double)。</p>
<p>有些对象引用域包含null可能是合法的，所以，为了避免可能导致空指针异常，则使用静态方法Objects.equals(Ojbect, Object)来检查这类域的等同性。</p>
<p>域的比较顺序可能会影响equals方法的性能。为了获得最佳的性能，应该最先比较最有可能不一致的域，或者是开销最低的域，最理想的情况是两个条件同时满足的域。</p>
<p>在编写完equals方法之后，应该问自己三个问题：它是否是对称的、传递的、一致的？并且要编写单元测试来检验。除非用AutoValue生成的。</p>
<p>编写和测试equals（及hashCode）方法都是十分繁琐的，得到的代码也很琐碎。代替手工编写和测试的最佳途径，是使用Google开源的AutoValue框架，它会自动生成这些方法，通过类汇总的单个注解就能触发。</p>
<p>IDE也有工具可以生成，但得到的源代码比使用Auto-Value的更加冗长，可读性也更差，它无法自动追踪类中的变化，但通常由于程序员手工实现它们。</p>
<p>总而言之，不要轻易覆盖equals方法，除非迫不得已。因为大多数情况下，Object继承的实现已经是想要的，如果覆盖，一定要比较这个类的所有关键域，并且查看是否遵守equals合约的所有五个条款。</p>
]]></content>
  </entry>
  <entry>
    <title>异常处理</title>
    <url>/2021/12/05/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>世界上最遥远的距离，是我在if里你在else里，似乎一直相伴又永远分离； </p>
<p>世界上最痴心的等待，是我当case你是switch，或许永远都选不上自己； </p>
<p>世界上最真情的相依，是你在try我在catch。无论你发神马脾气，我都默 默承受，静静处理。到那时，再来期待我们的finally。</p>
</blockquote>
<span id="more"></span>

<p>人们在遇到错误时会感觉不爽。如果一个用户在运行程序期间，由于程序的错误或一些外部环境的影响造成用户数据的丢失，用户就有可能不再使用这个程序了。为了避免这类事情发生，至少应该做到以下几点：</p>
<ul>
<li><p>向用户通告错误；</p>
</li>
<li><p>保存所有的工作错误；</p>
</li>
<li><p>允许用户以妥善的形式退出程序。</p>
</li>
</ul>
<h2 id="1-异常概述与体系结构"><a href="#1-异常概述与体系结构" class="headerlink" title="1. 异常概述与体系结构"></a>1. 异常概述与体系结构</h2><p>异常处理的任务就是<u><strong>将控制权从错误产生的地方转移给能够处理这种情况的错误处理器</strong></u>（异常处理器）。而为了能够在程序中处理异常情况，必须研究程序中可能会出现的错误和问题，以及哪类问题需要关注。</p>
<ol>
<li>用户输入错误</li>
<li>设备错误</li>
<li>物理限制</li>
<li>代码错误</li>
</ol>
<h3 id="1-1-异常分类"><a href="#1-1-异常分类" class="headerlink" title="1.1 异常分类"></a>1.1 异常分类</h3><p>在Java程序设计语言中，异常对象都是派生于Throwable类的一个实例。在执行过程中所发生的异常事件可分为两类：</p>
<ul>
<li>Error：Java运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出这种类型的对象。如果出现了这样的内部错误，除了通告给用户，并尽力使程序安全地终止之外，再也无能为力了。这种情况很少出现。</li>
<li>Exception：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如：<ul>
<li>错误的类型转换</li>
<li>数组访问越界</li>
<li>访问null指针</li>
<li>试图打开一个不存在的文件</li>
</ul>
</li>
</ul>
<p>对于这些错误，一般有两种解决办法：一是遇到错误就终止程序的运行。另一种方法是由程序员在编写程序时，就考虑到错误的检测、错误消息的提示，以及错误的处理。而捕获这些错误最理想的是在编译期间，但有的错误只有在运行时才会发生。比如：除数为0，数组下标越界等。因此，在Exception这一层次结构上，我们又可以分为两大分支：编译时异常和运行时异常（RuntimeException）。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211205234925125.png" alt="image-20211205234925125"></p>
<ul>
<li><p>运行时异常</p>
<p>指编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该积极避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常。</p>
<p>对于这类异常，可以不做处理，因为这类异常很普遍，若全部处理可能会对程序的可读性和运行效率产生影响。</p>
</li>
<li><p>编译时异常</p>
<p>指编译器要求必须处理的异常。即程序在运行时由于外界因素造成的一般性异常。**<u>编译器要求Java程序必须捕获或声明所有编译时异常。</u>**</p>
<p>对于这类异常，如果程序不处理，可能会带来意想不到的结果。</p>
</li>
</ul>
<blockquote>
<p>Java语言规范将派生于Error类或RuntimeException类的所有异常称为非受查异常，所有其它的异常称为受查异常。编译器将核查是否为所有的受查异常提供了异常处理器。</p>
</blockquote>
<h3 id="1-2-声明受查异常"><a href="#1-2-声明受查异常" class="headerlink" title="1.2 声明受查异常"></a>1.2 声明受查异常</h3><p>如果遇到了无法处理的情况，那么Java的方法可以抛出一个异常。这个道理很简单：一个方法不仅需要告诉编译器将要返回什么值，还要告诉编译器有可能发生什么错误。在自己编写方法时，不必将所有可能抛出的异常都进行声明。我们需要记住以下4种情况应该抛出异常：</p>
<ol>
<li>调用一个抛出受查异常的方法，例如，FileInputStream构造器。</li>
<li>程序运行过程中发现错误，并且利用throw语句抛出一个受查异常。</li>
<li>程序出现错误，例如，a[-1] = 0会抛出一个ArrayIndexOutOfBoundsException这样的非受查异常。</li>
<li>Java虚拟机和运行时库出现的内部错误。</li>
</ol>
<p>对于那些可能被他人使用的Java方法，应该根据异常规范，在方法的首部声明这个方法可能抛出的异常。如果一个方法有可能抛出多个受查异常类型，那么就必须在方法的首部列出所有的异常类。每个异常类之间用逗号隔开。</p>
<blockquote>
<p>如果在子类中覆盖率父类的一个方法，子类方法中声明的受查异常不能比父类方法中声明的异常更通用（也就是说，子类方法中可以抛出更特定的异常，或者根本不抛出任何异常）。特别的，如果父类方法没有抛出任何受查异常，子类也不能抛出任何受查异常。</p>
</blockquote>
<h3 id="1-3-如何抛出异常"><a href="#1-3-如何抛出异常" class="headerlink" title="1.3 如何抛出异常"></a>1.3 如何抛出异常</h3><p>对于一个已经存在的异常类，将其抛出非常容易。在这种情况下：</p>
<ol>
<li>找到一个合适的异常类。</li>
<li>创建这个类的一个对象。</li>
<li>将对象抛出。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">readData</span><span class="params">(Scanner in)</span> <span class="keyword">throws</span> EOFException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span>(n &lt; len)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-创建异常类"><a href="#1-4-创建异常类" class="headerlink" title="1.4 创建异常类"></a>1.4 创建异常类</h3><p>定义的类应该派生于Exception类或Exception的子类，其中包含两个构造器，一个是默认的构造器，另一个是带有详细信息的构造器（父类的Throwable的toString方法会打印这些信息，在调试中非常有用）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileFormatException</span> <span class="keyword">extends</span> <span class="title">IOException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileFormatException</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileFormatException</span><span class="params">(String gripe)</span> </span>&#123;	<span class="keyword">super</span>(gripe);	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就可以抛出我们自定义的异常了！</p>
<h2 id="2-捕获异常"><a href="#2-捕获异常" class="headerlink" title="2. 捕获异常"></a>2. 捕获异常</h2><p>要想捕获一个异常，必须设置try/catch语句块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span>(ExceptionType e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在try语句块中的任何代码抛出了一个在catch子句中说明的异常类，那么：</p>
<ol>
<li>程序将跳过try语句块剩余的代码。</li>
<li>程序将执行catch子句中的处理器代码。</li>
</ol>
<p>如果在try中没有抛出任何异常，那么程序将跳过catch语句。</p>
<p>另外一种异常处理方式是：什么都不做，而是将异常传递给调用者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	InputStream in = <span class="keyword">new</span> FileInputStream(filename);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器严格地执行throws说明符。如果调用了一个抛出受查异常的方法，就必须对它进行处理，或者继续传递。</p>
<p>哪种方法更好呢？通常，应该捕获那些知道如何处理的异常，而将那些不知道怎么处理的异常继续进行传递。如果想传递一个异常，就必须在方法的首部添加一个throws说明符，以便告知调用者这个方法可能会抛出异常。但是，在选择处理方式中也有一个例外：如果编写一个覆盖父类的方法，而这个方法又没有抛出异常，那么这个方法就必须捕获方法代码中的每一个受查异常。不允许在子类的throws说明符中出现超过父类方法所列出的异常范围。</p>
<h3 id="2-1-捕获多个异常"><a href="#2-1-捕获多个异常" class="headerlink" title="2.1 捕获多个异常"></a>2.1 捕获多个异常</h3><p>在一个try语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(FileNotFoundException e) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(UnkownHostException e) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在JavaSE7中，同一个catch子句中可以捕获多个异常类型。例如，假设对应缺少文件和未知主机异常的动作是一样的，就可以合并catch子句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(FileNotFoundException | UnkownHostException e) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有当捕获的异常类型彼此之间不存在子类关系时才需要这个特性。</p>
<blockquote>
<p>捕获多个异常时，异常变量隐含为final变量。</p>
</blockquote>
<h3 id="2-2-finally子句"><a href="#2-2-finally子句" class="headerlink" title="2.2 finally子句"></a>2.2 finally子句</h3><p>当代码抛出一个异常时，就会终止方法中剩余代码的处理，并退出这个方法的执行。如果方法获得了一些本地资源，并且只有这个方法自己知道，又如果这些资源在退出方法之前必须被回收，那么就会产生资源回收问题。一种解决方案是捕获并重新抛出所有异常。但是，这种解决方案比较乏味，这是因为需要在两个地方清楚所分配的资源。一个在正常的代码中；另一个在异常代码中。</p>
<p>Java有一种很好的解决方案，这就是finally子句。不管是否有异常被捕获，finally子句中的代码都被执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(...);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面这段代码中，有下面三种情况会执行finally子句：</p>
<ol>
<li>代码中没有抛异常。</li>
<li>抛出一个在catch子句中捕获的异常。</li>
<li>代码抛出了一个异常，但这个异常不是由catch子句捕获的。在这种情况下，程序将执行try语句块中所有语句，知道有异常被抛出为止。此时，将跳过try语句块中剩余的代码，然后执行finally子句中的语句，并将异常抛给这个方法的调用者。</li>
</ol>
<blockquote>
<p>提示：这里，强烈建议解耦合try/catch和try/finally语句块。这样可以提高代码的清晰度。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream in = ...;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException) &#123;</span><br><span class="line">    show error message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内层的try语句块只有一个职责，就是确保关闭输入流。外层的try语句块也只有一个职责，就是确保报告出现的问题。这种设计方式不仅清楚，而且还具有一个功能，就是会报告finally子句中出现的错误。</p>
</blockquote>
<blockquote>
<p>警告：当finally子句包含return语句时，将会出现一种意想不到的结果。假设利用return语句从try语句块中退出。在方法返回前，finally子句的内容将被执行。如果finally子句中也有一个return语句，这个返回值将会覆盖原始的返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> r = n * n;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用f(2)，那么try语句块的计算结果r=4，并执行return。然而，在方法真正返回之前，还要执行finally。finally将使得方法返回0，这个返回值覆盖了原始的返回值4。</p>
</blockquote>
<p>有时候，finally也会带来麻烦。例如，清理资源的方法也有可能抛出异常。解决这些麻烦，我们可以使用带资源的try语句。</p>
<h3 id="2-3-带资源的try语句"><a href="#2-3-带资源的try语句" class="headerlink" title="2.3 带资源的try语句"></a>2.3 带资源的try语句</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">open a resource</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    work with the resource</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    close the resource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设资源属于一个实现了AutoCloseable接口的类，JavaSE7为这种代码模式提供了一个很有用的快捷方式。AutoCloseable接口有一个方法：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211206185835797.png" alt="image-20211206185835797"></p>
<blockquote>
<p>注释：另外，还有一个Closeable接口。这是AutoCloseable的子接口，也包含一个close方法。不过，这个方法声明为抛出一个IOException。</p>
</blockquote>
<p>带资源的try语句的最简形式为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(Resource res = ...) &#123;</span><br><span class="line">    work with res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try块退出时，会自动调用res.close()。下面给出一个典型的例子，这里要读取一个文件中的所有单词：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;/usr/share/dict/words&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">while</span>(in.hasNext())</span><br><span class="line">        System.out.println(in.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个块正常退出时，或者存在一个异常时，都会调用in.close()方法，就好像使用了finally块一样。</p>
<p>还可以指定多个资源。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;/usr/share/dict/words&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">   	PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="string">&quot;out.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">while</span>(in.hasNext())</span><br><span class="line">        out.println(in.next().toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不论这个块如何退出，in和out都会关闭。如果你用常规方式手动编程，就需要嵌套的try/finally语句。</p>
<blockquote>
<p>注释：带资源的try语句本身也可以有catch子句和一个finally子句。这些子句会在关闭资源之后执行。不过在实际中，一个try语句中加入这么多内容可能不是一个好主意。</p>
</blockquote>
<h3 id="2-4-分析堆栈轨迹元素"><a href="#2-4-分析堆栈轨迹元素" class="headerlink" title="2.4 分析堆栈轨迹元素"></a>2.4 分析堆栈轨迹元素</h3><p>堆栈轨迹（stack trace）是一个方法调用过程的列表，它包含了程序执行过程中方法调用的特定位置。当Java程序正常终止，而没有捕获异常时，这个列表就会显示出来。可以调用Throwable类的printStackTrace方法访问堆栈轨迹的文本描述信息。而一种更灵活的方法是使用getStackTrace方法，它会得到StackTraceElement对象的一个数组，可以在你的程序中分析这个对象数组。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Throwable t = <span class="keyword">new</span> Throwable();</span><br><span class="line">StackTraceElement[] frames = t.getStackTrace();</span><br><span class="line"><span class="keyword">for</span>(StackTraceElement frame : frames)</span><br><span class="line">    analyze frame</span><br></pre></td></tr></table></figure>

<p>StackTraceElement类含有能够获得文件名和当前执行的代码行号的方法，同时，还含有能够获得类名和方法名的方法。toString方法将产生一个格式化的字符串，其中包含所获得的信息。</p>
<p>静态的Thread.getAllStackTraces方法，它可以产生所有线程的堆栈轨迹。下面给出使用这个方法的具体方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Thread, StackTraceElement[]&gt; map = Thread.getAllStackTraces();</span><br><span class="line"><span class="keyword">for</span>(Thread t : map.keySet()) &#123;</span><br><span class="line">    StackTraceElement[] frames = map.get(t);</span><br><span class="line">    analyze frames</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们看一个打印递归阶乘函数的堆栈情况示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atqingke;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> pengbin007</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/6 19:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTraceTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;factorial(&quot;</span> + n + <span class="string">&quot;):&quot;</span>);</span><br><span class="line">        Throwable t = <span class="keyword">new</span> Throwable();</span><br><span class="line">        StackTraceElement[] frames = t.getStackTrace();</span><br><span class="line">        <span class="keyword">for</span>(StackTraceElement f : frames)</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)  r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = n * factorial(n - <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;return &quot;</span> + r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;Enter n: &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">        factorial(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出结果为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Enter n: 3</span><br><span class="line">factorial(3):</span><br><span class="line">com.atqingke.StackTraceTest.factorial(StackTraceTest.java:13)</span><br><span class="line">com.atqingke.StackTraceTest.main(StackTraceTest.java:28)</span><br><span class="line">factorial(2):</span><br><span class="line">com.atqingke.StackTraceTest.factorial(StackTraceTest.java:13)</span><br><span class="line">com.atqingke.StackTraceTest.factorial(StackTraceTest.java:19)</span><br><span class="line">com.atqingke.StackTraceTest.main(StackTraceTest.java:28)</span><br><span class="line">factorial(1):</span><br><span class="line">com.atqingke.StackTraceTest.factorial(StackTraceTest.java:13)</span><br><span class="line">com.atqingke.StackTraceTest.factorial(StackTraceTest.java:19)</span><br><span class="line">com.atqingke.StackTraceTest.factorial(StackTraceTest.java:19)</span><br><span class="line">com.atqingke.StackTraceTest.main(StackTraceTest.java:28)</span><br><span class="line">return 1</span><br><span class="line">return 2</span><br><span class="line">return 6</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h2 id="3-使用异常机制的技巧"><a href="#3-使用异常机制的技巧" class="headerlink" title="3. 使用异常机制的技巧"></a>3. 使用异常机制的技巧</h2><ul>
<li>异常处理不能代替简单的测试</li>
<li>不要过分地细化异常</li>
<li>利用异常层次结构</li>
<li>不要压制异常</li>
<li>在检测错误时，”苛刻“要比放任更好</li>
<li>不要羞于传递异常</li>
</ul>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211206193013278.png" alt="image-20211206193013278"></p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>深入Java集合系列之——HashMap</title>
    <url>/2021/12/04/%E6%B7%B1%E5%85%A5Java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94HashMap/</url>
    <content><![CDATA[<h2 id="1-传统HashMap的缺点"><a href="#1-传统HashMap的缺点" class="headerlink" title="1. 传统HashMap的缺点"></a>1. 传统HashMap的缺点</h2><p>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
<ol>
<li><p>JDK1.8以前HashMap的实现是 数组 + 链表，即使哈希函数取得再好，也很难达到元素百分百均与分布。</p>
</li>
<li><p>当HashMap中有大量的元素都存放到同一个桶中时，这个桶下由一条长长的链表，这个时候HashMap就相当于一个单链表，加入单链表有n个元素，遍历的时间复杂度就是O(n)，完全失去了它的优势。</p>
</li>
<li><p>针对这种情况，JDK1.8中引入了红黑树(查找时间复杂度为O(logn))来优化这个问题。</p>
<span id="more"></span></li>
</ol>
<h2 id="2-JDK1-8中HashMap的数据结构"><a href="#2-JDK1-8中HashMap的数据结构" class="headerlink" title="2. JDK1.8中HashMap的数据结构"></a>2. JDK1.8中HashMap的数据结构</h2><h3 id="2-1-HashMap是数组-链表-红黑树实现的"><a href="#2-1-HashMap是数组-链表-红黑树实现的" class="headerlink" title="2.1 HashMap是数组 + 链表 + 红黑树实现的"></a>2.1 HashMap是数组 + 链表 + 红黑树实现的</h3><p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211204101623944.png" alt="image-20211204101623944"></p>
<p>新增红黑树：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span></span><br><span class="line"><span class="comment">     * extends Node) so can be used as extension of either regular or</span></span><br><span class="line"><span class="comment">     * linked node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-HashMap中关于红黑树的三个关键参数"><a href="#2-2-HashMap中关于红黑树的三个关键参数" class="headerlink" title="2.2 HashMap中关于红黑树的三个关键参数"></a>2.2 HashMap中关于红黑树的三个关键参数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment">     * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment">     * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment">     * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment">     * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment">     * shrinkage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment">     * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment">     * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment">     * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment">     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment">     * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>TREEIFY_THRESHOLD         一个桶的树化阈值</strong></p>
<p>当桶中元素个数超过这个值时，需要使用红黑树节点替换链表节点。</p>
</li>
<li><p><strong>UNTREEIFY_THRESHOLD   一个树的链表还原阈值</strong></p>
<p>当扩容时，桶中元素个数小于这个值时，就会把树形的桶元素还原（切分）为链表结构。</p>
</li>
<li><p><strong>MIN_TREEIFY_CAPACITY     哈希表的最小树形化容量</strong></p>
<p>当哈希表中的容量大于这个值时，表中的桶才能进行树形化，否则桶内元素太多时会扩容，而不是树形化。为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD。</p>
</li>
</ol>
<h3 id="2-3-HashMap在JDK1-8中新增的操作：桶的树形化treeifyBin"><a href="#2-3-HashMap在JDK1-8中新增的操作：桶的树形化treeifyBin" class="headerlink" title="2.3 HashMap在JDK1.8中新增的操作：桶的树形化treeifyBin()"></a>2.3 HashMap在JDK1.8中新增的操作：桶的树形化treeifyBin()</h3><p>在Java8中，如果一个桶中的元素个数超过TREEIFY_THRESHOLD（默认是8），就使用红黑树来替换链表，从而提高速度。这个替换的方法叫treeifyBin()，即树形化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment">     * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// 将桶内所有的链表节点替换成红黑树节点</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 如果当前哈希表为空，或者哈希表中元素的个数小于进行树形化的阈值（默认64），就去新建/扩容</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 如果哈希表中的元素个数超过了树形化阈值，进行树形化</span></span><br><span class="line">    <span class="comment">// e 是哈希表中指定位置桶里的链表节点，从第一个开始</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 新建一个树形节点，内容和当前链表节点 e 一致</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>) <span class="comment">// 确定树的头节点</span></span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 让桶的第一个元素指向新建的红黑树头节点，以后这个桶里的元素就是红黑树而不是链表了</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For treeifyBin</span></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过分析源码我们可以看到，treeifyBin方法主要做了三件事：</p>
<ol>
<li>根据哈希表中元素个数确定是扩容还是树形化。</li>
<li>如果是树形化遍历桶中的元素，创建相同个数的树形节点，复制内容，建立起联系。</li>
<li>然后让桶第一个元素指向新建的树头节点，替换桶的链表内容为树形内容。</li>
</ol>
<h2 id="3-hash方法"><a href="#3-hash方法" class="headerlink" title="3. hash方法"></a>3. hash方法</h2><p>在get方法和put方法中都需要先计算key映射到哪个桶上，然后才进行之后的操作，计算的主要代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure>

<p>上面的代码中，n指的是哈希表的大小，hash指的是key的哈希值，hash值是通过下面这段源码算出来的，采用了二次哈希的方式，其中key的hashCode方法是一个native方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个hash方法先通过key的hashCode方法获取一个哈希值，再拿这个哈希值与它的高16位的哈希值做一个异或操作来得到最后的哈希值，计算过程可以参考下图：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211205182507237.png" alt="image-20211205182507237"></p>
<p>为什么这样做？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class="line"><span class="comment">     * to lower.  Because the table uses power-of-two masking, sets of</span></span><br><span class="line"><span class="comment">     * hashes that vary only in bits above the current mask will</span></span><br><span class="line"><span class="comment">     * always collide. (Among known examples are sets of Float keys</span></span><br><span class="line"><span class="comment">     * holding consecutive whole numbers in small tables.)  So we</span></span><br><span class="line"><span class="comment">     * apply a transform that spreads the impact of higher bits</span></span><br><span class="line"><span class="comment">     * downward. There is a tradeoff between speed, utility, and</span></span><br><span class="line"><span class="comment">     * quality of bit-spreading. Because many common sets of hashes</span></span><br><span class="line"><span class="comment">     * are already reasonably distributed (so don&#x27;t benefit from</span></span><br><span class="line"><span class="comment">     * spreading), and because we use trees to handle large sets of</span></span><br><span class="line"><span class="comment">     * collisions in bins, we just XOR some shifted bits in the</span></span><br><span class="line"><span class="comment">     * cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class="line"><span class="comment">     * to incorporate impact of the highest bits that would otherwise</span></span><br><span class="line"><span class="comment">     * never be used in index calculations because of table bounds.</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<p>这是hash方法上的注释，大致意思就是通过这种最便捷的方式对一些移位位进行异或，这样可以减少系统损失，以及合并最高位的影响，否则，由于table bounds，最高位将用于不会用于索引计算。我们可以假设这样一种场景，如果n很小，假设为64，那么n - 1就是63(0x111111)，这样的值跟hashCode直接做与操作，实际上只使用了哈希值的后六位。当哈希值的高位变化很大，低位变化很小，这样就很容易造成冲突了，所以这里把高低位都利用起来，从而解决了这个问题。</p>
<p>也正是因为与的这个操作，决定了HashMap的大小只能是2的幂次方。如果不是2的幂次方，会发生什么？</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211205184539044.png" alt="image-20211205184539044"></p>
<p>即使你在创建HashMap的时候指定了初始大小，HashMap在创建的时候也会调用下面这个方法来调整大小：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的作用看起来不是很直观，它的实际作用就是把cap变成第一个大于等于2的幂次方的数。例如：16还是16，13就会调整为16，17就会调整为32。</p>
<h2 id="4-resize方法（rehash）"><a href="#4-resize方法（rehash）" class="headerlink" title="4. resize方法（rehash）"></a>4. resize方法（rehash）</h2><p>当HashMap中的元素越来越多的时候，hash冲突的几率也越来越高，因为数组长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。</p>
<p>HashMap在进行扩容时，使用的rehash方式非常巧妙，因为每次扩容都是翻倍，与原来计算(n - 1) &amp; hash的结果相比，只是多了一个bit位，所以节点要么就在原来的位置，要么倍分配到”原位置 + 旧容量“这个位置。也正是因为这样巧妙的rehash方式，保证了rehash之后每个桶上的节点数必定小于等于原来桶上的节点数，即保证了rehash之后不会出现更严重的冲突。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment">     * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">     * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">     * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">     * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算扩容后的大小</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前容量超过最大容量，则无法进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过，扩为两倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的resize阈值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// 创建新的哈希表</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历旧哈希表的每个桶，重新计算桶里元素的新位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果桶上只有一个键值对，直接插入即可</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 红黑树处理冲突</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// 链式处理冲突</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">// 计算节点新位置</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个需要注意的地方，有些文章指出当哈希表的**<u>桶占用</u><strong>超过阈值时就进行扩容，这是不对的；实际上是当哈希表中的</strong><u>键值对个数</u>**超过阈值时，才进行扩容的。</p>
<h2 id="5-分析HashMap的put方法"><a href="#5-分析HashMap的put方法" class="headerlink" title="5. 分析HashMap的put方法"></a>5. 分析HashMap的put方法</h2><h3 id="5-1-HashMap的put方法执行过程"><a href="#5-1-HashMap的put方法执行过程" class="headerlink" title="5.1 HashMap的put方法执行过程"></a>5.1 HashMap的put方法执行过程</h3><p>看图说话：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211204125204443.png" alt="image-20211204125204443"></p>
<p>源码分析（JDK1.8）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">     * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment">     * value is replaced.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// hash(key)：对key的hashCode()做hash</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 步骤① tab为空则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 步骤② 计算index，并对null做处理</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 步骤③ 节点key存在，直接覆盖value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 步骤④ 判断该链为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 步骤⑤ 该链为链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 链表长度大于8，转换成红黑树处理</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 步骤⑥ 超过最大容量，扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码分析（JDK1.7）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">     * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment">     * value is replaced.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">// 计算出hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 根据hash值计算插入位置</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 遍历当前索引的冲突链，判断是否存在对应key</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">// 先判断hash值是否相同，再进行equals判断，存在对应key，则替换oldValue并返回oldValue</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希值不同并且equals判断返回false，将新添加的entry指向原有的entry</span></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤小总结（JDK1.8）：</p>
<blockquote>
<ol>
<li>判断键值对数组table[i]是否为空或为null，否则执行resize进行扩容。</li>
<li>根据键值key计算hash值得到插入的数组索引i，如果table[i] == null，直接新建节点添加，转向第六步；如果table[i]不为空，继续下一步。</li>
<li>判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，转向第六步；否则继续下一步。（这里的相同指的是hashCode以及equals）</li>
<li>判断table[i]是否为treeNode，即table[i]是否为红黑树，如果是，直接在树中插入键值对，转向第六步；否则继续下一步。</li>
<li>遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换成红黑树，在红黑树中执行插入操作，否则进行链表插入操作；遍历过程中若发现key已经存在直接覆盖value即可。</li>
<li>插入成功后，判断实际存在的键值对数量size是否超过了最大容量threshold。如果超过，进行扩容。</li>
</ol>
</blockquote>
<h3 id="5-2-HashMap在JDK1-8中新增的操作：红黑树中查找元素-getNode"><a href="#5-2-HashMap在JDK1-8中新增的操作：红黑树中查找元素-getNode" class="headerlink" title="5.2 HashMap在JDK1.8中新增的操作：红黑树中查找元素 getNode()"></a>5.2 HashMap在JDK1.8中新增的操作：红黑树中查找元素 getNode()</h3><p>底层源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.get and related methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap的查找方法是get，它通过计算指定key的哈希值后，调用内部方法getNode。而这个getNode方法就是根据哈希表元素个数与哈希值求模（使用(n - 1) &amp; hash）得到key所在的桶的头节点，如果头节点恰好是红黑树节点，就调用红黑树节点的getTreeNode方法，否则就遍历链表节点。</p>
<p>getTreeNode方法是通过调用树形节点的find方法进行查找：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Calls find for root node.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续查看find方法可以发现，因为添加时已经保证这个树是有序的，所以使用的是折半查找，效率很高。</p>
<p>和插入时一样的是，如果对比节点的哈希值和要查找的哈希值相等，就会判断key是否相等，相等就直接返回；不想等就从子树中递归查找。</p>
<h3 id="5-3-JDK1-8-VS-JDK1-7-扩容机制"><a href="#5-3-JDK1-8-VS-JDK1-7-扩容机制" class="headerlink" title="5.3 JDK1.8 VS JDK1.7 扩容机制"></a>5.3 JDK1.8 VS JDK1.7 扩容机制</h3><p>举个例子说明一下扩容过程。假设我们的hash算法就是简单的用“key mod table.size”。其中的哈希桶数组的table的size = 2。现在我们执行下面三条语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">map.put(<span class="number">7</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">map.put(<span class="number">5</span>, <span class="string">&quot;C&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>key = 3、7、5在mod 2 以后都冲突在table[1]这里了。这里假设负载因子loadFactor = 1，即当键值对的实际大小size大于table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组resize成4，然后所有的Node重新rehash的过程。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211205141209269.png" alt="image-20211205141209269"></p>
<p>下面我们看一下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展，所以，元素的位置要么是在原来的位置，要么是在原位置再移动2次幂的位置。看下面这张图，n为table的长度，图(a)表示扩容前的key1和key2两种key确定索引位置的示例，图(b)表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211205145249684.png" alt="image-20211205145249684"></p>
<p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit（红色），因此新的index就会发生这样的变化：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211205145957298.png" alt="image-20211205145957298"></p>
<p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是0还是1就好了，是0的话索引没变，是1的话索引变成“原索引 + oldCap”，下图为16扩充为32的resize示意图：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211205152506574.png" alt="image-20211205152506574"></p>
<p>这个设计确实非常巧妙，既省去了重新计算hash值的时间，同时由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。</p>
<h2 id="6-Fail-Fast机制"><a href="#6-Fail-Fast机制" class="headerlink" title="6. Fail-Fast机制"></a>6. Fail-Fast机制</h2><p>我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其它线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓的fail-fast策略。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211205205315564.png" alt="image-20211205205315564"></p>
<p>这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashIterator() &#123;</span><br><span class="line">    expectedModCount = modCount;</span><br><span class="line">    Node&lt;K,V&gt;[] t = table;</span><br><span class="line">    current = next = <span class="keyword">null</span>;</span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">        <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其它线程修改了map。</p>
<p>在HashMap中的API指出：由所有HashMap类的”collection视图方法“所返回的迭代器都是快速失败的。在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的remove方法，其它任何时间任何方式的修改，迭代器将抛出ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不冒在将来不确定的时间发生任意不确定行为的风险。</p>
<p>注意，迭代的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能做出任何坚决的保证。快速失败迭代器尽最大的努力抛出ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确的做法是：迭代器的快速失败行为应该仅用于检测程序错误。</p>
<h2 id="7-JDK1-7-VS-JDK1-8的性能"><a href="#7-JDK1-7-VS-JDK1-8的性能" class="headerlink" title="7. JDK1.7 VS JDK1.8的性能"></a>7. JDK1.7 VS JDK1.8的性能</h2><h3 id="7-1-put操作"><a href="#7-1-put操作" class="headerlink" title="7.1 put操作"></a>7.1 put操作</h3><ol>
<li><p>hash比较均匀的时候（负载因子 = 0.75）</p>
<table>
<thead>
<tr>
<th>次数</th>
<th>10</th>
<th>100</th>
<th>1000</th>
<th>10000</th>
<th>100000</th>
</tr>
</thead>
<tbody><tr>
<td>JDK1.7时间（ns）</td>
<td>1100</td>
<td>720</td>
<td>832</td>
<td>914</td>
<td>912</td>
</tr>
<tr>
<td>JDK1.8时间（ns）</td>
<td>1019</td>
<td>1023</td>
<td>1188</td>
<td>267</td>
<td>115</td>
</tr>
</tbody></table>
</li>
<li><p>hash不均匀的时候</p>
<table>
<thead>
<tr>
<th>次数</th>
<th>10</th>
<th>100</th>
<th>1000</th>
<th>10000</th>
<th>100000</th>
</tr>
</thead>
<tbody><tr>
<td>JDK1.7时间（ns）</td>
<td>2500</td>
<td>14310</td>
<td>8151</td>
<td>14137</td>
<td>154319</td>
</tr>
<tr>
<td>JDK1.8时间（ns）</td>
<td>3765</td>
<td>38144</td>
<td>60707</td>
<td>1182</td>
<td>373</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="7-2-get操作"><a href="#7-2-get操作" class="headerlink" title="7.2 get操作"></a>7.2 get操作</h3><ol>
<li><p>hash比较均匀的时候</p>
<table>
<thead>
<tr>
<th>次数</th>
<th>10</th>
<th>100</th>
<th>1000</th>
<th>10000</th>
<th>100000</th>
</tr>
</thead>
<tbody><tr>
<td>JDK1.7时间（ns）</td>
<td>900</td>
<td>550</td>
<td>627</td>
<td>302</td>
<td>626</td>
</tr>
<tr>
<td>JDK1.8时间（ns）</td>
<td>2773</td>
<td>1047</td>
<td>318</td>
<td>94</td>
<td>13</td>
</tr>
</tbody></table>
</li>
<li><p>hash不均匀的时候</p>
<table>
<thead>
<tr>
<th>次数</th>
<th>10</th>
<th>100</th>
<th>1000</th>
<th>10000</th>
<th>100000</th>
</tr>
</thead>
<tbody><tr>
<td>JDK1.7时间（ns）</td>
<td>2000</td>
<td>14950</td>
<td>4294</td>
<td>2167</td>
<td>16447</td>
</tr>
<tr>
<td>JDK1.8时间（ns）</td>
<td>3430</td>
<td>3932</td>
<td>2028</td>
<td>767</td>
<td>19</td>
</tr>
</tbody></table>
</li>
</ol>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>深入Java集合系列之——ArrayList</title>
    <url>/2021/12/03/%E6%B7%B1%E5%85%A5Java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94ArrayList/</url>
    <content><![CDATA[<blockquote>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><ol>
<li>ArrayList创建时的大小为0，当加入第一个元素时，进行第一次扩容，默认容量大小为10。（Java8之前为饿汉式，Java为懒汉式）</li>
<li>ArrayList每次扩容都以当前数组大小的1.5倍去扩容。</li>
<li>Vector创建时默认大小为10（饿汉式）。<span id="more"></span></li>
<li>Vector每次扩容都以当前数组大小的2倍去扩容，当指定了capacityIncrement之后，每次扩容仅在原先基础上增加capacityIncrement个单位空间。</li>
<li>ArrayList和Vector的add、get、size方法的复杂度都为O(1)，remove方法的复杂度为O(n)。</li>
<li>ArrayList是线程不安全的，Vector是线程安全的。</li>
</ol>
</blockquote>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>先看源码中的这段注释：</p>
<blockquote>
<p>Resizable-array implementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list. (This class is roughly equivalent to Vector, except that it is unsynchronized.)</p>
<p>……</p>
</blockquote>
<p>从这里，我们可以知道，ArrayList是一个动态数组，实现了List接口以及List相关的所有方法，它允许所有元素的插入，包括null。此外，ArrayList和Vector除了线程不同步之外，大致相等。仔细阅读源码中的注释，我们还可以知道：每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。当元素添加到ArrayList中时，其容量也会自动增长。</p>
<h2 id="2-ArrayList的实现"><a href="#2-ArrayList的实现" class="headerlink" title="2. ArrayList的实现"></a>2. ArrayList的实现</h2><p>对于ArrayList而言，它实现了List接口、底层使用数组保存所有元素。其操作基本上是对数组的操作。下面我们来分析ArrayList的源代码：</p>
<h3 id="2-1-底层使用数组实现"><a href="#2-1-底层使用数组实现" class="headerlink" title="2.1 底层使用数组实现"></a>2.1 底层使用数组实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment"> * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-属性"><a href="#2-2-属性" class="headerlink" title="2.2 属性"></a>2.2 属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认容量大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 空数组常量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">// 默认的空数组常量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">// 存放元素的数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"><span class="comment">// 数组中包含的元素个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// 数组的最大上限</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>ArrayList的属性非常少，就只有这些。其中最重要的莫过于elementData，ArrayList的所有方法都是建立在elementData之上。</p>
<h3 id="2-3-构造器"><a href="#2-3-构造器" class="headerlink" title="2.3 构造器"></a>2.3 构造器</h3><p>ArrayList提供了三种方式的构造器，可以构造一个指定初始容量的空列表和一个默认容量为0的列表(<u><em><strong>Java8之前默认容量为10</strong></em></u>)以及构造一个包含指定Collection的元素的列表，这些元素按照该Collection的迭代器返回它们的顺序排列的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    <span class="comment">// Java8之前为：this(10);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">            elementData = a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            elementData = Arrays.copyOf(a, size, Object[].class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-存储"><a href="#2-4-存储" class="headerlink" title="2.4 存储"></a>2.4 存储</h3><p>ArrayList提供了set(int index, E element)、boolean add(E e)、void add(int index, E element)、boolean addAll(Collection&lt;? extends E&gt; c)、boolean addAll(int index, Collection&lt;? extends E&gt; c)这些添加元素的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用指定的元素element替代列表中index位置上的元素，并返回以前位于该位置上的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将指定的元素e添加到列表尾部</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将指定的元素element插入index，如果index有元素，则向右移动当前位于index以及所有后续元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">	<span class="comment">// 如果数组长度不足，进行扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 将elementData中从index开始，长度为size-index的元素拷贝到从下标为index+1开始的新的elementData数组中</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按照指定Collection的迭代器所返回的元素顺序，将该Collection中的所有元素添加到列表尾部</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从指定位置开始，将指定Collection中的所有元素插入到列表中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList的add方法在插入之前，会先检查是否需要扩容，然后再把元素添加到数组中最后一个元素的后面。在calculateCapacity方法中，我们可以看见，当elementData为空数组时，会使用默认的大小去扩容。所以说，通过无参构造方法来创建ArrayList时，它的大小其实是为0的，只有在使用到的时候，才会通过grow方法去创建一个大小为10的数组。（这与Java8之前不同，Java8之前是属于饿汉式）</p>
<p>第一个add方法的复杂度为O(1)，虽然有时候会涉及到扩容操作，但是扩容的次数是非常少的，所以这一部分时间可以忽略不计。如果使用的是带指定下标的add方法，则复杂度为O(n)，因为涉及到对数组中元素的移动，这一操作是非常耗时的。</p>
<h3 id="2-5-读取"><a href="#2-5-读取" class="headerlink" title="2.5 读取"></a>2.5 读取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-删除"><a href="#2-6-删除" class="headerlink" title="2.6 删除"></a>2.6 删除</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 由于ArrayList中允许存放null，因此下面通过两种情况来分别处理</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-grow方法"><a href="#3-grow方法" class="headerlink" title="3.grow方法"></a>3.grow方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>grow方法是在数组进行扩容的时候用到的，从中我们可以看见，**<u>ArrayList每次扩容都是扩1.5倍</u>**，然后调用Arrays类的copyOf方法，把元素重新拷贝到一个新的数组中去。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生，或者根据实际需求，通过调用ensureCapacityInternal方法来手动增加ArrayList实例的容量。</p>
<p>ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过trimToSize方法来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = (size == <span class="number">0</span>)</span><br><span class="line">            ? EMPTY_ELEMENTDATA</span><br><span class="line">            : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Fail-Fast机制"><a href="#4-Fail-Fast机制" class="headerlink" title="4. Fail-Fast机制"></a>4. Fail-Fast机制</h2><p>ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。</p>
<h2 id="5-Vector"><a href="#5-Vector" class="headerlink" title="5.Vector"></a>5.Vector</h2><p>Vector很多方法都跟ArrayList一样，只是多加了个synchronized来保证线程安全。</p>
<p>Vector比ArrayList多了一个属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> capacityIncrement;</span><br></pre></td></tr></table></figure>

<p>这个属性是在扩容的时候用到的，它表示每次扩容只扩capacityIncrement个空间就足够了。该属性可以通过构造方法给它赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;    <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);	&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;    <span class="keyword">this</span>(<span class="number">10</span>); 	&#125;</span><br></pre></td></tr></table></figure>

<p>从构造方法中，我们可以看出Vector的默认大小也是10，而且它在初始化的时候就已将创建了数组了，这点跟ArrayList不一样，再看一下grow方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从grow方法中我们可以发现，newCapacity默认情况下是两倍的oldCapacity，而当指定了capacityIncrement的值之后，newCapacity = oldCapacity + capacityIncrement。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Map接口继承树</title>
    <url>/2021/12/03/Map%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E6%A0%91/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211203111736182.png" alt="image-20211203111736182"></p>
<ul>
<li>Map与Collection并列存在。用于保存具有**==映射关系==**得数据：key-value。</li>
<li>Map中的key和value都可以是任何引用类型得数据。</li>
<li>Map中的**==key用Set来存放，不允许重复==**，即同一个Map对象所对应的类，须重写hashCode和equals方法。</li>
</ul>
<span id="more"></span>

<ul>
<li><p>常用String类作为Map的“键”。</p>
</li>
<li><p>key和value之间存在单向一对一关系，即通过指定的key总能找到唯一的、确定的value。</p>
</li>
<li><p>Map接口的常用实现类：HashMap、TreeMap、LinkedHashMap和Properties。其中，<strong>HashMap是Map接口使用频率最高的实现类</strong>。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211203112634817.png" alt="image-20211203112634817"></p>
</li>
</ul>
<h2 id="1-常用方法"><a href="#1-常用方法" class="headerlink" title="1. 常用方法"></a>1. 常用方法</h2><ul>
<li>添加、删除、修改操作<ul>
<li>Object put(Object key,Object value); 将指定key-value添加到(或修改)当前Map对象中</li>
<li>void putAll(Map m); 将m中所有key-value对存放到当前map中</li>
<li>Object remove(Object key); 移出指定key的key-value对，并返回value</li>
<li>void clear(); 清空当前map中的所有数据</li>
</ul>
</li>
<li>元素查询的操作<ul>
<li>Object get(Object key); 获取指定key对应的value</li>
<li>boolean containsKey(Object key); 是否包含指定的key</li>
<li>boolean containsValue(Object value); 是否包含指定的value</li>
<li>int size(); 返回map中key-value对的个数</li>
<li>boolean isEmpty(); 判断当前map是否为空</li>
<li>boolean equals(Object obj); 判断当前map和参数对象obj是否相等</li>
</ul>
</li>
<li>元视图操作<ul>
<li>Set keySet(); 返回所以key构成的Set集合</li>
<li>Collection values(); 返回所有value构成的Collection集合</li>
<li>Set entrySet(); 返回所有key-value对构成的Set集合</li>
</ul>
</li>
</ul>
<h2 id="2-HashMap"><a href="#2-HashMap" class="headerlink" title="2. HashMap"></a>2. HashMap</h2><blockquote>
<ul>
<li><strong>==HashMap是Map接口使用频率最高的实现类。==</strong></li>
<li>允许使用null键和null值，与HashSet一样，不保证映射的顺序。</li>
<li>所有的key构成的集合是Set：无序的、不可重复的。所以要重写方法。</li>
<li>所有value构成的集合是Collection：无序的、可以重复的。所以要重写equals。</li>
<li>一个key-value构成一个entry。</li>
<li>所有的entry构成的集合是Set：无序的、不可重复的。</li>
<li>HashMap判断两个key相等的标准是：两个key通过equals方法返回true，hashCode值也相等。</li>
<li>HashMap判断两个value相等的标准是：两个value通过equals方法返回true。</li>
</ul>
</blockquote>
<h3 id="2-1-HashMap的存储结构"><a href="#2-1-HashMap的存储结构" class="headerlink" title="2.1 HashMap的存储结构"></a>2.1 HashMap的存储结构</h3><p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211203132751458.png" alt="image-20211203132751458"></p>
<h3 id="2-2-HashMap源码中的重要常量"><a href="#2-2-HashMap源码中的重要常量" class="headerlink" title="2.2 HashMap源码中的重要常量"></a>2.2 HashMap源码中的重要常量</h3><p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211203133703159.png" alt="image-20211203133703159"></p>
<h3 id="2-3-JDK-1-8之前"><a href="#2-3-JDK-1-8之前" class="headerlink" title="2.3 JDK 1.8之前"></a>2.3 JDK 1.8之前</h3><p>HashMap的内部存储结构其实是**<u>数组和链表</u>**的结合。当实例化一个HashMap时，系统会创建一个长度为Capacity的Entry数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。</p>
<p>每个bucket中存储一个元素，即一个Entry对象，但每一个Entry对象可以带一个引用变量，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Entry链。而且**==新添加的元素作为链表的head==**。</p>
<ul>
<li><p><strong>添加元素的过程</strong></p>
<p>向HashMap中添加entry1(key, value)，首先需要计算entry1中key的哈希值（根据key所在类的hashCode计算得到），这个哈希值经过处理以后，得到在底层Entry[]数组中要存储的位置i。如果位置i上没有元素，则entry1直接添加成功。如果位置i上已经存在entry2（或还有链表存在的entry3，entry4），则需要通过循环的方法，依次比较entry1中key和其它的entry。如果彼此hash值相同，则直接添加成功。如果hash值相同，继续比较二者是否equals。如果返回true，则使用entry1的value去替换equals为true的entry的value。如果遍历一遍以后，发现所有的equals返回都为false，则entry1仍可添加成功。entry1指向原有的entry元素。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211203165213991.png" alt="image-20211203165213991"></p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211203165106541.png" alt="image-20211203165106541"></p>
</li>
<li><p><strong>HashMap的扩容</strong></p>
<p>当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的，所以为了提高查询的效率，就要对HashMap的数组进行扩容，而**<u>在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。</u>**</p>
</li>
<li><p><strong>那么HashMap什么时候进行扩容呢？</strong></p>
<p>当HashMap中的元素个数超过数组大小 * loadFactor时，就会进行数组扩容，而loadFactor默认值就是0.75.也就是说，默认数组大小为16，当元素个数超过16 * 0.75 = 12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为2 * 16 = 32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以<em><strong>如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能</strong></em>。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211203164010966.png" alt="image-20211203164010966"></p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211203165721926.png" alt="image-20211203165721926"></p>
</li>
</ul>
<h3 id="2-4-JDK-1-8"><a href="#2-4-JDK-1-8" class="headerlink" title="2.4 JDK 1.8"></a>2.4 JDK 1.8</h3><p>HashMap的内部存储结构其实是**<u>数组 + 链表 + 红黑树</u>**的结合。当实例化一个HashMap时，会初始化initialCapacity和loadFactor，在put第一对映射关系时，系统会创建一个长度为initialCapacity的Node数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。</p>
<p>每个bucket中存储一个元素，即一个Node对象，但每一个Node对象可以带一个引用变量next，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Node链。也可能是一个一个TreeNode对象，每一个TreeNode对象可以有两个叶子节点left和right，因此，在一个桶中，就有可能生成一个TreeNode树。而新添加的元素作为链表的last，或树的叶子节点。</p>
<ul>
<li><p><strong>扩容和树形化</strong></p>
<p>扩容操作与JDK1.7相类似。当HashMap中的其中一个链的对象个数如果达到了8个，此时如果没有capacity没有达到64，那么HashMap会先扩容解决；如果已经达到了64，那么这个链会变成树，节点类型由Node变成TreeNode类型。当然，如果当映射关系被移除后，下次resize时判断树节点个数低于6个，也会把树再转化为链表。</p>
</li>
<li><p><strong>关于映射关系的key是否可以修改？</strong></p>
<p>不要修改！映射关系存储到HashMap中会存储key的hash值，这样就不用再每次查找时重新计算每一个Entry或Node(TreeNode)的hash值了，因此如果已经put到Map中的映射关系，再修改key的属性，而这个属性又参与hashCode值得计算，那么会导致匹配不上。</p>
</li>
</ul>
<h3 id="2-5-总结：JDK1-8相较于之前得变化"><a href="#2-5-总结：JDK1-8相较于之前得变化" class="headerlink" title="2.5 总结：JDK1.8相较于之前得变化"></a>2.5 总结：JDK1.8相较于之前得变化</h3><ol>
<li>HashMap map = new HashMap(); // 默认情况下，先不创建长度为16的数组</li>
<li>当首次调用map.put()时，再创建长度为16的数组</li>
<li>数组为Node类型，在JDK1.7中称为Entry类型</li>
<li>形成链表结构时，新添加的key-value对在链表的尾部（七上八下）</li>
<li>当数组指定索引位置的链表长度 &gt; 8时，且map中的数组的长度 &gt; 64时，次索引位置上的所有key-value对使用红黑树进行存储。</li>
</ol>
<h2 id="3-LinkedHashMap"><a href="#3-LinkedHashMap" class="headerlink" title="3. LinkedHashMap"></a>3. LinkedHashMap</h2><ul>
<li>HashMap的子类。</li>
<li>在HashMap存储结构的基础上，使用了一对双向链表来记录添加元素的顺序。</li>
<li>与LinkedHashSet类似，LinkedHashMap可以维护Map的迭代顺序：迭代顺序与key-value对的插入顺序一致。</li>
</ul>
<h2 id="4-TreeMap"><a href="#4-TreeMap" class="headerlink" title="4. TreeMap"></a>4. TreeMap</h2><ul>
<li>TreeMap存储key-value对时，需要根据key-value对进行排序，TreeMap可以保证所有的key-value对处于有序状态。</li>
<li>TreeMap底层使用红黑树结构存储数据。</li>
<li>TreeMap的key的排序：<ul>
<li>自然排序：TreeMap所有key必须实现Comparable接口，而且所有的key应该是同一个类的对象，否则将会抛出ClassCastException。</li>
<li>定制排序：创建TreeMap时，传入一个Comparator对象。此时不需要Map的key实现Comparable接口。</li>
</ul>
</li>
<li>TreeMap判断两个key相等的标准：两个key通过compareTo方法或者compare方法返回0.</li>
</ul>
<h2 id="5-Hashtable"><a href="#5-Hashtable" class="headerlink" title="5. Hashtable"></a>5. Hashtable</h2><ul>
<li>Hashtable是一个古老的Map实现类，JDK1.0就提供了，并且与HashMap不同的是，它是线程安全的。</li>
<li>Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用。</li>
<li>与HashMap不同，Hashtable不允许使用null作为key和value。</li>
<li>与HashMap一样，Hashtable也不能保证其中key-value对的顺序。</li>
<li>判断key、value相等的标准，同HashMap。</li>
</ul>
<h2 id="6-Properties"><a href="#6-Properties" class="headerlink" title="6. Properties"></a>6. Properties</h2><ul>
<li>Properties类是Hashtable的子类，该对象用于处理属性文件</li>
<li>由于属性文件里的key、value都是字符串类型，所以**<u>Properties里的key和value都是字符串类型</u>**。</li>
<li>存取数据时，建议使用setProperty(String key, String value)方法和getProperty(String key)方法。</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>集合面试题</title>
    <url>/2021/12/02/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="请问ArrayList-LinkedList-Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别？"><a href="#请问ArrayList-LinkedList-Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别？" class="headerlink" title="请问ArrayList/LinkedList/Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别？"></a>请问ArrayList/LinkedList/Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别？</h3><span id="more"></span>

<ul>
<li><p>ArrayList和LinkedList的异同</p>
<blockquote>
<p>二者都是线程不安全的，相对线程安全的Vector，执行效率高。</p>
<p>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作以及add和remove，LinkedList比较占优势，因为ArrayList要移动数据。</p>
</blockquote>
</li>
<li><p>ArrayList和Vector的区别</p>
<blockquote>
<p>Vector和ArrayList几乎是完全相同的，唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下，大多数的Java程序员使用ArrayList而不是Vector，因为同步完全可以由程序员自己来控制。Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。Vector还有一个子类Stack。</p>
</blockquote>
</li>
</ul>
<h3 id="负载因子值的大小，对HashMap有什么影响"><a href="#负载因子值的大小，对HashMap有什么影响" class="headerlink" title="负载因子值的大小，对HashMap有什么影响"></a>负载因子值的大小，对HashMap有什么影响</h3><blockquote>
<ul>
<li>负载因子的大小决定了HashMap的数据密度。</li>
<li>负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长，造成查询或插入时的比较次数增多，性能会下降。</li>
<li>负载因子越小，就越容易触发扩容，数据密度也越小，意味着发射如果碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内存空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间。</li>
<li>按照其它语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数。</li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>Collection接口继承树</title>
    <url>/2021/12/02/Collection%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E6%A0%91/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211202210335782.png" alt="image-20211202210335782"></p>
<ul>
<li><p>Collection接口是List、Set和Queue接口的父接口，该接口里定义的方法既可用于操作Set集合，也可用于操作List和Queue集合。</p>
<span id="more"></span></li>
<li><p>JDK不提供此接口的任何直接实现，而是提供更具体的子接口（如：Set和List）实现。</p>
</li>
<li><p>在Java5之前，Java集合会丢失容器中所有对象的数据类型，把所有对象都当成Object类型处理；从JDK5.0增加了泛型以后，Java集合可以记住容器中对象的数据类型。</p>
</li>
</ul>
<h2 id="1-Collection接口方法"><a href="#1-Collection接口方法" class="headerlink" title="1. Collection接口方法"></a>1. Collection接口方法</h2><p>1.1 添加 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(Object obj) </span><br><span class="line">addAll(Collection coll) </span><br></pre></td></tr></table></figure>

<p>1.2 获取有效元素的个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span></span><br></pre></td></tr></table></figure>

<p>1.3 清空集合 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span></span><br></pre></td></tr></table></figure>

<p>1.4 是否是空集合 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span></span><br></pre></td></tr></table></figure>

<p>1.5 是否包含某个元素 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object obj)</span> <span class="comment">// 是通过元素的equals方法来判断是否是同一个对象 </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection c)</span> <span class="comment">// 也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较。</span></span></span><br></pre></td></tr></table></figure>

<p>1.6 删除 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object obj)</span> <span class="comment">// 通过元素的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素 </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection coll)</span> <span class="comment">// 取当前集合的差集 </span></span></span><br></pre></td></tr></table></figure>

<p>1.7 取两个集合的交集 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection c)</span> <span class="comment">// 把交集的结果存在当前集合中，不影响c </span></span></span><br></pre></td></tr></table></figure>

<p>1.8 集合是否相等 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span></span><br></pre></td></tr></table></figure>

<p>1.9 转成对象数组 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] toArray() </span><br></pre></td></tr></table></figure>

<p>1.10 获取集合对象的哈希值 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hashCode() </span><br></pre></td></tr></table></figure>

<p>1.11 遍历 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">iterator() <span class="comment">// 返回迭代器对象，用于集合遍历</span></span><br></pre></td></tr></table></figure>

<h2 id="2-List接口"><a href="#2-List接口" class="headerlink" title="2. List接口"></a>2. List接口</h2><blockquote>
<ul>
<li>鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组。</li>
<li>List集合类中**==元素有序、且可重复==**，集合中的每个元素都有其对应的顺序索引。</li>
<li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</li>
<li>JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。</li>
</ul>
</blockquote>
<p>List除了从Collection集合继承的方法外，List集合里添加了一些根据索引来操作集合元素的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, Object ele)</span></span>; <span class="comment">// 在index位置插入ele元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection eles)</span></span>; <span class="comment">// 从index开始将eles中的所有元素添加进来</span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">// 获取指定index的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object obj)</span></span>; <span class="comment">// 返回obj在集合中首次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object obj)</span></span>; <span class="comment">// 返回obj在当前集合中末次出现的位置</span></span><br><span class="line"><span class="function">Object <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">// 移除指定index的元素，并返回此元素</span></span><br><span class="line"><span class="function">Object <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, Object ele)</span></span>; <span class="comment">// 设置指定index的元素为ele</span></span><br><span class="line"><span class="function">List <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span>; <span class="comment">// 返回从fromIndex到toIndex的子集合</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-ArrayList"><a href="#2-1-ArrayList" class="headerlink" title="2.1. ArrayList"></a>2.1. ArrayList</h3><blockquote>
<ul>
<li>ArrayList是LIst接口的典型实现类、主要实现类。</li>
<li>本质上，ArrayList是对象引用的一个“变长”数组。</li>
<li>ArrayList的JDK1.8之前与之后的实现区别？<ul>
<li>JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组。</li>
<li>JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当要添加第一个元素时再创建一个始容量为10的数组。</li>
</ul>
</li>
<li>Arrays.asList(…)方法返回的List集合，既不是ArrayList实例，也不是Vector实例。而是一个固定长度的List集合。</li>
</ul>
</blockquote>
<p>我们可以执行下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer[] datas = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(datas);</span><br><span class="line">    list.add(<span class="number">5</span>);</span><br><span class="line">    System.out.println(list.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果是抛异常UnsupportedOperationException。查看Arrays.asList()源码发现</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211202214748103.png" alt="image-20211202214748103"></p>
<p>asList方法返回的虽然是一个ArrayList，但并不是我们平常使用的那个。而是Arrays的一个静态内部类，并且这个类实现了Serializable接口，说明它是可序列化的，正如我们所使用的String一样，是不可变的。</p>
<h3 id="2-2-LinkedList"><a href="#2-2-LinkedList" class="headerlink" title="2.2 LinkedList"></a>2.2 LinkedList</h3><blockquote>
<ul>
<li>对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高</li>
<li>新增方法：<ul>
<li>void addFirst(Object obj)</li>
<li>void addLast(Object obj)</li>
<li>Object getFirst()</li>
<li>Object getLast()</li>
<li>Object removeFirst()</li>
<li>Object removeLast()</li>
</ul>
</li>
</ul>
</blockquote>
<p>LinkedList：**==双向链表==**，内部没有声明数组，而是定义了Node类型的first和last，用于记录首末元素。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211202220345414.png" alt="image-20211202220345414">同时，定义内部类Node，作为LinkedList中保存数据的基本结构。Node除了保存数据，还定义了两个变量：</p>
<ul>
<li>prev变量记录前一个元素的位置</li>
<li>next变量记录下一个元素的位置</li>
</ul>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211202220452685.png" alt="image-20211202220452685"></p>
<h3 id="2-3-Vector"><a href="#2-3-Vector" class="headerlink" title="2.3 Vector"></a>2.3 Vector</h3><p>Vector是一个古老的集合，JDK1.0就有了（ArrayList和LinkedList都是since1.2）。大多数操作与ArrayList相同，区别之处在于==<strong>Vector是线程安全的</strong>==。</p>
<p>新增方法：</p>
<ul>
<li>void addElement(Object obj)</li>
<li>void insertElementAt(Object obj, int index)</li>
<li>void setElementAt(Object obj, int index)</li>
<li>void removeElement(Object obj)</li>
<li>void removeAllElement()</li>
</ul>
<p>在各种List中，最好把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList。Vector总是比ArrayList慢，所以尽量避免使用。</p>
<h2 id="3-Set接口"><a href="#3-Set接口" class="headerlink" title="3. Set接口"></a>3. Set接口</h2><blockquote>
<ul>
<li>Set接口是Collection的子接口，Set接口没有提供额外的方法。</li>
<li>Set集合不允许包含相同的元素，如果试着把两个相同的元素加入同一个Set集合中，则添加操作失败。</li>
<li>Set判断两个对象是否相同不是使用==运算符，而是根据equals()方法。</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211202222826445.png" alt="image-20211202222826445"></p>
<h3 id="3-1-HashSet"><a href="#3-1-HashSet" class="headerlink" title="3.1 HashSet"></a>3.1 HashSet</h3><blockquote>
<ul>
<li>HashSet是Set接口的典型实现，大多数时候使用Set集合时都使用这个实现类。</li>
<li>HashSet按Hash算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。</li>
<li>HashSet具有以下特点：<ul>
<li>不能保证元素的排列顺序</li>
<li>不是线程安全的</li>
<li>集合元素可以是null（根据不重复原则，只能有一个）</li>
</ul>
</li>
<li>HashSet集合判断两个元素相等的标准：两个对象通过hashCode()方法比较相等，并且两个对象的equals()方法返回值也相等。</li>
<li>对于存放在Set容器中的对象，对应的类一定要重写equals和hashCode方法，以实现对象相等规则。即：”**==相等的对象必须具有相等的散列码==**“。</li>
</ul>
</blockquote>
<h4 id="3-1-1-向HashSet中添加元素的过程"><a href="#3-1-1-向HashSet中添加元素的过程" class="headerlink" title="3.1.1 向HashSet中添加元素的过程"></a>3.1.1 向HashSet中添加元素的过程</h4><p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211203090912611.png" alt="image-20211203090912611"></p>
<p>对于添加成功的情况二和情况三而言：元素a与已经存在指定索引位置上数据以链表的方式存储。</p>
<p>JDK7：元素a放到数组中，指向原来的元素。</p>
<p>JDK8：原来的元素在数组中，指向元素a。</p>
<p>总结：**==七上八下==**</p>
<blockquote>
<p>注释：HashSet底层：数组 + 链表的结构（前提：JDK7）。初始容量为16，当如果使用率超过0.75，就会扩大容量为原来的2倍。</p>
</blockquote>
<h4 id="3-1-2-重写hashCode-方法的基本原则"><a href="#3-1-2-重写hashCode-方法的基本原则" class="headerlink" title="3.1.2 重写hashCode()方法的基本原则"></a>3.1.2 重写hashCode()方法的基本原则</h4><ul>
<li>在程序运行时，同一个对象多次调用hashCode方法应该返回相同的值。</li>
<li>当两个对象的equals方法比较返回true时，这两个对象的hashCode方法的返回值也应相等。</li>
<li>对象中用作equals方法比较的Field，都应该用来计算hashCode值。</li>
</ul>
<h4 id="3-1-3-重写equals-方法的基本原则"><a href="#3-1-3-重写equals-方法的基本原则" class="headerlink" title="3.1.3 重写equals()方法的基本原则"></a>3.1.3 重写equals()方法的基本原则</h4><p>以自定义的Customer类为例，何时需要重写equals？</p>
<ul>
<li>当一个类有自己特有的”逻辑相等“概念，当改写equals的时候，总是要改写hashCode，根据一个类的equals方法（改写后），两个截然不同的实例有可能在逻辑上是相等的，但是，根据Object.hashCode方法，它们仅仅是两个对象。</li>
<li>因此，违反了”**==相等的对象必须具有相等的散列码==**“。</li>
<li>结论：复写equals方法的时候一般都需要同时复写hashCode方法。<strong>通常参与计算hashCode的对象的属性也应该参与到equals中进行计算</strong>。</li>
</ul>
<h4 id="3-1-4-Eclipse-IDEA工具里hashCode的重写"><a href="#3-1-4-Eclipse-IDEA工具里hashCode的重写" class="headerlink" title="3.1.4 Eclipse/IDEA工具里hashCode的重写"></a>3.1.4 Eclipse/IDEA工具里hashCode的重写</h4><p>在自定义类中可以调用工具自动重写equals和hashCode。问题：为什么用Eclipse/IDEA复写hashCode方法，有31这个数字？</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211203092415291.png" alt="image-20211203092415291"></p>
<ul>
<li>选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的”冲突“就越少，查找起来效率也会提高。（减少冲突）</li>
<li>31只占用5bits（1 1111），相乘造成数据溢出的概率较小。</li>
<li>31可以由 <u>*i × 31 == (i &lt;&lt; 5) -1*</u> 来表示，现在很多虚拟机里面都有做相关优化。（提高算法效率）</li>
<li>31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数背身和被乘数还有1来整除！（减少冲突）</li>
</ul>
<h3 id="3-2-LinkedHashSet"><a href="#3-2-LinkedHashSet" class="headerlink" title="3.2 LinkedHashSet"></a>3.2 LinkedHashSet</h3><blockquote>
<ul>
<li>LinkedHashSet是HashSet的子类。</li>
<li>LinkedHashSet根据元素的hashCode值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以**==插入顺序==**保存的。</li>
<li><strong>LinkedHashSet插入性能略低于HashSet</strong>，但在迭代访问Set里的全部元素时有很好的性能。</li>
<li>LinkedHashSet不允许集合元素重复</li>
</ul>
</blockquote>
<h3 id="3-3-TreeSet"><a href="#3-3-TreeSet" class="headerlink" title="3.3 TreeSet"></a>3.3 TreeSet</h3><blockquote>
<ul>
<li>TreeSet是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态。</li>
<li>TreeSet底层使用<strong>红黑树</strong>结构存储数据。</li>
<li>新增的方法：<ul>
<li>Comparator comparator() </li>
<li>Object first() </li>
<li>Object last() </li>
<li>Object lower(Object e) </li>
<li>Object higher(Object e) </li>
<li>SortedSet subSet(fromElement, toElement) </li>
<li>SortedSet headSet(toElement) </li>
<li>SortedSet tailSet(fromElement)</li>
</ul>
</li>
<li>TreeSet两种排序方法：自然排序和定制排序。默认采用自然排序。</li>
<li>特点：有序，查询速度比List快。</li>
<li></li>
</ul>
</blockquote>
<h4 id="3-3-1-自然排序"><a href="#3-3-1-自然排序" class="headerlink" title="3.3.1 自然排序"></a>3.3.1 自然排序</h4><p>TreeSet会调用集合元素的compareTo(Object obj)方法来比较元素之间的大小关系，然后将集合元素按升序（默认情况）排列。</p>
<p>如果试图把一个对象添加到TreeSet时，则该对象的类必须实现Comparable接口，而实现了Comparable的类又必须实现compareTo方法，两个对象即通过compareTo方法的返回值来比较大小。</p>
<p>Comparable的典型实现：</p>
<ul>
<li>BigDecimal、BigInteger以及所有的数组型对应的包装类：按它们对应的数值大小进行比较。</li>
<li>Character：按字符的unicode值来进行比较。</li>
<li>Boolean：true对应的包装类实例大于false对应的包装类实例。</li>
<li>String：按字符串中字符的unicode值进行比较。</li>
<li>Date、Time：后边的时间、日期比前面的大。</li>
</ul>
<blockquote>
<ul>
<li>向TreeSet中添加元素时，只有第一个元素无须比较compareTo方法，后面添加的所有元素都会调用compareTo方法进行比较。</li>
<li>因为只有相同类的两个实例才会比较大小，所以向TreeSet中添加的应该是同一个类的对象。</li>
<li>对于TreeSet集合而言，它判断两个对象是否相等的唯一标准是：两个对象通过compareTo方法比较返回值。</li>
<li>当需要把一个对象放入TreeSet中，重写该对象对应的equals方法时，应保证该方法与compareTo方法有一致的结果；如果两个对象通过equals方法比较返回true，则通过compareTo方法比较应返回0.否则，让人难以理解。</li>
</ul>
</blockquote>
<h4 id="3-3-2-定制排序"><a href="#3-3-2-定制排序" class="headerlink" title="3.3.2 定制排序"></a>3.3.2 定制排序</h4><p>TreeSet的自然排序要求元素所属的类实现Comparable接口，如果元素所属的类没有实现Comparable即可，或不希望按照升序的方式排列元素或希望按照其它属性大小进行排序，则考虑使用定制排序。定制排序，通过Comparator接口来实现，需要重写compare(T o1, T o2)方法。</p>
<p>利用int compare(T o1, T o2)方法，比较o1和o2大小，返回正整数，表示o1大；0表示相等；负整数表示o2大。</p>
<p>要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。此时，仍然只能向TreeSet中添加类型相同的对象。否则发生ClassCastException异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Comparator comparator = (o1, o2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Customer &amp;&amp; o2 <span class="keyword">instanceof</span>  Customer) &#123;</span><br><span class="line">            Customer u1 = (Customer) o1;</span><br><span class="line">            Customer u2 = (Customer) o2;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(u1.getAge(), u2.getAge());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入类型不匹配！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    TreeSet treeSet = <span class="keyword">new</span> TreeSet(comparator);</span><br><span class="line">    treeSet.add(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合框架概述</title>
    <url>/2021/12/02/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h2><p>Java最初的版本只为最常用的数据结构提供了很少的一组类：Vector、Stack、Hashtable、BitSet与Enumeration接口，其中的Enumeration接口提供了一种用于访问任意容器中各个元素的抽象机制。</p>
<p>随着JavaSE1.2的问世，设计人员感到是推出一组功能完善的数据结构的时机了。面对一大堆相互矛盾的设计策略，他们希望让类库规模小且易于学习，而不希望像C++的“标准模板库”（即STL）那样复杂，但却又希望能够得到STL率先推出的“泛型算法”所具有的优点。本节将介绍Java集合框架的基本设计，展示使用它们的方法，并解释一些颇具争议的特性背后的考虑。</p>
<h3 id="1-将集合的接口与实现分离"><a href="#1-将集合的接口与实现分离" class="headerlink" title="1. 将集合的接口与实现分离"></a>1. 将集合的接口与实现分离</h3><p>与现代的数据结构类库的常见情况一样，Java集合类库也将接口（interface）与实现（implementation）分离。首先，看一下人们熟悉的数据结构——队列（queue）是如何分离的。</p>
<p>队列接口指出可以在队列的尾部添加元素，在队列的头部删除元素，并且可以查找队列中元素的个数。当需要收集对象，并按照“先进先出”的规则检索对象时就应该使用队列。</p>
<p>队列接口的最简形式可能类似下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123; <span class="comment">// a simplified form of the interface in the standard library</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口并没有说明队列是如何实现的。队列通常有两种实现方式：</p>
<ul>
<li>一种是使用循环数组</li>
<li>另一种是使用链表</li>
</ul>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211202153503296.png" alt="image-20211202153503296"></p>
<p>每一个实现都可以通过一个实现了Queue接口的类表示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularArrayQueue</span> &lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="number">0</span>;    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="keyword">false</span>;    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;        <span class="keyword">return</span> <span class="keyword">false</span>;    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="keyword">null</span>;    &#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="number">0</span>;    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="keyword">false</span>;    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;        <span class="keyword">return</span> <span class="keyword">false</span>;    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="keyword">null</span>;    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注释：实际上，Java类库没有名为CircularArrayQueue和LinkedListQueue的类。这里只是以这些类作为示例，解释一下集合接口与实现在概念上的不同。如果需要一个循环数组队列，就可以使用ArrayDeque类。如果需要一个链表队列，就直接使用LinkedList类，这个类实现了Queue接口。</p>
</blockquote>
<p>当在程序中使用队列时，一旦构建了集合就不需要知道究竟使用了哪种实现。因此，只有在构建集合对象时，使用具体的类才有意义。也就是在调用构造器的地方，指明你需要使用的接口实现类。具体做法就是在创建一个集合对象时，我们一般静态创建一个接口，在调用构造器new这个对象时，再指明具体的接口实现类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Customer&gt; expressLane = <span class="keyword">null</span>;</span><br><span class="line">expressLane = <span class="keyword">new</span> CircularArrayQueue();</span><br><span class="line"><span class="comment">// 也就等价于</span></span><br><span class="line">Queue&lt;Customer&gt; expressLane = <span class="keyword">new</span> CircularArrayQueue();</span><br><span class="line"><span class="comment">// 这种创建集合对象的做法也是我们在实际开发中通常所用的方法</span></span><br></pre></td></tr></table></figure>

<p>在研究API文档时，会发现另外一组名字以Abstract开头的类，例如，AbstractQueue。这些类是为类库设计者而设计的。如果想要实现自己的队列类（也许不太可能），会发现扩展AbstractQueue类要比实现Queue接口中的所有方法轻松得多。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211202182324676.png" alt="image-20211202182324676"></p>
<h3 id="2-Collection接口"><a href="#2-Collection接口" class="headerlink" title="2. Collection接口"></a>2. Collection接口</h3><p>在Java类库中，集合类的基本接口是Collection接口。这个接口有两个基本方法add和iterator()。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211202182633987.png" alt="image-20211202182633987"></p>
<p>add用于向集合中添加元素。如果添加成功就返回true，否则返回false。例如，如果你试图向集合中添加一个已经存在的对象，会返回false。因为集合中不允许存在重复的对象。</p>
<p>iterator用于返回一个实现了Iterator接口的对象。可以使用这个迭代器对象依次访问集合中的元素。</p>
<h3 id="3-迭代器"><a href="#3-迭代器" class="headerlink" title="3. 迭代器"></a>3. 迭代器</h3><p>Iterator接口包含4个方法</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211202184905848.png" alt="image-20211202184905848"></p>
<p>通过反复调用next方法，可以逐个访问集合中的每个元素。但是，如果到了集合的末尾，next方法将抛出一个NoSuchElementException。因此，需要在调用next之前调用hasNext方法来判断是否下一个元素是否为null。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211202185152900.png" alt="image-20211202185152900"></p>
<p>如果想要查看集合中的所有元素，就请求一个迭代器，并在hasNext返回true时反复地调用next方法。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; c = ......;</span><br><span class="line">Iterator&lt;String&gt; iter = c.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">    String element = iter.next();</span><br><span class="line">    <span class="keyword">do</span> something with element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用“foreach”循环可以更加简练地表示同样的操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(String element : c) &#123;</span><br><span class="line"> 	<span class="keyword">do</span> something with element   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器简单地将“foreach”循环翻译为带有迭代器的循环。</p>
<p>“foreach”循环可以与任何实现了Iterable接口的对象一起工作，这个接口包含三个抽象方法(Java SE 8之后)：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211202190640844.png" alt="image-20211202190640844"></p>
<p>Collection接口扩展了Iterable接口。因此，对于标准类库中的任何集合都可以使用“foreach”循环。</p>
<p>在Java集合类库中，应该将迭代器认为是位于两个元素之间。<strong>当调用next时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用</strong>。</p>
<blockquote>
<p>注释：这里还有一个有用的推论。可以将Iterator.next与InputStream.read看作为等效的。从数据流中读取一个字节，就会自动地“消耗掉”这个字节。下一次调用read将会消耗并返回输入的下一个字节。用同样的方式，反复地调用next就可以读取集合中所有元素。</p>
</blockquote>
<p>Iterator接口的remove方法将会删除上次调用next方法时返回的元素。在大多数情况下，在决定删除某个元素之前应该先看一下这个元素是很具有实际意义的。然而，<strong>如果先要删除指定位置上的元素，仍然需要越过这个元素</strong>。更为重要的是，对next方法和remove方法的调用具有互相依赖性。<u><strong>如果调用remove之前没有调用next将是不合法的。如果这样做，将会抛出IllegalStateException异常</strong>。</u></p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211202192504271.png" alt="image-20211202192504271"></p>
<p>如果想删除两个相邻的元素，不能直接地调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">it.remove();</span><br><span class="line">it.remove(); <span class="comment">// Error!!!</span></span><br></pre></td></tr></table></figure>

<p>相反，必须先调用next越过将要删除的元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">it.remove();</span><br><span class="line">it.next();</span><br><span class="line">it.remove(); <span class="comment">// OK!</span></span><br></pre></td></tr></table></figure>

<h3 id="4-泛型实用方法"><a href="#4-泛型实用方法" class="headerlink" title="4. 泛型实用方法"></a>4. 泛型实用方法</h3><p>由于Collection与Iterator都是泛型接口，可以编写操作任何集合类型的实用方法。例如，下面是一个检测任意结合是否包含指定元素的泛型方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Collection&lt;E&gt; c, Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(E element : c) </span><br><span class="line">        <span class="keyword">if</span>(element.equals(obj))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>Java类库设计者认为：这些实用方法中的某些方法非常有用，应该将它们提供给用户使用。这样，类库的使用者就不必自己重新构建这些方法了。contains就是这样一个实用方法。</p>
<p>事实上，Collection接口声明了很多有用的方法，所有的实现类都必须提供这些方法。在这些方法中，有很多方法的功能非常明确，不需要过多的解释。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211202194211291.png" alt="image-20211202194211291"></p>
<p>当然，如果实现Collection接口的每一个类都要提供如此多的例行方法将是一件很烦人的事情。为了能够让实现者更容易地实现这个接口，Java类库提供了一个类AbstractCollection，它将基础方法size和iterator抽象化了，但是在此提供了例行方法。例如：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211202194307915.png" alt="image-20211202194307915"></p>
<h3 id="5-集合框架中的接口"><a href="#5-集合框架中的接口" class="headerlink" title="5. 集合框架中的接口"></a>5. 集合框架中的接口</h3><p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211202195210125.png" alt="image-20211202195210125"></p>
<h3 id="6-Collections工具类"><a href="#6-Collections工具类" class="headerlink" title="6. Collections工具类"></a>6. Collections工具类</h3><blockquote>
<ul>
<li>Collections是一个操作Set、List和Map等集合的工具类。</li>
<li>Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法</li>
</ul>
</blockquote>
<ul>
<li><p>排序操作（均为static方法）</p>
<ul>
<li>reverse(List); 反转List中元素的顺序</li>
<li>shuffle(List); 对List集合元素进行随机排序</li>
<li>sort(List); 根据元素的自然顺序对指定List集合元素按升序排序</li>
<li>sort(List, Comparator); </li>
<li>swap(List, int, int); 将指定list集合中的i出元素和j出元素进行交换</li>
</ul>
</li>
<li><p>查找、替换</p>
<ul>
<li>Object max(Collection); 自然排序后，返回给定集合中最大元素</li>
<li>Object max(Collection，Comparator);</li>
<li>Object min(Collection);</li>
<li>Object min(Collection，Comparator);</li>
<li>int frequency(Collection，Object); 返回指定集合中指定元素的出现次数</li>
<li>void copy(List dest,List src);</li>
<li>boolean replaceAll(List list，Object oldVal，Object newVal); 使用新值替换List对象的所有旧值</li>
</ul>
</li>
<li><p>同步机制</p>
<p>Collections类中提供了多个synchronizedXxx方法，该方法可以将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211203191631324.png" alt="image-20211203191631324"></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
</search>
