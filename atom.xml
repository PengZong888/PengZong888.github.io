<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>青稞</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-12-05T13:07:33.451Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>pengbin007</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入Java集合系列之——HashMap</title>
    <link href="http://example.com/2021/12/04/%E6%B7%B1%E5%85%A5Java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94HashMap/"/>
    <id>http://example.com/2021/12/04/%E6%B7%B1%E5%85%A5Java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94HashMap/</id>
    <published>2021-12-04T01:32:40.000Z</published>
    <updated>2021-12-05T13:07:33.451Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;1-传统HashMap的缺点&quot;&gt;&lt;a href=&quot;#1-传统HashMap的缺点&quot; class=&quot;headerlink&quot; title=&quot;1. 传统HashMap的缺点&quot;&gt;&lt;/a&gt;1. 传统HashMap的缺点&lt;/h2&gt;&lt;p&gt;HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;JDK1.8以前HashMap的实现是 数组 + 链表，即使哈希函数取得再好，也很难达到元素百分百均与分布。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当HashMap中有大量的元素都存放到同一个桶中时，这个桶下由一条长长的链表，这个时候HashMap就相当于一个单链表，加入单链表有n个元素，遍历的时间复杂度就是O(n)，完全失去了它的优势。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;针对这种情况，JDK1.8中引入了红黑树(查找时间复杂度为O(logn))来优化这个问题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="集合" scheme="http://example.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>深入Java集合系列之——ArrayList</title>
    <link href="http://example.com/2021/12/03/%E6%B7%B1%E5%85%A5Java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94ArrayList/"/>
    <id>http://example.com/2021/12/03/%E6%B7%B1%E5%85%A5Java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94ArrayList/</id>
    <published>2021-12-03T11:25:50.000Z</published>
    <updated>2021-12-03T14:47:45.414Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;h2 id=&quot;6-总结&quot;&gt;&lt;a href=&quot;#6-总结&quot; class=&quot;headerlink&quot; title=&quot;6. 总结&quot;&gt;&lt;/a&gt;6. 总结&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;ArrayList创建时的大小为0，当加入第一个元素时，进行第一次扩容，默认容量大小为10。（Java8之前为饿汉式，Java为懒汉式）&lt;/li&gt;
&lt;li&gt;ArrayList每次扩容都以当前数组大小的1.5倍去扩容。&lt;/li&gt;
&lt;li&gt;Vector创建时默认大小为10（饿汉式）。</summary>
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="集合" scheme="http://example.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Map接口继承树</title>
    <link href="http://example.com/2021/12/03/Map%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E6%A0%91/"/>
    <id>http://example.com/2021/12/03/Map%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E6%A0%91/</id>
    <published>2021-12-03T03:12:55.000Z</published>
    <updated>2021-12-03T10:27:52.766Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211203111736182.png&quot; alt=&quot;image-20211203111736182&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Map与Collection并列存在。用于保存具有**==映射关系==**得数据：key-value。&lt;/li&gt;
&lt;li&gt;Map中的key和value都可以是任何引用类型得数据。&lt;/li&gt;
&lt;li&gt;Map中的**==key用Set来存放，不允许重复==**，即同一个Map对象所对应的类，须重写hashCode和equals方法。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="集合" scheme="http://example.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>集合面试题</title>
    <link href="http://example.com/2021/12/02/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2021/12/02/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-12-02T14:11:55.000Z</published>
    <updated>2021-12-05T13:10:13.492Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;h3 id=&quot;请问ArrayList-LinkedList-Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别？&quot;&gt;&lt;a href=&quot;#请问ArrayList-LinkedList-Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别？&quot; class=&quot;headerlink&quot; title=&quot;请问ArrayList/LinkedList/Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别？&quot;&gt;&lt;/a&gt;请问ArrayList/LinkedList/Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别？&lt;/h3&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="集合" scheme="http://example.com/tags/%E9%9B%86%E5%90%88/"/>
    
    <category term="面经" scheme="http://example.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>Collection接口继承树</title>
    <link href="http://example.com/2021/12/02/Collection%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E6%A0%91/"/>
    <id>http://example.com/2021/12/02/Collection%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E6%A0%91/</id>
    <published>2021-12-02T12:50:18.000Z</published>
    <updated>2021-12-03T03:28:01.272Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211202210335782.png&quot; alt=&quot;image-20211202210335782&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Collection接口是List、Set和Queue接口的父接口，该接口里定义的方法既可用于操作Set集合，也可用于操作List和Queue集合。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="集合" scheme="http://example.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java集合框架概述</title>
    <link href="http://example.com/2021/12/02/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2021/12/02/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/</id>
    <published>2021-12-02T05:40:01.000Z</published>
    <updated>2021-12-05T13:10:18.478Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Java集合框架&quot;&gt;&lt;a href=&quot;#Java集合框架&quot; class=&quot;headerlink&quot; title=&quot;Java集合框架&quot;&gt;&lt;/a&gt;Java集合框架&lt;/h2&gt;&lt;p&gt;Java最初的版本只为最常用的数据结构提供了很少的一组类：Vector、Stack、Hashtable、BitSet与Enumeration接口，其中的Enumeration接口提供了一种用于访问任意容器中各个元素的抽象机制。&lt;/p&gt;
&lt;p&gt;随着JavaSE1.2的问世，设计人员感到是推出一组功能完善的数据结构的时机了。面对一大堆相互矛盾的设计策略，他们希望让类库规模小且易于学习，而不希望像C++的“标准模板库”（即STL）那样复杂，但却又希望能够得到STL率先推出的“泛型算法”所具有的优点。本节将介绍Java集合框架的基本设计，展示使用它们的方法，并解释一些颇具争议的特性背后的考虑。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="集合" scheme="http://example.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
</feed>
