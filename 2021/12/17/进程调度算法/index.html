<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    进程调度算法 |
    
    青稞
  </title>
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="青稞" type="application/atom+xml">
</head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-进程调度算法" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h1 class="article-title" itemprop="name">
  进程调度算法
</h1>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/12/17/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2021-12-17T03:47:07.000Z" itemprop="datePublished">2021-12-17</time>
</a>
      
    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>操作系统中存在许多种调度算法，有的调度算法适用于作业调度，有的调度算法适用于进程调度，有的两者皆适用。</p>
<h1 id="1-先来先服务（FCFS）调度算法"><a href="#1-先来先服务（FCFS）调度算法" class="headerlink" title="1. 先来先服务（FCFS）调度算法"></a>1. 先来先服务（FCFS）调度算法</h1><ul>
<li><p>算法思想</p>
<p>主要从“公平”的角度考虑（类似生活中排队买东西）。</p>
</li>
<li><p>算法规则</p>
<p>按照作业/进程到达的先后顺序进行服务。</p>
</li>
<li><p>用于作业/进程调度</p>
<p>用于作业调度时，考虑的是哪个作业先到达后备队列；</p>
<p>用于进程调度时，考虑的是哪个进程先到达就绪队列。</p>
</li>
<li><p>是否可抢占</p>
<p>非抢占式算法。</p>
</li>
<li><p>优缺点</p>
<ul>
<li>公平、算法实现简单。</li>
<li>排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即，<strong>FCFS算法对长作业有利，对短作业不利。</strong></li>
</ul>
</li>
<li><p>是否会导致饥饿</p>
<p>不会。</p>
</li>
</ul>
<h1 id="2-短作业优先（SJF）调度算法"><a href="#2-短作业优先（SJF）调度算法" class="headerlink" title="2. 短作业优先（SJF）调度算法"></a>2. 短作业优先（SJF）调度算法</h1><ul>
<li><p>算法思想</p>
<p>追求最少的平均等待时间，最少的平均周转时间、最少的平均带权周转时间。</p>
</li>
<li><p>算法规则</p>
<p>最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）。</p>
</li>
<li><p>用于作业/进程调度</p>
<p>既可用于作业调度，也可用于进程调度。用于进程调度时称为”短进程优先（SPF）“算法。</p>
</li>
<li><p>是否可抢占</p>
<p>SJF和SPF是<strong>非抢占式</strong>的算法。但是<strong>也有抢占式的版本——最短剩余时间优先算法</strong>（SRTN，Shortest Remaining Time Next）。</p>
</li>
<li><p>优缺点</p>
<ul>
<li>”最短的“平均等待时间、平均周转时间。</li>
<li>不公平。<strong>对短作业有利，对长作业不利</strong>。可能产生<strong>饥饿现象</strong>。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先。</li>
</ul>
</li>
<li><p>是否会导致饥饿</p>
<p>会，如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生”<strong>饥饿</strong>“现象，如果一直得不到服务，则称为”<strong>饿死</strong>“。</p>
</li>
</ul>
<h1 id="3-优先级调度算法"><a href="#3-优先级调度算法" class="headerlink" title="3. 优先级调度算法"></a>3. 优先级调度算法</h1><ul>
<li><p>算法思想</p>
<p>随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序。</p>
</li>
<li><p>算法规则</p>
<p>调度时选择优先级最高的作业/进程。</p>
</li>
<li><p>用于作业/进程调度</p>
<p>既可以用于作业调度，也可以用于进程调度。甚至，还会用于I/O调度中。</p>
</li>
<li><p>是否可抢占</p>
<p>抢占式、非抢占式都有。做题时的区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占。</p>
</li>
<li><p>优缺点</p>
<ul>
<li>用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活调整对各种作业/进程的偏好程度。</li>
<li>若源源不断有高优先级进程到来，则可能会导致饥饿。</li>
</ul>
</li>
<li><p>是否会导致饥饿<br>会</p>
</li>
<li><p>补充</p>
<ul>
<li>就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近对头的位置。</li>
<li>根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种：<ul>
<li>静态优先级：创建进程时确定，之后一直不变。</li>
<li>动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。</li>
</ul>
</li>
<li>如何合理地设置各类进程的优先级？<ul>
<li>通常：系统进程优先级高于用户进程，前台进程高于后台进程。</li>
<li>OS更偏好I/O型进程（或称I/O繁忙型进程）。</li>
<li>与I/O型进程相对的是计算型进程（或称CPU繁忙型进程）。</li>
</ul>
</li>
<li>如果采用的是动态优先级，什么时候应该调整？<ul>
<li>可以从追求公平、提升资源利用率等角度考虑。</li>
<li>如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级。</li>
<li>如果某进程占用处理机运行了很长时间，则可适当降低其优先级。</li>
<li>如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="4-高响应比优先调度算法"><a href="#4-高响应比优先调度算法" class="headerlink" title="4. 高响应比优先调度算法"></a>4. 高响应比优先调度算法</h1><ul>
<li><p>算法思想</p>
<p>要综合考虑作业/进程的等待时间和要求服务的时间。</p>
</li>
<li><p>算法规则</p>
<p>在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务。</p>
<ul>
<li>响应比 = (等待时间 + 要求服务时间) / 要求服务时间</li>
</ul>
</li>
<li><p>用于作业/进程调度</p>
<p>既可用于作业调度，也可用于进程调度。</p>
</li>
<li><p>是否可抢占</p>
<p>非抢占式算法，因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比。</p>
</li>
<li><p>优缺点</p>
<p>综合考虑了等待时间和运行时间（要求服务时间）；</p>
<p>等待时间相同时，要求服务时间短的优先（SJF的优点）；</p>
<p>要求服务时间相同时，等待时间长的优先（FCFS的优点）；</p>
<p>对于长作业来说，随着等待时间越来越久，其响应比也会也来越大，从而避免了长作业饥饿的问题。</p>
</li>
<li><p>是否会导致饥饿</p>
<p>不会。</p>
</li>
</ul>
<h1 id="5-时间片轮转调度算法"><a href="#5-时间片轮转调度算法" class="headerlink" title="5. 时间片轮转调度算法"></a>5. 时间片轮转调度算法</h1><ul>
<li><p>算法思想</p>
<p>公平的、轮流为各个进程服务，让每个进程在一定时间间隔内都可以得到响应。</p>
</li>
<li><p>算法规则</p>
<p>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</p>
</li>
<li><p>用于作业/进程调度</p>
<p>用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）。</p>
</li>
<li><p>是否可抢占</p>
<p>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式算法。由时钟装置发出的时钟中断来通知CPU时间片已到。</p>
</li>
<li><p>优缺点</p>
<ul>
<li>公平；响应快，适用于分时操作系统。</li>
<li>由于高频率的进程切换，因此有一定的开销；不区分任务的紧急程度。</li>
</ul>
</li>
<li><p>是否会导致饥饿</p>
<p>不会。</p>
</li>
<li><p>补充</p>
<ul>
<li>时间片太大，使得每个进程可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。</li>
<li>时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的</li>
</ul>
</li>
</ul>
<h1 id="6-多级反馈队列调度算法（融合了前几种算法的优点）"><a href="#6-多级反馈队列调度算法（融合了前几种算法的优点）" class="headerlink" title="6. 多级反馈队列调度算法（融合了前几种算法的优点）"></a>6. 多级反馈队列调度算法（融合了前几种算法的优点）</h1><ul>
<li><p>算法思想</p>
<p>对其它调度算法的折中权衡。</p>
</li>
<li><p>算法规则</p>
<ul>
<li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。</li>
<li>新进程到达时先进入第一级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾。</li>
<li>只有第k级队列为空时，才会为k + 1级队头的进程分配时间片。</li>
</ul>
</li>
<li><p>用于作业/进程调度</p>
<p>用于进程调度。</p>
</li>
<li><p>是否可抢占</p>
<p>抢占式算法。在k级队列的进程运行过程中，若更上级的队列中进入了一个新的进程，则由于新进程处于优先级最高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。</p>
</li>
<li><p>优缺点</p>
<p>对各类型进程相对公平（FCFS的优点）；每个新到达的进程都可以很快得到相应（RR的优点）；短进程只用较少的时间就可完成（SJF的优点）；不必实现估计进程的运行时间（避免用户作假）；可灵活的调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程（扩展：可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级）。</p>
</li>
<li><p>是否会导致饥饿</p>
<p>会。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/17/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/" data-id="ckzb6dz4w002bzwtw6re57e1g" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2021/12/17/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/" class="article-nav-link">
    <strong class="article-nav-caption">Newer</strong>
    <div class="article-nav-title">
      
      磁盘调度算法
      
    </div>
  </a>
  
  
  <a href="/2021/12/16/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86/" class="article-nav-link">
    <strong class="article-nav-caption">Older</strong>
    <div class="article-nav-title"></div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>青稞 &copy; 2022</li>
      
        <li>ZHWANGART</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="青稞"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>





<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>