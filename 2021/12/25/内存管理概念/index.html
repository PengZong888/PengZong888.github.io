<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    内存管理概念 |
    
    青稞
  </title>
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="青稞" type="application/atom+xml">
</head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-内存管理概念" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h1 class="article-title" itemprop="name">
  内存管理概念
</h1>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/12/25/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/" class="article-date">
  <time datetime="2021-12-25T06:38:59.000Z" itemprop="datePublished">2021-12-25</time>
</a>
      
    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <blockquote>
<ol>
<li>为什么要进行内存管理？</li>
<li>页式管理中每个页表项的大小的下限如何决定？</li>
<li>多级页表解决了什么问题？又会带来什么问题？</li>
</ol>
</blockquote>
<h1 id="1-内存管理的基本原理和要求"><a href="#1-内存管理的基本原理和要求" class="headerlink" title="1. 内存管理的基本原理和要求"></a>1. 内存管理的基本原理和要求</h1><p>Memory Management是OS设计中最重要和最复杂的内容之一。虽然硬件技术在不断发展，内存容量在不断增大，但仍然不可能将所有用户进程和系统所需的全部资源放入主存，因此OS必须对内存空间进行合理的划分和有效的动态分配，而这就是内存管理的概念。</p>
<p>内存管理的功能有：</p>
<blockquote>
<ul>
<li><strong>内存空间的分配与回收</strong>。由OS完成主存储器空间的分配和管理，使程序员摆脱存储分配的麻烦，提高编程效率。</li>
<li><strong>地址转换。</strong>在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址。</li>
<li><strong>内存空间的扩充。</strong>利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存。</li>
<li><strong>存储保护。</strong>保证所有作业在自己的存储空间内运行，互不干扰。</li>
</ul>
</blockquote>
<h2 id="1-1-程序装入和链接"><a href="#1-1-程序装入和链接" class="headerlink" title="1.1 程序装入和链接"></a>1.1 程序装入和链接</h2><p>创建进程首先要将程序和数据装入内存。将用户源程序变为可在内存中执行的程序，通常需要以下几个步骤：</p>
<blockquote>
<ul>
<li>编译。由编译程序将用户源代码编译成若干目标模块。</li>
<li>链接。由链接程序将编译后形成的一组目标模块及所需的库函数链接在一起，形成一个完整的装入模块。</li>
<li>装入。由装入程序将装入模块装入内存运行。</li>
</ul>
</blockquote>
<p>这三步如图所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211228140435063.png" alt="image-20211228140435063"></p>
<p>程序的链接有以下三种方式：</p>
<ul>
<li><strong>静态链接</strong>。程序运行前，就已经将各个模块和库函数链接成一个可执行程序，以后也不再拆开。</li>
<li><strong>装入时动态链接</strong>。装入内存时，边装入，边链接。</li>
<li><strong>运行时动态链接</strong>。程序运行时链接。便于修改和更新以及实现对目标模块的共享。</li>
</ul>
<p>内存的装入模块在装入内存时，也有三种方式：</p>
<ul>
<li><p><strong>绝对装入</strong>。编译时，就已经知道程序的内存位置。绝对装入程序只要按照模块中的地址，将程序和数据装入进去即可（不需要修改程序和数据）。这种方式只适用于单道程序环境。</p>
</li>
<li><p><strong>可重定位装入</strong>。在多道程序环境下，多个目标模块的起始地址通常都是从0开始，程序中的其它地址都是相对于始址的。根据内存的当前情况，将装入模块装入内存的适当位置。装入时对目标程序中指令和数据的修改过程称为<strong>重定位</strong>，地址变换通常是在装入时一次完成的，所以又称静态重定位。</p>
<p>静态重定位的特点是：一个作业装入内存时，必须给它分配要求的全部内存空间，如果没有足够的空间，则不能装入。此外，作业一旦进入内存空间，就不能移动或者再申请内存空间。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211228145653209.png" alt="image-20211228145653209"></p>
<ul>
<li><p><strong>动态运行时装入</strong>。也称动态重定位。上面讲了，可重定位装入方式一旦作业进入内存空间就不能移动，而通常而言，程序都有移动的需求，因此动态重定位也就产生了。装入程序装入内存后，并不立即把装入模块中的相对地址转换成绝对地址，而是<strong>把这种地址转换推迟到程序真正执行的时候才进行</strong>。因此，装入内存后的所有地址均为相对地址。这种方式需要一个重定位寄存器的支持。</p>
<p>动态重定位的特点是：可以将程序分配到不连续的存储区中；只需要装入部分代码即可运行程序，然后在程序运行期间，动态申请内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。</p>
</li>
</ul>
<h2 id="1-2-逻辑地址空间和物理地址空间"><a href="#1-2-逻辑地址空间和物理地址空间" class="headerlink" title="1.2 逻辑地址空间和物理地址空间"></a>1.2 逻辑地址空间和物理地址空间</h2><p>用户和程序员只需要知道逻辑地址，而内存管理的具体机制则是完全透明的，只有系统编程人员才会涉及内存管理的具体机制。不同进程可以有相同的逻辑地址，因为这些相同的逻辑地址可以映射到主存中的不同位置。</p>
<p>当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址，这个过程称为<strong>地址重定位</strong>。</p>
<h2 id="1-3-内存保护"><a href="#1-3-内存保护" class="headerlink" title="1.3 内存保护"></a>1.3 内存保护</h2><p>内存分配前，需要保护OS不受用户进程的影响，同时保护用户进程不受其它用户进程的影响。内存保护可采取两种方法：</p>
<ol>
<li>在CPU中设置一对上、下限寄存器，存放用户作业在主存中的下限和上限地址，每当CPU要访问一个地址时，分别和两个寄存器的值相比，判断有无越界。</li>
<li>采用重定位寄存器（或基址寄存器）和界地址寄存器（又称限长寄存器）来实现这种保护。重定位寄存器包含最小的物理地址，界地址寄存器包含逻辑地址的最大值。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211228160242172.png" alt="image-20211228160242172"></p>
<p>实现内存保护需要重定位寄存器和界地址寄存器，因此要注意两者区别：</p>
<ul>
<li>重定位寄存器是用来“加”的，逻辑地址 + 重定位寄存器中的值 = 物理地址</li>
<li>界地址寄存器是用来“比”的，通过比较界地址寄存器和逻辑地址的值来判断是否越界。</li>
</ul>
<h1 id="2-覆盖与交换"><a href="#2-覆盖与交换" class="headerlink" title="2. 覆盖与交换"></a>2. 覆盖与交换</h1><p>覆盖与交换技术是用在多道程序环境下用来扩充内存的两种方法。</p>
<h2 id="2-1-覆盖"><a href="#2-1-覆盖" class="headerlink" title="2.1 覆盖"></a>2.1 覆盖</h2><p>由于程序时并非任何时刻都要访问所有数据，因此可以把用户空间分成一个固定区和若干覆盖区。将经常活跃的部分放在固定区，其余按调用关系分段。先将即将访问的段放入覆盖区，其它段放在外存中，需要调用时，系统再将其调入覆盖区，替换覆盖区中原有的段。</p>
<p>覆盖技术的特点是：打破了一个进程必须全部装入主存才能运行的限制，但是当同时运行的程序大于主存的容量，仍然是不能运行的。而且，内存中只有覆盖区可以更新，不在覆盖区的部分会常驻内存。</p>
<h2 id="2-2-交换"><a href="#2-2-交换" class="headerlink" title="2.2 交换"></a>2.2 交换</h2><p>把处于等待状态的程序从内存移到辅存，腾出内存空间，这一过程又称<strong>换出</strong>；把准备好的竞争CPU运行的程序从辅存移到内存，这一过程又称<strong>换入</strong>。</p>
<p>关于交换需要注意的问题：</p>
<ol>
<li>交换需要备份存储，通常是快速磁盘。它必须足够大，并提供对这些内存映像的直接访问。</li>
<li>为了有效使用CPU，需要使每个进程的执行时间比交换时间长。</li>
<li>若换出进程，则必须保证该进程处于完全空闲状态。</li>
<li>交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用起来可能更快。</li>
<li>交换通常在有许多进程运行且内存空间吃紧时开始启动，而在系统负荷降低时就暂停。</li>
<li>普通的交换使用不多，但交换策略的变体在许多系统中仍然发挥作用。</li>
</ol>
<p>交换主要在不同进程之间进行，而覆盖则在同一程序或进程中。</p>
<h1 id="3-连续分配管理方式"><a href="#3-连续分配管理方式" class="headerlink" title="3. 连续分配管理方式"></a>3. 连续分配管理方式</h1><p>连续分配方式是指为一个用户程序分配一个连续的内存空间。主要包括单一连续分配、固定分区分配和动态分区分配。</p>
<h2 id="3-1-单一连续分配"><a href="#3-1-单一连续分配" class="headerlink" title="3.1 单一连续分配"></a>3.1 单一连续分配</h2><p>内存在此方式下分为系统区和用户区，系统区仅供OS使用，通常在低地址部分。这种方式无须进行内存包含，因为内存中永远只有一道程序，因此肯定不会因为访问越界而干扰其它程序。</p>
<p>这种方式简单、无外部碎片，可以采用覆盖技术，不需要额外的技术支持。缺点是只能用于单用户、单任务的OS中，有内部碎片，存储器的利用率极低。</p>
<h2 id="3-2-固定分区分配"><a href="#3-2-固定分区分配" class="headerlink" title="3.2 固定分区分配"></a>3.2 固定分区分配</h2><p>将用户内存空间划分为若干固定大小的区域，每个分区只装入一道作业。在划分分区时有两种不同的方法：</p>
<ul>
<li>分区大小相等</li>
<li>分区大小不等</li>
</ul>
<p>为便于内存分配，通常将分区按大小排队，并为之建立一张分区说明表，其中各表项包括每个分区的始址、大小及状态。当有用户程序要装入时，便检索该表，以找到合适的分区予以分配并将其状态置为“已分配”；没有找到则拒绝分配。</p>
<p>这种方式存在两个问题：</p>
<ol>
<li>程序可能太大而放不进任何一个分区</li>
<li>主存利用率低，当程序小于固定分区大小时，也占用了一个完整的内存分区空间，这样分区内部就存在空间浪费，这种现象称为内部碎片。</li>
</ol>
<h2 id="3-3-动态分区分配"><a href="#3-3-动态分区分配" class="headerlink" title="3.3 动态分区分配"></a>3.3 动态分区分配</h2><p>这种分区方法不预先划分内存，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此，系统中分区的大小和数目是可变的。</p>
<p>动态分区在开始分配时是很好的，但之后会导致内存中出现许多小的内存块，内存利用率也随之下降。克服外部碎片可以通过<strong>紧凑</strong>技术来解决，即OS不时地对进程进行移动和整理。但这需要动态重定位寄存器的支持，且相对费时。</p>
<p>在进程装入或换入主存时，若内存中有多个足够大的空闲块，则OS必须确定分配哪个内存块给进程使用，这就是动态分区的分配策略。考虑以下几种算法：</p>
<ol>
<li><strong>首次适应算法（First Fit）</strong>空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。</li>
<li><strong>最佳适应算法（Best Fit）</strong>空闲分区按容量递增的方式形成分区链，找到第一个能满足要求的空闲分区。</li>
<li><strong>最坏适应算法（Worst Fit）</strong>又称最大适应（Largest Fit）算法，空闲分区以容量递减的次序链接，找到第一个能满足要求的空闲分区，即挑选出最大的分区。</li>
<li><strong>邻近使用算法（Next Fit）</strong>又称循环首次适应算法，由首次适应算法演变而成。不同之处是，分配内存时从上次查找结束的位置开始继续查找。</li>
</ol>
<p>在这几种方法中，First Fit不仅最简单，通常也是最好和最快的。但是会使得低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此增加了查找的开销。</p>
<p>邻近适应算法试图解决这个问题。但实际上，它常常导致在内存的末尾分配空间分裂成小碎片。它通常比首次适应算法的结果要差。</p>
<p>最佳适应虽然称为“最佳”，但是性能通常很差，因为每次最佳的分配会留下很小的难以利用的内存块，会产生最多的外部碎片。</p>
<p>最坏与最佳相反，选择最大的可用块，会很快导致没有可用的大内存块，因此性能也非常差。</p>
<p>Knuth和Shore分别就前三种方法做了模拟实验，结果表明：首次可能比最佳效果好，而这两者一定比最大效果好。另外，在算法实现时，分配操作中最佳和最大需要对可用块进行排序或遍历查找，而首次和邻近只需要简单查找；在回收操作时，当回收的块与原来的空闲块相邻时，需要合并。</p>
<p>三种内存分区管理方式的比较如下表：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211228202338021.png" alt="image-20211228202338021"></p>
<p>以上三种内存分区管理方法有一个共同特点，即用户进程在主存中都是连续存放的。</p>
<h1 id="4-非连续分配管理方式"><a href="#4-非连续分配管理方式" class="headerlink" title="4. 非连续分配管理方式"></a>4. 非连续分配管理方式</h1><p>在连续分配方式中，即使内存中有1GB的空闲空间，但如果不是连续的，那么需要1GB的作业仍然是无法运行的。但如果采用非连续分配方式，则可以将这1GB的作业分散地分配在内存的各个区域，当然，这也需要额外的空间去存储它们（分散区域）的索引，使得非连续分配方式的存储密度低于连续存储方式的。</p>
<p>非连续分配管理方式根据分区的大小是否固定，分为分页存储管理方式和分段存储管理方式。</p>
<p>在分页存储管理方式中，又根据运行作业时是否要把作业的所有页面都装入内存才能运行，分为基本分页存储管理方式和请求分页存储管理方式。</p>
<h2 id="4-1-基本分页存储管理方式"><a href="#4-1-基本分页存储管理方式" class="headerlink" title="4.1 基本分页存储管理方式"></a>4.1 基本分页存储管理方式</h2><p>固定分区会产生内部碎片，动态分区会产生外部碎片，而且这两种技术对内存的利用率都比较低。我们希望内存的使用能尽量避免碎片的产生，这就引入了分页的思想：<strong>把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。</strong></p>
<p>分页从形式上看，类似分区相等的固定分区技术，但是分页管理不会产生外部碎片。但是两者有本质的不同点：<strong>块的大小相对分区的大小要小很多</strong>。而且因为进程也是按块划分的，所以尽管会产生内部碎片，但也只有在进程的最后一个块才有，这种碎片相对进程来说是非常小的，每个进程平均只产生半个块大小的内部碎片（也称<strong>页内碎片</strong>）。</p>
<h3 id="4-1-1-分页存储的几个基本概念"><a href="#4-1-1-分页存储的几个基本概念" class="headerlink" title="4.1.1 分页存储的几个基本概念"></a>4.1.1 分页存储的几个基本概念</h3><ol>
<li><p><strong>页面和页面大小</strong></p>
<p>进程中的块称为<strong>页</strong>，内存中的块称为<strong>页框（或页帧</strong>）。外存也以同样的单位进行划分，直接称为<strong>块</strong>。进程在执行时需要申请主存空间，即要为每个页面分配主存中的可用页框，这就产生了页和页框一一对应。</p>
<p>为方便地址转换，<strong>页面大小应是2的整数幂</strong>。同时页面大小应该适中，<strong>太小</strong>会使进程页面数过多，这样页表就过长，占用大量内存，而且也会增加硬件地址转换的开销，降低页面的换入/换出的效率；页面<strong>过大</strong>会使页内碎片增多，降低内存的利用率。</p>
</li>
<li><p><strong>地址结构</strong></p>
<p>地址结构包含两部分：前一部分为页号P，后一部分为页内偏移量W。地址长度为32位，其中0~11位为页内地址，即每页大小为4KB；12-31位为页号，地址空间最多允许二的二十次方页。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229131227978.png" alt="image-20211229131227978"></p>
<p>注意，地址结构决定了虚拟内存的寻址空间有多大。</p>
</li>
<li><p><strong>页表</strong></p>
<p>为了便于在内存中找到进程的每个页面对应的物理块，系统为每个进程建立了一张页表，它<strong>记录页面在内存中对应的物理块号</strong>，页表一般存放在内存中。</p>
<p>页表是由页表项组成的，页表项和地址都是由两部分组成的，而且第一部分都是页号，但页表项的第二部分是物理内存中的块号，而地址的第二部分是页内偏移；<strong>页表项的第二部分与地址的第二部分共同组成物理地址</strong>。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229132720413.png" alt="image-20211229132720413"></p>
<p><strong>页表的作用就是实现从页号到物理块号的地址映射。</strong></p>
</li>
</ol>
<h3 id="4-1-2-基本地址变换机构"><a href="#4-1-2-基本地址变换机构" class="headerlink" title="4.1.2 基本地址变换机构"></a>4.1.2 基本地址变换机构</h3><p>地址变换机构的任务是将逻辑地址转换为内存中的物理地址。地址变换是借助于页表实现的。如图给出了分页存储管理系统中的地址变换机构：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229135240244.png" alt="image-20211229135240244"></p>
<p>在系统中通常设置一个页表寄存器（PTR），存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和长度存放在进程控制块中，当进程执行时，才将页表始址和长度存入页表寄存器。设页面大小为L，逻辑地址A到物理地址E的变换过程如下（逻辑地址、页号、每页的长度都是十进制数）：</p>
<ol>
<li>计算页号P(P = A / L)和页内偏移量W(W=A % L)。</li>
<li>比较页号P和页表长度M，若P ≥ M，则产生越界中断，否则继续执行。</li>
<li>页表中页号P对应的页表项地址 = 页表始址F + 页号P * 页表项长度，取出该页表项内容b，即为物理块号。要注意区分页表长度和页表项长度。页表长度是指一共有多少页，页表项长度是指页地址占多大存储空间。</li>
<li>计算E = b * L + W，用得到的物理地址E去访问内存。</li>
</ol>
<p>以上整个地址转换由硬件完成。例如，若页面大小L为1KB，页号2对应的物理块为b = 8，计算逻辑地址A = 2500的物理地址E的过程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P = <span class="number">2500</span> / <span class="number">1</span>KB = <span class="number">2</span></span><br><span class="line">W = <span class="number">2500</span> % <span class="number">1</span>KB = <span class="number">452</span></span><br><span class="line">E = <span class="number">8</span> * <span class="number">1024</span> + <span class="number">452</span> = <span class="number">8644</span></span><br></pre></td></tr></table></figure>

<p> 页表项的大小不是随意规定的，而是有所约束的。页表项的作用是找到该页在内存中的位置。以32位逻辑地址空间、字节编址单位、一页4KB为例，地址空间内一共有1MB（2的32B / 4KB）页，因此需要20位才能保证表示范围能容纳所有页面，又因为以字节作为编址单位，即页表项的大小 ≥ 20/8 = 3B。所以在这个条件下，为了保证页表项能够指向所有页面，页表项的大小应该大于3B。</p>
<p>下面讨论分页管理方式存在的两个主要问题：</p>
<ul>
<li>每次访存操作都需要进行逻辑地址到物理地址的转换，地址转换过程必须足够快，否则访存速度会降低；</li>
<li>每个进程引入页表，用于存储映射机制，页表不能太大，否则内存利用率会降低。</li>
</ul>
<h3 id="4-1-3-具有快表的地址变换机构"><a href="#4-1-3-具有快表的地址变换机构" class="headerlink" title="4.1.3 具有快表的地址变换机构"></a>4.1.3 具有快表的地址变换机构</h3><p>在上面的地址变换过程中，将所有页表存放在内存中，如果要存取数据或指令，则至少需要经过两次访存：第一次是访问页表，取出数据或指令的存放地址；第二次是根据地址取出数据或指令。</p>
<p>这样就比通常执行指令的速度满了一半。为此，在地址变换机构中增设一个具有并行查找能力的高速缓冲存储器——快表。又称<strong>相联存储器（TLB）</strong>，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，主存中的页表常称为慢表。具有快表的地址变换机构如图所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229145806007.png" alt="image-20211229145806007"></p>
<p>在具有快表的分页机制中，地址的变换过程如下：</p>
<ol>
<li>CPU给出逻辑地址后，由硬件进行地址转换，将页号送入高速缓存寄存器，并将此页号与快表中的所有页号进行比较。</li>
<li>若找到匹配的页号，说明所要访问的页表项在快表中，则直接从中取出该页对应的页框号，与页内偏移量拼接形成物理地址。这样，存取数据仅一次访存即可实现。</li>
<li>若未找到匹配的页号，则需要访问主存中的页表，在读出页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换。</li>
</ol>
<blockquote>
<p>注意：有些处理机设计为快表和慢表同时查找，若在快表中查找成功则终止慢表的查找。</p>
</blockquote>
<p>一般快表的命中率可达90%以上，这样分页带来的速度损失就可降低至10%一下。</p>
<h3 id="4-1-4-两级页表"><a href="#4-1-4-两级页表" class="headerlink" title="4.1.4 两级页表"></a>4.1.4 两级页表</h3><p>由于引入了分页管理，进程在执行时不需要将所有页调入内存页框，而只需将保存有映射关系的页表调入内存。但是，我们仍然需要考虑页表的大小。以32为逻辑地址空间、页面大小4KB、页表项大小4B为例。以一个40MB的进程为例，页表项共40KB（40MB / 4KB * 4B），若将所有页表项内容保存在内存中，则需要10个内存页框来保存整个页表，整个进程大小约为一万个页面。</p>
<p>为了压缩页表，我们进一步延伸页表映射的思想，就可得到二级分页。二级页表的逻辑地址空间格式如下：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229200300740.png" alt="image-20211229200300740"></p>
<p>二级页表实际上是在原有页表结构上再加上一层页表，示意结构如下：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229201658072.png" alt="image-20211229201658072"></p>
<p>建立多级页表的目的在于建立索引，以便不用浪费主存空间去存储无用的页表项，也不用盲目地顺序式查找页表项。</p>
<h2 id="4-2-基本分段存储管理方式"><a href="#4-2-基本分段存储管理方式" class="headerlink" title="4.2 基本分段存储管理方式"></a>4.2 基本分段存储管理方式</h2><p>分页管理方式是从计算机的角度考虑设计的，目的是为了提高内存的利用率。分页通过硬件机制实现，对用户完全透明。分段管理方式的提出则考虑了用户和程序员，以满足编程、信息保护和共享、动态增长和动态链接等多方面的需要。</p>
<h3 id="4-2-1-分段"><a href="#4-2-1-分段" class="headerlink" title="4.2.1 分段"></a>4.2.1 分段</h3><p>段式管理方式按照用户进程中的自然段划分逻辑空间。例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为5段，每段从0开始编址，并分配一段连续的地址空间（段内要求连续，段间不要求连续），其逻辑地址由段号S与段内偏移量W两部分组成。</p>
<p>如图，段号为16位，段内偏移量为16位，因此一个作业最多有2的16次方 = 65536段，最大段长为64KB。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229153510705.png" alt="image-20211229153510705"></p>
<h3 id="4-2-2-段表"><a href="#4-2-2-段表" class="headerlink" title="4.2.2 段表"></a>4.2.2 段表</h3><p>每个进程都有一张逻辑空间与内存空间映射的段表，其中每个段表项对应进程的一段，段表项记录该段在内存中的始址和长度。段表的内容如图所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229153735071.png" alt="image-20211229153735071"></p>
<p>配置段表后，执行中的进程可以通过查找段表，找到每段所对应的内存区。可见，段表用于实现从逻辑段到物理内存区的映射，如图所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229155523742.png" alt="image-20211229155523742"></p>
<h3 id="4-2-3-地址变换机构"><a href="#4-2-3-地址变换机构" class="headerlink" title="4.2.3 地址变换机构"></a>4.2.3 地址变换机构</h3><p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229203619342.png" alt="image-20211229203619342"></p>
<p>分段系统的地址变换过程如图所示。为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器，用于存放段表始址F和段表长度M。从逻辑地址A到物理地址E之间的地址变换过程如下：</p>
<ol>
<li>从逻辑地址A中取出前几位为段号S，后几位为段内偏移量W。</li>
<li>比较段号S和段表长度M，若S ≥ M，则产生越界中断，否则继续执行。</li>
<li>段表中段号S对应的段表项地址 = 段表始址F + 段号S * 段表项长度，取出该段表项的前几位得到段长C。若段内偏移量 ≥ C，则产生越界中断，否则继续执行。从这里我们可以知道，段表项实际上只有两部分，前几位是段长，后几位是始址。</li>
<li>取出段表项中该段的始址b，计算E = b + W，用得到的物理地址E去访问内存。</li>
</ol>
<h3 id="4-2-4-段的共享和保护"><a href="#4-2-4-段的共享和保护" class="headerlink" title="4.2.4 段的共享和保护"></a>4.2.4 段的共享和保护</h3><p>在分段系统中，段的共享是通过两个作业的段表中相应表项指向被共享的段的同一个物理副本来实现的。当一个作业正从共享段中读取数据时，必须防止另一个作业修改此共享段中的数据。不能修改的代码称为纯代码或可重入代码（不属于临界资源），这样的代码和不能修改的数据可以共享，而可修改的代码和数据不能共享。</p>
<h2 id="4-3-段页式管理方式"><a href="#4-3-段页式管理方式" class="headerlink" title="4.3 段页式管理方式"></a>4.3 段页式管理方式</h2><p>页式管理可以有效提高内存利用率，而分段管理能反映程序的逻辑结构并有利于段的共享。将这两种方式结合起来，便形成了段页式存储管理方式。</p>
<p>在段页式系统中，作业的地址空间首先被分成若干逻辑段，每段都有自己的段号，然后将每段分成若干大小固定的页。作业的逻辑地址分为三部分：段号、页号和页内偏移量，如图所示：</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229203843529.png" alt="image-20211229203843529"></p>
<blockquote>
<p>注意：在一个进程中，段表只有一个，而页表可能有多个。</p>
</blockquote>
<p>在进行地址变换时，首先通过段表查到页表始址，然后通过页表找到页帧号，最后形成物理地址。如图，进行一次访问实际需要三次访问主存，这里同样可以使用快表来加快查找速度，其关键字由段号、页号组成，值是对应的页帧号和保护码。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211229205235593.png" alt="image-20211229205235593"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/25/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/" data-id="ckzb6dz5a002lzwtw89653j9j" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2021/12/25/%E4%BA%8C%E5%8D%81%E4%B8%89%E4%B8%AA%E5%AE%9E%E9%AA%8C%E5%85%A5%E9%97%A8SpringIOC-%E4%B8%8A/" class="article-nav-link">
    <strong class="article-nav-caption">Newer</strong>
    <div class="article-nav-title">
      
      二十三个实验入门SpringIOC(上)
      
    </div>
  </a>
  
  
  <a href="/2021/12/24/%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2/" class="article-nav-link">
    <strong class="article-nav-caption">Older</strong>
    <div class="article-nav-title">死锁预防</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>青稞 &copy; 2022</li>
      
        <li>ZHWANGART</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="青稞"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>





<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>