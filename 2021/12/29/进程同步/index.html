<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    进程同步 |
    
    青稞
  </title>
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="青稞" type="application/atom+xml">
</head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-进程同步" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h1 class="article-title" itemprop="name">
  进程同步
</h1>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/12/29/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/" class="article-date">
  <time datetime="2021-12-29T13:47:55.000Z" itemprop="datePublished">2021-12-29</time>
</a>
      
    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <blockquote>
<ol>
<li>为什么要引入进程同步的概念？</li>
<li>不同的进程之间会存在什么关系？</li>
<li>当单纯用本节介绍的方法解决问题会遇到什么新的问题？</li>
</ol>
</blockquote>
<h1 id="1-进程同步的基本概念"><a href="#1-进程同步的基本概念" class="headerlink" title="1. 进程同步的基本概念"></a>1. 进程同步的基本概念</h1><p>在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系，引入了进程同步的概念。</p>
<h2 id="1-1-临界资源"><a href="#1-1-临界资源" class="headerlink" title="1.1 临界资源"></a>1.1 临界资源</h2><p>虽然多个进程可以共享系统中的各种资源，但许多资源一次只能为一个进程服务，我们<strong>将一次仅允许一个进程使用的资源称为临界资源</strong>。许多物理设备都属于临界资源，如打印机等。此外，还有许多变量、数据等。</p>
<p>对临界资源的访问，必须互斥地进行，在每个进程中，<strong>访问临界资源的那段代码称为临界区</strong>。为了保证临界资源的正确使用，可把临界资源的访问过程分为4个部分：</p>
<ul>
<li><strong>进入区</strong>。为了进入临界区使用临界资源，在进入区要检查可否进入临界区，若能进入，则应设置正在访问临界区的标志，以阻止其它进程同时进入临界区。</li>
<li><strong>临界区</strong>。进程中访问临界资源的那段代码，又称临界段。</li>
<li><strong>退出区</strong>。将正在访问临界区的标志清除。</li>
<li><strong>剩余区</strong>。代码中的剩余部分。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	entry section;			<span class="comment">// 进入区</span></span><br><span class="line">    critical section;		<span class="comment">// 临界区</span></span><br><span class="line">    <span class="built_in">exit</span> section;			<span class="comment">// 退出区</span></span><br><span class="line">    remainder section;		<span class="comment">// 剩余区</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<h2 id="1-2-同步"><a href="#1-2-同步" class="headerlink" title="1.2 同步"></a>1.2 同步</h2><p>同步亦称直接制约关系，是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系源于它们之间的相互合作。</p>
<h2 id="1-3-互斥"><a href="#1-3-互斥" class="headerlink" title="1.3 互斥"></a>1.3 互斥</h2><p>互斥也称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一个进程才允许去访问此临界资源。</p>
<p>为禁止两个进程同时进入临界区，同步机制应遵循以下准则：</p>
<blockquote>
<ol>
<li><strong>空闲让进</strong>。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。</li>
<li><strong>忙则等待</strong>。当已有进程进入临界区时，其它试图进入临界区的进程必须等待。</li>
<li><strong>有限等待</strong>。对请求访问的进程，应保证能在有限时间内进入临界区。</li>
<li><strong>让权等待</strong>。当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。</li>
</ol>
</blockquote>
<h1 id="2-实现临界区互斥的基本方法"><a href="#2-实现临界区互斥的基本方法" class="headerlink" title="2. 实现临界区互斥的基本方法"></a>2. 实现临界区互斥的基本方法</h1><h2 id="2-1-软件实现方法"><a href="#2-1-软件实现方法" class="headerlink" title="2.1 软件实现方法"></a>2.1 软件实现方法</h2><p>在进入区设置并检查一些标志来标明是否有进程在临界区中，若已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。</p>
<h3 id="2-1-1-单标志法"><a href="#2-1-1-单标志法" class="headerlink" title="2.1.1 单标志法"></a>2.1.1 单标志法</h3><p>该算法设置一个公用整型变量turn，<strong>用于指示被允许进入临界区的进程编号</strong>。该算法可确保每次只允许一个进程进入临界区，但两个进程必须交替进入临界区，若某个进程不再进入临界区，则另一个进程也将无法进入临界区（违背“空闲让进”）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P0进程						// P1进程</span></span><br><span class="line"><span class="keyword">while</span> (turn != <span class="number">0</span>);			<span class="keyword">while</span> (turn != <span class="number">1</span>);		<span class="comment">// 进入区</span></span><br><span class="line">critical section;			critical section;		<span class="comment">// 临界区</span></span><br><span class="line">turn = <span class="number">1</span>;					turn = <span class="number">0</span>;				<span class="comment">// 退出区</span></span><br><span class="line">remainder section;			remainder section;		<span class="comment">// 剩余区</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-双标志先检查"><a href="#2-1-2-双标志先检查" class="headerlink" title="2.1.2 双标志先检查"></a>2.1.2 双标志先检查</h3><p>该算法的基本思想是在每个进程访问临界区资源之前，先查看临界区资源是否正在被访问，只有不在，进程才能进入自己的临界区；否则等待。为此，设置一个数据flag[i]，如第i个元素值为FALSE，表示Pi进程未进入临界区；值为TRUE，表示Pi进程进入临界区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pi进程						   // Pj进程</span></span><br><span class="line"><span class="keyword">while</span> (flag[j]);	①			<span class="keyword">while</span> (flag[i]);	②	<span class="comment">// 进入区</span></span><br><span class="line">flag[i] = TRUE;		③			flag[j] = TRUE;		④	<span class="comment">// 进入区</span></span><br><span class="line">critical section;				critical section;		<span class="comment">// 临界区</span></span><br><span class="line">flag[i] = FALSE;				flag[j] = FALSE;		<span class="comment">// 退出区</span></span><br><span class="line">remainder section;				remainder section;		<span class="comment">// 剩余区</span></span><br></pre></td></tr></table></figure>

<p>优点：不用交替进入，可连续使用；</p>
<p>缺点：Pi和Pj可能同时进入临界区。按序列①②③④执行时，会同时进入临界区（“违背忙则等待”）。即在检查对方的flag后和切换自己的flag前有一段时间，结果都检查通过。这里的问题就是检查和修改不能一次进行。</p>
<h3 id="2-1-3-双标志后检查"><a href="#2-1-3-双标志后检查" class="headerlink" title="2.1.3 双标志后检查"></a>2.1.3 双标志后检查</h3><p>这里与先检查的区别就是我们先将自己的标志设为TRUE，再检测对方的状态标志。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pi进程						   // Pj进程</span></span><br><span class="line">flag[i] = TRUE;		①			flag[j] = TRUE;		②	<span class="comment">// 进入区</span></span><br><span class="line"><span class="keyword">while</span> (flag[j]);	③			<span class="keyword">while</span> (flag[i]);	④	<span class="comment">// 进入区</span></span><br><span class="line">critical section;				critical section;		<span class="comment">// 临界区</span></span><br><span class="line">flag[i] = FALSE;				flag[j] = FALSE;		<span class="comment">// 退出区</span></span><br><span class="line">remainder section;				remainder section;		<span class="comment">// 剩余区</span></span><br></pre></td></tr></table></figure>

<p>这样，我们虽然避免了“忙则等待”，但是可能会产生”饥饿“现象（按序列①②③④执行）。</p>
<h3 id="2-1-4-Peterson’s-Algorithm"><a href="#2-1-4-Peterson’s-Algorithm" class="headerlink" title="2.1.4 Peterson’s Algorithm"></a>2.1.4 Peterson’s Algorithm</h3><p>为了防止两个进程为进入临界区而无限等待，又设置了变量turn，每个进程先设置自己的标志再设置turn标志。这是，再同时检测另一个进程状态标志和允许进入标志，以便保证两个进程同时要求进入临界区时，只允许一个进程进入临界区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pi进程						   	   // Pj进程</span></span><br><span class="line">flag[i] = TRUE; turn = j;			flag[j] = TRUE; turn = i;			<span class="comment">// 进入区</span></span><br><span class="line"><span class="keyword">while</span> (flag[j] &amp;&amp; turn == j);		<span class="keyword">while</span> (flag[i] &amp;&amp; turn == i);		<span class="comment">// 进入区</span></span><br><span class="line">critical section;					critical section;					<span class="comment">// 临界区</span></span><br><span class="line">flag[i] = FALSE;					flag[j] = FALSE;					<span class="comment">// 退出区</span></span><br><span class="line">remainder section;					remainder section;					<span class="comment">// 剩余区</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-硬件实现方法"><a href="#2-2-硬件实现方法" class="headerlink" title="2.2 硬件实现方法"></a>2.2 硬件实现方法</h2><p>计算机提供了特殊的硬件指令，允许对一个字中的内容进行检测和修正，或对两个字的内容进行交换等。通过硬件支持实现临界段问题的方法称为低级方法，或称元方法。</p>
<h3 id="2-2-1-中断屏蔽方法"><a href="#2-2-1-中断屏蔽方法" class="headerlink" title="2.2.1 中断屏蔽方法"></a>2.2.1 中断屏蔽方法</h3><p>当一个进程正在使用处理机执行它的临界区代码时，防止其它进程进入其临界区进行访问的最简单方法就是：<strong>禁止一切中断发生</strong>，或称之为屏蔽中断、关中断。因为CPU只有在发生中断时才引起进程切换，典型模式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">关中断;</span><br><span class="line">临界区;</span><br><span class="line">开中断;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这种方法限制了处理机交替执行程序的能力，因此执行的效率会明显降低。对内核来说，在它执行更新变量或列表的几条指令期间，关中断是很方便，但是将关中断的权利交给用户是很不明智的，如果一个进程关中断后不再开，则系统可能祭了。</p>
<h3 id="2-2-2-硬件指令方法"><a href="#2-2-2-硬件指令方法" class="headerlink" title="2.2.2 硬件指令方法"></a>2.2.2 硬件指令方法</h3><p><strong>TestAndSet指令</strong>：这条指令是原子操作，即执行该代码时不允许被中断。其功能是读出指定的标志后把该标志设为真。指令的功能描述如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">TestAndSet</span><span class="params">(boolean *lock)</span> </span>&#123;</span><br><span class="line">    boolean old;</span><br><span class="line">    old = *lock;</span><br><span class="line">    *lock = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以为每个临界资源设置一个共享布尔变量lock，表示资源的两种状态：true表示正在被占用，初值为false。在进程访问临界资源之前，利用TestAndSet检查和修改标志lock；若有进程在临界区，则重复检查，知道进程退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (TestAndSet(&amp;lock));</span><br><span class="line">进程的临界区代码段;</span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line">进程的其它代码;</span><br></pre></td></tr></table></figure>

<p><strong>Swap指令</strong>：见名知意，其功能描述如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Swap(boolean *a, boolean *b) &#123;</span><br><span class="line">    boolean temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：以上对TestAndSet和Swap指令的描述仅仅是功能实现，而并非软件实现的定义。事实上，它们是由硬件逻辑直接实现的，不会被中断。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">key = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (key != <span class="literal">false</span>);</span><br><span class="line">	Swap(&amp;lock, &amp;key);</span><br><span class="line">进程的临界区代码段;</span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line">进程的其它代码;</span><br></pre></td></tr></table></figure>

<p>硬件方法的优点：适用于任意数目的进程，而不管是单处理机还是多处理机；简单、容易验证其正确性。可以支持进程内有多个临界区，只需为每个临界区设立一个布尔变量。</p>
<p>硬件方法的缺点：进程等待进入临界区时要耗费处理机时间，不能实现让权等待。从等待进程中随机选择一个进入临界区，有的进程可能一直选不上，从而导致“饥饿”。</p>
<h1 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3. 信号量"></a>3. 信号量</h1><p>信号量机制是一种功能较强的机制，可用来解决同步与互斥问题，它只能被两个标准的原语wait(S)和signal(S)访问，也可记为“P操作”和“V操作”。</p>
<p>原语是指完成某种功能且不被分割、不被中断执行的操作序列，通常可由硬件来实现。例如，上面的TestAndSet和Swap指令就是由硬件实现的原子操作。原语功能的不被中断执行特性在单处理机上可由软件通过屏蔽中断方法实现。</p>
<h2 id="3-1-整型信号量"><a href="#3-1-整型信号量" class="headerlink" title="3.1 整型信号量"></a>3.1 整型信号量</h2><p>整型信号量被定义为一个用于表示资源数目的整型量S，wait和signal操作可描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wait(S) &#123;</span><br><span class="line">	<span class="keyword">while</span> (S &lt;= <span class="number">0</span>);</span><br><span class="line">    S = S - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">signal(S) &#123;</span><br><span class="line">    S = S + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wait操作中，只要信号量S ≤ 0，就会不断地测试。因此，该机制<strong>并未遵循“让权等待”的准则</strong>，而是使进程处于“忙等”的状态。</p>
<h2 id="3-2-记录型信号量"><a href="#3-2-记录型信号量" class="headerlink" title="3.2 记录型信号量"></a>3.2 记录型信号量</h2><p>为解决忙等现象，我们再增加一个进程链表L，用于链接所有等待该资源的进程。记录型信号量得名于采用了记录型的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span></span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure>

<p>相应的wait(S)和signal(S)的操作如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(semaphore S)</span> </span>&#123;	<span class="comment">// 相当于申请资源</span></span><br><span class="line">	S.value--;	<span class="comment">// 进程请求一个该类资源</span></span><br><span class="line">    <span class="keyword">if</span>(S.value &lt; <span class="number">0</span>) &#123;	<span class="comment">// 资源已分配完毕</span></span><br><span class="line">        add <span class="keyword">this</span> process to S.L;	<span class="comment">// 将此进程加入到等待队列中</span></span><br><span class="line">        block(S.L);		<span class="comment">// 调用block原语，进行自我阻塞，放弃处理机，遵循了“让权等待”原则</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">(semaphore S)</span> </span>&#123;	<span class="comment">// 相当于释放资源</span></span><br><span class="line">    S.value++;	<span class="comment">// 使系统中可供分配的该类资源数量加一</span></span><br><span class="line">    <span class="keyword">if</span>(S.value &lt;= <span class="number">0</span>) &#123;	<span class="comment">// 加一之后value仍然小于等于0，说明S.L中仍有等待该资源的进程被阻塞</span></span><br><span class="line">        remove a process P from S.L;</span><br><span class="line">        wakeup(P); <span class="comment">// 调用wakeup原语，将S.L中的第一个等待进程唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-利用信号量实现同步"><a href="#3-3-利用信号量实现同步" class="headerlink" title="3.3 利用信号量实现同步"></a>3.3 利用信号量实现同步</h2><p>设S为实现进程P1，P2同步的公共信号量，初值为0。进程P2中的语句y要使用进程P1中语句x的运行结果，所有只有当语句x完成之后y才能执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">semaphore S = <span class="number">0</span>;	<span class="comment">// 初始化信号量</span></span><br><span class="line">P1() &#123;</span><br><span class="line">    x;				<span class="comment">// 语句x</span></span><br><span class="line">    V(S);			<span class="comment">// 告诉P2，x已经完成</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">P2() &#123;</span><br><span class="line">    ...</span><br><span class="line">    P(S);			<span class="comment">// 检查x是否完成</span></span><br><span class="line">    y;				<span class="comment">// 检查无误，执行y</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-利用信号量实现进程互斥"><a href="#3-4-利用信号量实现进程互斥" class="headerlink" title="3.4 利用信号量实现进程互斥"></a>3.4 利用信号量实现进程互斥</h2><p>设S为实现进程P1，P2互斥的信号量，由于每次只允许一个进程进入临界区，所以S的初值设为1（即可用资源数为1）.只需把临界区置于P(S)和V(S)之间，就可以实现两个进程对临界区资源的互斥访问。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semphore S = <span class="number">1</span>;			<span class="comment">// 初始化信号量</span></span><br><span class="line">P1() &#123;</span><br><span class="line">    ...</span><br><span class="line">    P(S);				<span class="comment">// 准备开始访问临界资源，加锁</span></span><br><span class="line">    进程P1的临界区;</span><br><span class="line">    V(S);				<span class="comment">// 访问结束，解锁</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">P2() &#123;</span><br><span class="line">    ...</span><br><span class="line">    P(S);				<span class="comment">// 准备开始访问临界资源，加锁</span></span><br><span class="line">    进程P2的临界区;		</span><br><span class="line">    V(S);				<span class="comment">// 访问结束，解锁</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单总结PV操作在同步互斥中的应用：在同步问题中，若某个行为要用到某种资源，则在这个行为前面P这种资源一下；若某个行为会提供某种资源，则在这个行为后面V这种资源一下（<strong>前P后V</strong>）。在互斥问题中，P，V操作要紧夹着是哦也能够互斥资源的那个行为，中间不能有其它冗余代码。</p>
<h2 id="3-5-利用信号量实现前驱关系"><a href="#3-5-利用信号量实现前驱关系" class="headerlink" title="3.5 利用信号量实现前驱关系"></a>3.5 利用信号量实现前驱关系</h2><p><img src="C:/Users/pengbin007/AppData/Roaming/Typora/typora-user-images/image-20211230152305157.png" alt="image-20211230152305157"></p>
<p>如图，S1,S2,…,S6是最简单的程序段（只有一条语句）。为使个程序段能正确执行，应设置若干初始值为“0”的信号量。例如，为保证S1→S2，S1→S3的前驱关系，应分别设置a1,a2。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">semaphore a1 = a2 = b1 = b2 = c = d = e = <span class="number">0</span>;	<span class="comment">// 初始化信号量</span></span><br><span class="line">S1() &#123;</span><br><span class="line">    ...;</span><br><span class="line">    V(a1); V(a2);	<span class="comment">// S1运行完成</span></span><br><span class="line">&#125;</span><br><span class="line">S2() &#123;</span><br><span class="line">    P(a1);			<span class="comment">// 检查S1是否完成</span></span><br><span class="line">    ...;</span><br><span class="line">    V(b1); V(b2);	<span class="comment">// S2完成</span></span><br><span class="line">&#125;</span><br><span class="line">S3() &#123;</span><br><span class="line">    P(a2);			<span class="comment">// 检查S1是否完成</span></span><br><span class="line">    ...;</span><br><span class="line">    V(c);			<span class="comment">// S3完成</span></span><br><span class="line">&#125;</span><br><span class="line">S4() &#123;</span><br><span class="line">    P(b1);			<span class="comment">// 检查S2是否完成</span></span><br><span class="line">    ...;</span><br><span class="line">    V(d);			<span class="comment">// S4完成</span></span><br><span class="line">&#125;</span><br><span class="line">S5() &#123;</span><br><span class="line">    P(b2);			<span class="comment">// 检查S2是否完成</span></span><br><span class="line">    ...;</span><br><span class="line">    V(e);			<span class="comment">// S5完成</span></span><br><span class="line">&#125;</span><br><span class="line">S6() &#123;</span><br><span class="line">    P(c);			<span class="comment">// 检查S3是否完成</span></span><br><span class="line">    P(d);			<span class="comment">// 检查S4是否完成</span></span><br><span class="line">    P(e);			<span class="comment">// 检查S5是否完成</span></span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-分析进程同步和互斥问题的方法步骤"><a href="#3-6-分析进程同步和互斥问题的方法步骤" class="headerlink" title="3.6 分析进程同步和互斥问题的方法步骤"></a>3.6 分析进程同步和互斥问题的方法步骤</h2><ol>
<li><strong>关系分析</strong>。</li>
<li><strong>整理思路</strong>。</li>
<li><strong>设置信号量</strong>。</li>
</ol>
<h1 id="4-管程"><a href="#4-管程" class="headerlink" title="4. 管程"></a>4. 管程</h1><p>在信号量机制中，每个要访问临界资源的进程都必须自备同步的PV操作，大量分散的同步操作给系统管理带来了麻烦，且容易因同步操作不当而导致死锁。于是，一种新的同步工具——管程。管程的特性保证了进程互斥，无须程序员自己实现互斥，从而降低了死锁发生的可能性。同时管程提供了条件变量，可以让程序员灵活地实现进程同步。</p>
<h2 id="4-1-管程的定义"><a href="#4-1-管程的定义" class="headerlink" title="4.1 管程的定义"></a>4.1 管程的定义</h2><h2 id="4-2-条件变量"><a href="#4-2-条件变量" class="headerlink" title="4.2 条件变量"></a>4.2 条件变量</h2><h1 id="5-经典同步问题"><a href="#5-经典同步问题" class="headerlink" title="5. 经典同步问题"></a>5. 经典同步问题</h1><h2 id="5-1-生产者-消费者问题"><a href="#5-1-生产者-消费者问题" class="headerlink" title="5.1 生产者-消费者问题"></a>5.1 生产者-消费者问题</h2><h2 id="5-2-读者-写者问题"><a href="#5-2-读者-写者问题" class="headerlink" title="5.2 读者-写者问题"></a>5.2 读者-写者问题</h2><h2 id="5-3-哲学家进餐问题"><a href="#5-3-哲学家进餐问题" class="headerlink" title="5.3 哲学家进餐问题"></a>5.3 哲学家进餐问题</h2><h2 id="5-4-吸烟者问题"><a href="#5-4-吸烟者问题" class="headerlink" title="5.4 吸烟者问题"></a>5.4 吸烟者问题</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/29/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/" data-id="ckzb6dz4x002czwtw6rsnb8ek" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2021/12/30/%E7%BB%8F%E5%85%B8IPC%E9%97%AE%E9%A2%98/" class="article-nav-link">
    <strong class="article-nav-caption">Newer</strong>
    <div class="article-nav-title">
      
      经典IPC问题
      
    </div>
  </a>
  
  
  <a href="/2021/12/25/%E4%BA%8C%E5%8D%81%E4%B8%89%E4%B8%AA%E5%AE%9E%E9%AA%8C%E5%85%A5%E9%97%A8SpringIOC-%E4%B8%8B/" class="article-nav-link">
    <strong class="article-nav-caption">Older</strong>
    <div class="article-nav-title">二十三个实验入门SpringIOC(下)</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>青稞 &copy; 2022</li>
      
        <li>ZHWANGART</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="青稞"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>





<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>