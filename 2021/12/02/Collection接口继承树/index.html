<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    Collection接口继承树 |
    
    青稞
  </title>
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="青稞" type="application/atom+xml">
</head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-Collection接口继承树" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h1 class="article-title" itemprop="name">
  Collection接口继承树
</h1>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/12/02/Collection%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E6%A0%91/" class="article-date">
  <time datetime="2021-12-02T12:50:18.000Z" itemprop="datePublished">2021-12-02</time>
</a>
      
    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211202210335782.png" alt="image-20211202210335782"></p>
<ul>
<li><p>Collection接口是List、Set和Queue接口的父接口，该接口里定义的方法既可用于操作Set集合，也可用于操作List和Queue集合。</p>
<span id="more"></span></li>
<li><p>JDK不提供此接口的任何直接实现，而是提供更具体的子接口（如：Set和List）实现。</p>
</li>
<li><p>在Java5之前，Java集合会丢失容器中所有对象的数据类型，把所有对象都当成Object类型处理；从JDK5.0增加了泛型以后，Java集合可以记住容器中对象的数据类型。</p>
</li>
</ul>
<h2 id="1-Collection接口方法"><a href="#1-Collection接口方法" class="headerlink" title="1. Collection接口方法"></a>1. Collection接口方法</h2><p>1.1 添加 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(Object obj) </span><br><span class="line">addAll(Collection coll) </span><br></pre></td></tr></table></figure>

<p>1.2 获取有效元素的个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span></span><br></pre></td></tr></table></figure>

<p>1.3 清空集合 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span></span><br></pre></td></tr></table></figure>

<p>1.4 是否是空集合 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span></span><br></pre></td></tr></table></figure>

<p>1.5 是否包含某个元素 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object obj)</span> <span class="comment">// 是通过元素的equals方法来判断是否是同一个对象 </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection c)</span> <span class="comment">// 也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较。</span></span></span><br></pre></td></tr></table></figure>

<p>1.6 删除 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object obj)</span> <span class="comment">// 通过元素的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素 </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection coll)</span> <span class="comment">// 取当前集合的差集 </span></span></span><br></pre></td></tr></table></figure>

<p>1.7 取两个集合的交集 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection c)</span> <span class="comment">// 把交集的结果存在当前集合中，不影响c </span></span></span><br></pre></td></tr></table></figure>

<p>1.8 集合是否相等 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span></span><br></pre></td></tr></table></figure>

<p>1.9 转成对象数组 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] toArray() </span><br></pre></td></tr></table></figure>

<p>1.10 获取集合对象的哈希值 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashCode() </span><br></pre></td></tr></table></figure>

<p>1.11 遍历 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iterator() <span class="comment">// 返回迭代器对象，用于集合遍历</span></span><br></pre></td></tr></table></figure>

<h2 id="2-List接口"><a href="#2-List接口" class="headerlink" title="2. List接口"></a>2. List接口</h2><blockquote>
<ul>
<li>鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组。</li>
<li>List集合类中**==元素有序、且可重复==**，集合中的每个元素都有其对应的顺序索引。</li>
<li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</li>
<li>JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。</li>
</ul>
</blockquote>
<p>List除了从Collection集合继承的方法外，List集合里添加了一些根据索引来操作集合元素的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, Object ele)</span></span>; <span class="comment">// 在index位置插入ele元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection eles)</span></span>; <span class="comment">// 从index开始将eles中的所有元素添加进来</span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">// 获取指定index的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object obj)</span></span>; <span class="comment">// 返回obj在集合中首次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object obj)</span></span>; <span class="comment">// 返回obj在当前集合中末次出现的位置</span></span><br><span class="line"><span class="function">Object <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">// 移除指定index的元素，并返回此元素</span></span><br><span class="line"><span class="function">Object <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, Object ele)</span></span>; <span class="comment">// 设置指定index的元素为ele</span></span><br><span class="line"><span class="function">List <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span>; <span class="comment">// 返回从fromIndex到toIndex的子集合</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-ArrayList"><a href="#2-1-ArrayList" class="headerlink" title="2.1. ArrayList"></a>2.1. ArrayList</h3><blockquote>
<ul>
<li>ArrayList是LIst接口的典型实现类、主要实现类。</li>
<li>本质上，ArrayList是对象引用的一个“变长”数组。</li>
<li>ArrayList的JDK1.8之前与之后的实现区别？<ul>
<li>JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组。</li>
<li>JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当要添加第一个元素时再创建一个始容量为10的数组。</li>
</ul>
</li>
<li>Arrays.asList(…)方法返回的List集合，既不是ArrayList实例，也不是Vector实例。而是一个固定长度的List集合。</li>
</ul>
</blockquote>
<p>我们可以执行下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer[] datas = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(datas);</span><br><span class="line">    list.add(<span class="number">5</span>);</span><br><span class="line">    System.out.println(list.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果是抛异常UnsupportedOperationException。查看Arrays.asList()源码发现</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211202214748103.png" alt="image-20211202214748103"></p>
<p>asList方法返回的虽然是一个ArrayList，但并不是我们平常使用的那个。而是Arrays的一个静态内部类，并且这个类实现了Serializable接口，说明它是可序列化的，正如我们所使用的String一样，是不可变的。</p>
<h3 id="2-2-LinkedList"><a href="#2-2-LinkedList" class="headerlink" title="2.2 LinkedList"></a>2.2 LinkedList</h3><blockquote>
<ul>
<li>对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高</li>
<li>新增方法：<ul>
<li>void addFirst(Object obj)</li>
<li>void addLast(Object obj)</li>
<li>Object getFirst()</li>
<li>Object getLast()</li>
<li>Object removeFirst()</li>
<li>Object removeLast()</li>
</ul>
</li>
</ul>
</blockquote>
<p>LinkedList：**==双向链表==**，内部没有声明数组，而是定义了Node类型的first和last，用于记录首末元素。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211202220345414.png" alt="image-20211202220345414">同时，定义内部类Node，作为LinkedList中保存数据的基本结构。Node除了保存数据，还定义了两个变量：</p>
<ul>
<li>prev变量记录前一个元素的位置</li>
<li>next变量记录下一个元素的位置</li>
</ul>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211202220452685.png" alt="image-20211202220452685"></p>
<h3 id="2-3-Vector"><a href="#2-3-Vector" class="headerlink" title="2.3 Vector"></a>2.3 Vector</h3><p>Vector是一个古老的集合，JDK1.0就有了（ArrayList和LinkedList都是since1.2）。大多数操作与ArrayList相同，区别之处在于==<strong>Vector是线程安全的</strong>==。</p>
<p>新增方法：</p>
<ul>
<li>void addElement(Object obj)</li>
<li>void insertElementAt(Object obj, int index)</li>
<li>void setElementAt(Object obj, int index)</li>
<li>void removeElement(Object obj)</li>
<li>void removeAllElement()</li>
</ul>
<p>在各种List中，最好把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList。Vector总是比ArrayList慢，所以尽量避免使用。</p>
<h2 id="3-Set接口"><a href="#3-Set接口" class="headerlink" title="3. Set接口"></a>3. Set接口</h2><blockquote>
<ul>
<li>Set接口是Collection的子接口，Set接口没有提供额外的方法。</li>
<li>Set集合不允许包含相同的元素，如果试着把两个相同的元素加入同一个Set集合中，则添加操作失败。</li>
<li>Set判断两个对象是否相同不是使用==运算符，而是根据equals()方法。</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211202222826445.png" alt="image-20211202222826445"></p>
<h3 id="3-1-HashSet"><a href="#3-1-HashSet" class="headerlink" title="3.1 HashSet"></a>3.1 HashSet</h3><blockquote>
<ul>
<li>HashSet是Set接口的典型实现，大多数时候使用Set集合时都使用这个实现类。</li>
<li>HashSet按Hash算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。</li>
<li>HashSet具有以下特点：<ul>
<li>不能保证元素的排列顺序</li>
<li>不是线程安全的</li>
<li>集合元素可以是null（根据不重复原则，只能有一个）</li>
</ul>
</li>
<li>HashSet集合判断两个元素相等的标准：两个对象通过hashCode()方法比较相等，并且两个对象的equals()方法返回值也相等。</li>
<li>对于存放在Set容器中的对象，对应的类一定要重写equals和hashCode方法，以实现对象相等规则。即：”**==相等的对象必须具有相等的散列码==**“。</li>
</ul>
</blockquote>
<h4 id="3-1-1-向HashSet中添加元素的过程"><a href="#3-1-1-向HashSet中添加元素的过程" class="headerlink" title="3.1.1 向HashSet中添加元素的过程"></a>3.1.1 向HashSet中添加元素的过程</h4><p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211203090912611.png" alt="image-20211203090912611"></p>
<p>对于添加成功的情况二和情况三而言：元素a与已经存在指定索引位置上数据以链表的方式存储。</p>
<p>JDK7：元素a放到数组中，指向原来的元素。</p>
<p>JDK8：原来的元素在数组中，指向元素a。</p>
<p>总结：**==七上八下==**</p>
<blockquote>
<p>注释：HashSet底层：数组 + 链表的结构（前提：JDK7）。初始容量为16，当如果使用率超过0.75，就会扩大容量为原来的2倍。</p>
</blockquote>
<h4 id="3-1-2-重写hashCode-方法的基本原则"><a href="#3-1-2-重写hashCode-方法的基本原则" class="headerlink" title="3.1.2 重写hashCode()方法的基本原则"></a>3.1.2 重写hashCode()方法的基本原则</h4><ul>
<li>在程序运行时，同一个对象多次调用hashCode方法应该返回相同的值。</li>
<li>当两个对象的equals方法比较返回true时，这两个对象的hashCode方法的返回值也应相等。</li>
<li>对象中用作equals方法比较的Field，都应该用来计算hashCode值。</li>
</ul>
<h4 id="3-1-3-重写equals-方法的基本原则"><a href="#3-1-3-重写equals-方法的基本原则" class="headerlink" title="3.1.3 重写equals()方法的基本原则"></a>3.1.3 重写equals()方法的基本原则</h4><p>以自定义的Customer类为例，何时需要重写equals？</p>
<ul>
<li>当一个类有自己特有的”逻辑相等“概念，当改写equals的时候，总是要改写hashCode，根据一个类的equals方法（改写后），两个截然不同的实例有可能在逻辑上是相等的，但是，根据Object.hashCode方法，它们仅仅是两个对象。</li>
<li>因此，违反了”**==相等的对象必须具有相等的散列码==**“。</li>
<li>结论：复写equals方法的时候一般都需要同时复写hashCode方法。<strong>通常参与计算hashCode的对象的属性也应该参与到equals中进行计算</strong>。</li>
</ul>
<h4 id="3-1-4-Eclipse-IDEA工具里hashCode的重写"><a href="#3-1-4-Eclipse-IDEA工具里hashCode的重写" class="headerlink" title="3.1.4 Eclipse/IDEA工具里hashCode的重写"></a>3.1.4 Eclipse/IDEA工具里hashCode的重写</h4><p>在自定义类中可以调用工具自动重写equals和hashCode。问题：为什么用Eclipse/IDEA复写hashCode方法，有31这个数字？</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211203092415291.png" alt="image-20211203092415291"></p>
<ul>
<li>选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的”冲突“就越少，查找起来效率也会提高。（减少冲突）</li>
<li>31只占用5bits（1 1111），相乘造成数据溢出的概率较小。</li>
<li>31可以由 <u>*i × 31 == (i &lt;&lt; 5) -1*</u> 来表示，现在很多虚拟机里面都有做相关优化。（提高算法效率）</li>
<li>31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数背身和被乘数还有1来整除！（减少冲突）</li>
</ul>
<h3 id="3-2-LinkedHashSet"><a href="#3-2-LinkedHashSet" class="headerlink" title="3.2 LinkedHashSet"></a>3.2 LinkedHashSet</h3><blockquote>
<ul>
<li>LinkedHashSet是HashSet的子类。</li>
<li>LinkedHashSet根据元素的hashCode值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以**==插入顺序==**保存的。</li>
<li><strong>LinkedHashSet插入性能略低于HashSet</strong>，但在迭代访问Set里的全部元素时有很好的性能。</li>
<li>LinkedHashSet不允许集合元素重复</li>
</ul>
</blockquote>
<h3 id="3-3-TreeSet"><a href="#3-3-TreeSet" class="headerlink" title="3.3 TreeSet"></a>3.3 TreeSet</h3><blockquote>
<ul>
<li>TreeSet是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态。</li>
<li>TreeSet底层使用<strong>红黑树</strong>结构存储数据。</li>
<li>新增的方法：<ul>
<li>Comparator comparator() </li>
<li>Object first() </li>
<li>Object last() </li>
<li>Object lower(Object e) </li>
<li>Object higher(Object e) </li>
<li>SortedSet subSet(fromElement, toElement) </li>
<li>SortedSet headSet(toElement) </li>
<li>SortedSet tailSet(fromElement)</li>
</ul>
</li>
<li>TreeSet两种排序方法：自然排序和定制排序。默认采用自然排序。</li>
<li>特点：有序，查询速度比List快。</li>
<li></li>
</ul>
</blockquote>
<h4 id="3-3-1-自然排序"><a href="#3-3-1-自然排序" class="headerlink" title="3.3.1 自然排序"></a>3.3.1 自然排序</h4><p>TreeSet会调用集合元素的compareTo(Object obj)方法来比较元素之间的大小关系，然后将集合元素按升序（默认情况）排列。</p>
<p>如果试图把一个对象添加到TreeSet时，则该对象的类必须实现Comparable接口，而实现了Comparable的类又必须实现compareTo方法，两个对象即通过compareTo方法的返回值来比较大小。</p>
<p>Comparable的典型实现：</p>
<ul>
<li>BigDecimal、BigInteger以及所有的数组型对应的包装类：按它们对应的数值大小进行比较。</li>
<li>Character：按字符的unicode值来进行比较。</li>
<li>Boolean：true对应的包装类实例大于false对应的包装类实例。</li>
<li>String：按字符串中字符的unicode值进行比较。</li>
<li>Date、Time：后边的时间、日期比前面的大。</li>
</ul>
<blockquote>
<ul>
<li>向TreeSet中添加元素时，只有第一个元素无须比较compareTo方法，后面添加的所有元素都会调用compareTo方法进行比较。</li>
<li>因为只有相同类的两个实例才会比较大小，所以向TreeSet中添加的应该是同一个类的对象。</li>
<li>对于TreeSet集合而言，它判断两个对象是否相等的唯一标准是：两个对象通过compareTo方法比较返回值。</li>
<li>当需要把一个对象放入TreeSet中，重写该对象对应的equals方法时，应保证该方法与compareTo方法有一致的结果；如果两个对象通过equals方法比较返回true，则通过compareTo方法比较应返回0.否则，让人难以理解。</li>
</ul>
</blockquote>
<h4 id="3-3-2-定制排序"><a href="#3-3-2-定制排序" class="headerlink" title="3.3.2 定制排序"></a>3.3.2 定制排序</h4><p>TreeSet的自然排序要求元素所属的类实现Comparable接口，如果元素所属的类没有实现Comparable即可，或不希望按照升序的方式排列元素或希望按照其它属性大小进行排序，则考虑使用定制排序。定制排序，通过Comparator接口来实现，需要重写compare(T o1, T o2)方法。</p>
<p>利用int compare(T o1, T o2)方法，比较o1和o2大小，返回正整数，表示o1大；0表示相等；负整数表示o2大。</p>
<p>要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。此时，仍然只能向TreeSet中添加类型相同的对象。否则发生ClassCastException异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Comparator comparator = (o1, o2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Customer &amp;&amp; o2 <span class="keyword">instanceof</span>  Customer) &#123;</span><br><span class="line">            Customer u1 = (Customer) o1;</span><br><span class="line">            Customer u2 = (Customer) o2;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(u1.getAge(), u2.getAge());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入类型不匹配！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    TreeSet treeSet = <span class="keyword">new</span> TreeSet(comparator);</span><br><span class="line">    treeSet.add(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/02/Collection%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E6%A0%91/" data-id="ckwp0kyzs0000qctwadxke4zz" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E9%9B%86%E5%90%88/" rel="tag">Java集合</a></li></ul>

    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2021/12/02/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-nav-link">
    <strong class="article-nav-caption">Newer</strong>
    <div class="article-nav-title">
      
      集合面试题
      
    </div>
  </a>
  
  
  <a href="/2021/12/02/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/" class="article-nav-link">
    <strong class="article-nav-caption">Older</strong>
    <div class="article-nav-title">Java集合框架概述</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>青稞 &copy; 2021</li>
      
        <li>ZHWANGART</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="青稞"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>





<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>