<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    初见设计模式 |
    
    青稞
  </title>
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="青稞" type="application/atom+xml">
</head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-初见设计模式" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h1 class="article-title" itemprop="name">
  初见设计模式
</h1>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/12/09/%E5%88%9D%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2021-12-09T00:32:00.000Z" itemprop="datePublished">2021-12-09</time>
</a>
      
    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>设计模式最初是在建筑学中被提出的，建筑师克里斯托弗·亚历山大在1970年代编撰了一本汇集设计模式的书，但是设计模式的思想在建筑设计领域里的影响远没有后来在软件开发领域里传播的广泛和深远。</p>
<p>软件设计中的设计模式是在GoF（”四人帮“，指Gamma、Helm、Johnson &amp; Vlissides、Addison-Wesley四人）合著的《设计模式》一书中第一次提出的，随后被规范化。</p>
<h2 id="1-为什么要使用"><a href="#1-为什么要使用" class="headerlink" title="1. 为什么要使用"></a>1. 为什么要使用</h2><p>设计模式优点如下：</p>
<ul>
<li><strong>复用解决方案</strong></li>
<li><strong>设计模式将设计方法标准化</strong></li>
<li><strong>设计模式可以提高个人和团队的设计能力</strong></li>
<li><strong>设计模式使软件更容易修改和维护</strong></li>
</ul>
<h2 id="2-设计模式分类"><a href="#2-设计模式分类" class="headerlink" title="2. 设计模式分类"></a>2. 设计模式分类</h2><ul>
<li>创建型模式：用于创建对象。对象的创建会消耗掉系统的很多资源，所以单独对对象的创建进行研究，以便能够高效地创建对象就是创建型模式要探讨的问题。</li>
<li>结构型模式：用于构建类间的关系。如何设计对象的结构、继承和依赖关系会影响到后续程序的维护性，代码的健壮性、耦合性等。这些因素需要使用结构型模式来优化。</li>
<li>行为型模式：用于控制对象的行为。如果对象的行为设计的号，那么对象的行为就会更清晰，它们之间的协作效率就会更高。</li>
</ul>
<p>具体分类见下23种：</p>
<blockquote>
<ul>
<li>创建型模式<ul>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
<li>建造者模式</li>
<li>原型模式</li>
<li>单例模式</li>
</ul>
</li>
<li>结构型模式<ul>
<li>适配器模式</li>
<li>桥接模式</li>
<li>代理模式</li>
<li>外观模式</li>
<li>装饰模式</li>
<li>组合模式</li>
<li>享元模式</li>
</ul>
</li>
<li>行为型模式<ul>
<li>命令模式</li>
<li>观察者模式</li>
<li>责任链模式</li>
<li>迭代器模式</li>
<li>访问者模式</li>
<li>状态模式</li>
<li>备忘录模式</li>
<li>策略模式</li>
<li>调停者模式</li>
<li>模板方法模式</li>
<li>解释器模式</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="3-七大原则"><a href="#3-七大原则" class="headerlink" title="3. 七大原则"></a>3. 七大原则</h2><p>设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础。</p>
<h3 id="3-1-单一职责原则"><a href="#3-1-单一职责原则" class="headerlink" title="3.1 单一职责原则"></a>3.1 单一职责原则</h3><p>对类来说，即一个类应该只负责一项职责。如：类A负责两个不同职责1和2，当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1和A2。</p>
<p>注意事项和细节：</p>
<ul>
<li>降低类的复杂度，一个类只负责一项职责。</li>
<li>提高类的可读性，可维护性。</li>
<li>降低变更引起的风险。</li>
<li>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则。</li>
</ul>
<h3 id="3-2-接口隔离原则"><a href="#3-2-接口隔离原则" class="headerlink" title="3.2 接口隔离原则"></a>3.2 接口隔离原则</h3><p>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。</p>
<h3 id="3-3-依赖倒转原则"><a href="#3-3-依赖倒转原则" class="headerlink" title="3.3 依赖倒转原则"></a>3.3 依赖倒转原则</h3><ol>
<li>高层模块不应该依赖低层模块，二者都应该依赖其抽象。</li>
<li>抽象不应该依赖细节，细节应该依赖抽象。</li>
<li>依赖倒转的中心思想是面向接口编程。</li>
<li>依赖倒转原则的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在Java中，抽象是指接口或抽象类，细节就是具体的实现类。</li>
<li>使用接口或抽象类的目的是指定好规范，而不涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。</li>
</ol>
<p>依赖关系传递方式：</p>
<ul>
<li>接口传递</li>
<li>构造方法传递</li>
<li>setter方式传递</li>
</ul>
<p>注意事项和细节：</p>
<ul>
<li>低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好。</li>
<li>变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化。</li>
<li>继承时遵循里氏替换原则。</li>
</ul>
<h3 id="3-4-里氏替换原则"><a href="#3-4-里氏替换原则" class="headerlink" title="3.4 里氏替换原则"></a>3.4 里氏替换原则</h3><h4 id="3-4-1-OO中的继承性的思考和说明"><a href="#3-4-1-OO中的继承性的思考和说明" class="headerlink" title="3.4.1 OO中的继承性的思考和说明"></a>3.4.1 OO中的继承性的思考和说明</h4><ul>
<li>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</li>
<li>继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其它的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障。</li>
</ul>
<p>而在编程中，为了正确的使用继承，我们需要用到里氏替换原则。</p>
<h4 id="3-4-2-基本介绍"><a href="#3-4-2-基本介绍" class="headerlink" title="3.4.2 基本介绍"></a>3.4.2 基本介绍</h4><p>里氏替换原则在1988年，由麻省理工学院的一位姓里的女士提出的。</p>
<p>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。<strong>换句话说，所有引用基类的地方必须能透明地使用其子类的对象。</strong></p>
<p>在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。</p>
<p>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。</p>
<h3 id="3-5-开闭原则"><a href="#3-5-开闭原则" class="headerlink" title="3.5 开闭原则"></a>3.5 开闭原则</h3><p>开闭原则是编程中最基础、最重要的设计原则。一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。用抽象构建框架，用实现扩展细节。这样，当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p>
<p>我们在编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</p>
<h3 id="3-6-迪米特法则"><a href="#3-6-迪米特法则" class="headerlink" title="3.6 迪米特法则"></a>3.6 迪米特法则</h3><p>一个对象应该对其它对象保持最少的了解，但是，类与类关系越密切，耦合度越大。迪米特法则又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法，不对外泄露任何信息。迪米特法则还有个更简单的定义：只与直接的朋友通信。</p>
<p>所谓的直接的朋友就是：每个对象都会与其它对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称<strong>出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接朋友</strong>。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</p>
<p>迪米特法则的核心是降低类之间的耦合，但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系，并不是要求完全没有依赖关系。</p>
<h3 id="3-7-合成复用原则"><a href="#3-7-合成复用原则" class="headerlink" title="3.7 合成复用原则"></a>3.7 合成复用原则</h3><p>原则是尽量使用合成/聚合的方式，而不是使用继承。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/09/%E5%88%9D%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-id="ckx2yjv9i0005pgtwdem9cujy" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2021/12/09/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9F%BA%E7%A1%80/" class="article-nav-link">
    <strong class="article-nav-caption">Newer</strong>
    <div class="article-nav-title">
      
      Java内存模型的基础
      
    </div>
  </a>
  
  
  <a href="/2021/12/08/%E7%B3%BB%E7%BB%9F%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%B9%8B%E2%80%94%E2%80%94%E6%97%A5%E5%BF%97/" class="article-nav-link">
    <strong class="article-nav-caption">Older</strong>
    <div class="article-nav-title">系统错误处理机制之——日志</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>青稞 &copy; 2022</li>
      
        <li>ZHWANGART</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="青稞"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>





<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>