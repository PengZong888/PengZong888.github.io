<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    页面置换算法 |
    
    青稞
  </title>
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="青稞" type="application/atom+xml">
</head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-页面置换算法" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h1 class="article-title" itemprop="name">
  页面置换算法
</h1>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/12/11/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2021-12-11T11:27:40.000Z" itemprop="datePublished">2021-12-11</time>
</a>
      
    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>当发生缺页中断时，操作系统必须在内存中选择一个页面将其换出内存，以便为即将调入的页面腾出空间。如果要换出的页面在内存驻留期间已经被修改过，就必须把它写回磁盘以更新该页面在磁盘上的副本，如果没有，则不需要回写（磁盘上的副本就是最新的）。直接用调入的页面覆盖被淘汰的页面就可以了。</p>
<p>缺页中断发生时，虽然可以随机选择一个页面进行置换，但是如果我们每次选择的都是不常使用的页面可以提升系统性能（不用回写，并且能避免其在短时间内又被置换回来）。”页面置换“问题在计算机设计的其它领域中也同样发生。例如，多数计算机把最近使用过的32字节或64字节的存储块保存在一个或多个告诉缓存中。另外一个例子是Web服务器。服务器可以把经常访问的一些Web页面存放在存储器的高速缓存中。</p>
<h2 id="1-最优页面置换算法（OPT，Optimal）"><a href="#1-最优页面置换算法（OPT，Optimal）" class="headerlink" title="1. 最优页面置换算法（OPT，Optimal）"></a>1. 最优页面置换算法（OPT，Optimal）</h2><p>很容易就可以描述出最好的页面置换算法，虽然<strong>此算法不可能实现</strong>。该算法是这样工作的：在缺页中断发生时，有些页面在内存中，其中有一个页面将很快被访问，其它页面则可能要到10、100或1000条指令后才会被访问，每个页面都可以用在该页面首次被访问前所要执行的指令数作为标记。</p>
<p>最优页面置换算法规定应该置换标记最大的页面。如果一个页面在800万条指令内不会被使用，另外一个600万条，则置换前一个页面，从而把因需要调入这个页面而发生的缺页中断推迟到将来，越久越好。计算机也像人一样，希望把不愉快的事情尽可能往后拖延。</p>
<p>这个算法唯一的问题就是无法实现。当缺页中断发生时，<strong>OS无法知道各个页面下一次将在什么时候被访问</strong>。当然，通过首先在仿真程序上运行程序，跟踪所有页面的访问情况，然后在第二次运行时利用第一次收集的信息是可以实现的。<strong>用这种方式，可以通过最优页面置换算法对其它可实现算法的性能进行比较</strong>。如果OS达到的页面置换性能只比最优算法差1%，那么即使花费大量的精力来寻找更好的算法最多也只能换来1%的性能提高。</p>
<p>假定系统为某进程分配了三个物理块，并考虑有页面号引用串7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1。那么采用OPT算法时的情况如下表：</p>
<table>
<thead>
<tr>
<th align="center">访问页面</th>
<th>7</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>0</th>
<th>3</th>
<th>0</th>
<th>4</th>
<th>2</th>
<th>3</th>
<th>0</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>2</th>
<th>0</th>
<th>1</th>
<th>7</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td align="center">物理块1</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>2</td>
<td></td>
<td>2</td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td>7</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">物理块2</td>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td></td>
<td>0</td>
<td></td>
<td>4</td>
<td></td>
<td></td>
<td>0</td>
<td></td>
<td></td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">物理块3</td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
<td></td>
<td>3</td>
<td></td>
<td>3</td>
<td></td>
<td></td>
<td>3</td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">缺页否</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>缺页率：45%</p>
<h2 id="2-最近未使用页面置换算法（NRU，Not-Recently-Used）"><a href="#2-最近未使用页面置换算法（NRU，Not-Recently-Used）" class="headerlink" title="2. 最近未使用页面置换算法（NRU，Not Recently Used）"></a>2. 最近未使用页面置换算法（NRU，Not Recently Used）</h2><p>为了让OS能够收集有用的统计信息，在大部分具有虚拟内存的计算机中，系统为每一页面设置了两个状态位。当页面被访问（读或写）时设置R位；当页面被写入（即修改）时设置M位。这些位包含在页表项中，每次访问内存时更新这些位，因此由硬件来设置这些位是必要的。</p>
<p>如果硬件没有这些位，可以用OS的缺页中断和时钟中断机制进行以下的模拟：当启动一个进程时，将其所有的页面都标记为不在内存中；一旦访问任何一个页面都会引发一次缺页中断，此时OS就可以设置R位，修改页表项使其指向正确的页面，并设为READ ONLY模式。然后重新启动引起缺页中断的指令；如果随后对该页面的修改又引起了缺页中断，则OS设置这个页面的M位，并将其改为READ/WRITE模式。</p>
<p>可以用R位和M位来构造一个简单的页面置换算法：当启动一个进程时，它的所有页面的两个位都由OS设为0，R位被定期清零（比如在每次时钟中断时），以区别最近没有被访问的页面和被访问的页面。</p>
<p>当发生缺页中断时，OS检查所有的页面并根据它们当前的R位和M位的值，将它们分成以下四类：</p>
<ul>
<li>第0类：没有被访问，没有被修改</li>
<li>第1类：没有被访问，已经被修改</li>
<li>第2类：已经被访问，没有被修改</li>
<li>第3类：已经被访问，已经被修改</li>
</ul>
<p>尽管第1类看起来似乎不可能，但是一个第3类的页面在它的R位被时钟中断清零后就成了第1位。时钟中断不清零M位是因为在决定一个页面是否要写回磁盘需要用到这个位。</p>
<p>NRU算法随机地从类编号最小的非空类中挑选一个页面淘汰。这个算法隐含的意思是，在最近一个时钟滴答中淘汰一个没有被访问的已修改页面要比淘汰一个被频繁使用的”干净“页面好。NRU的主要优点是易于理解和能够有效地被实现，虽然它的性能不是最好的，但是已经够用了。</p>
<h2 id="3-先进先出页面置换算法（FIFO）"><a href="#3-先进先出页面置换算法（FIFO）" class="headerlink" title="3. 先进先出页面置换算法（FIFO）"></a>3. 先进先出页面置换算法（FIFO）</h2><p>由OS维护一个所有当前在内存中的页面的链表，最新进入的页面放在表尾，最早的放在表头。当发生缺页中断时，淘汰表头的页面并把新调入的页面加到表尾。</p>
<table>
<thead>
<tr>
<th align="center">访问页面</th>
<th>7</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>0</th>
<th>3</th>
<th>0</th>
<th>4</th>
<th>2</th>
<th>3</th>
<th>0</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>2</th>
<th>0</th>
<th>1</th>
<th>7</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td align="center">物理块1</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>2</td>
<td></td>
<td>2</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>0</td>
<td></td>
<td></td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
<td>7</td>
<td>7</td>
<td>7</td>
</tr>
<tr>
<td align="center">物理块2</td>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td></td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td align="center">物理块3</td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
<td></td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>3</td>
<td></td>
<td></td>
<td>3</td>
<td>2</td>
<td></td>
<td></td>
<td>2</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td align="center">缺页否</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<p>缺页率：75%</p>
<h2 id="4-第二次机会页面置换算法"><a href="#4-第二次机会页面置换算法" class="headerlink" title="4. 第二次机会页面置换算法"></a>4. 第二次机会页面置换算法</h2><p>FIFO算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：检查最老页面的R位。如果R位是0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是1，就将R位清零，并把该页面放到链表尾端，然后继续搜索。这就是第二次机会算法。</p>
<p>第二次机会算法就是寻找一个在最近的时钟间隔内没有被访问过的页面。如果所有的页面都被访问过了，该算法就简化为纯粹的FIFO算法。</p>
<h2 id="5-时钟页面置换算法（CLOCK）"><a href="#5-时钟页面置换算法（CLOCK）" class="headerlink" title="5.时钟页面置换算法（CLOCK）"></a>5.时钟页面置换算法（CLOCK）</h2><p>尽管第二次机会算法是一个比较合理的算法，但它经常要在链表中移动页面，既降低了效率又不是很有必要。一个更好的办法是<strong>把所有的页面都保存在一个类似钟面的环形链表中</strong>，一个表针指向最老的页面。当发生缺页中断时，算法首先检查表针指向的页面，如果它的R为是0就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；如果是1就清除R为并把表针前移一个位置。重复这个过程知道找到了一个R位为0的页面为止。这就是时钟算法。</p>
<h2 id="6-最近最少使用页面置换算法（LRU）"><a href="#6-最近最少使用页面置换算法（LRU）" class="headerlink" title="6.最近最少使用页面置换算法（LRU）"></a>6.最近最少使用页面置换算法（LRU）</h2><p>对最优算法的一个很好的近似是基于这样的观察：在前面几条指令中频繁使用的页面很可能在后面的几条指令中被使用。反过来说，已经很久没有使用的页面很有可能在未来较长一段时间内仍然不会被使用。这一思想提示了一个可实现的算法：<strong>在缺页中断时，置换未使用时间最长的页面</strong>。这一策略称为LRU（Least Recently Used）页面置换算法。</p>
<p>虽然LRU在理论上可以实现，但代价很高。为了完全实现LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的在表尾。困难的是在每次访问内存时都必须更新整个链表。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常耗时的操作，即使使用硬件实现也一样费时（假设有这样的硬件）。</p>
<table>
<thead>
<tr>
<th align="center">访问页面</th>
<th>7</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>0</th>
<th>3</th>
<th>0</th>
<th>4</th>
<th>2</th>
<th>3</th>
<th>0</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>2</th>
<th>0</th>
<th>1</th>
<th>7</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td align="center">物理块1</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>2</td>
<td></td>
<td>2</td>
<td></td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>0</td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td>1</td>
<td></td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">物理块2</td>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td></td>
<td>0</td>
<td></td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>3</td>
<td></td>
<td></td>
<td>3</td>
<td></td>
<td>0</td>
<td></td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">物理块3</td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
<td></td>
<td>3</td>
<td></td>
<td>3</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td>2</td>
<td></td>
<td>7</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">缺页否</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>缺页率：60%</p>
<p>还是有一些使用特殊硬件实现LRU的方法。首先考虑一个最简单的方法，这个方法要求硬件有一个64位计数器C，它在每条指令执行完后自动加1，每个页表项必须有一个足够容纳这个计数器值的域。在每次访问内存后，将当前的C值保存到被访问页面的页表项中。一旦发生缺页中断，OS就检查所有页表项中计数器的值，找到值最小的一个页面，这个页面就是最近最少使用的页面。</p>
<h2 id="7-用软件模拟LRU"><a href="#7-用软件模拟LRU" class="headerlink" title="7. 用软件模拟LRU"></a>7. 用软件模拟LRU</h2><p>LRU算法在理论上可以实现的，但是在实际操作中的硬件很难实现。因此，我们希望能用一种软件的方式来实现，这就是<strong>NFU（Not Frequently Used，最不常用）算法。该算法将每一个页面与一个初值为0的软件计数器相关联，每次时钟中断时，由OS扫描内存中所有页面，将每个页面的R位加到它的计数器上。这个计数器大体上跟踪了每个页面被访问的频繁程度。发生缺页中断时，则置换计数器值最小的页面</strong>。</p>
<p>NFU的主要问题是它从来不忘记任何事情。比如，在一个多次(扫描)编译器中，第一次被频繁使用的页面在程序进入第二次扫描的时候，其计数器的值可能依旧很高。实际上，如果第一次扫描的执行时间恰好是各次扫描中最长的，含有以后各次扫描代码的页面的计数器可能总是比含有第一次扫描代码的页面的计数器小，结果是OS将置换有用的页面而不是不再使用的页面。</p>
<p>幸运的是只要最一点修改就能很好的模拟LRU。其修改分为两部分：首先，在R位被加进之前先将计数器右移一位，其次；将R位加到计数器最左端而不是最右端。修改以后的<strong>老化（aging）算法</strong>，下图解释了它是如何工作的。假设在第一个时钟滴答后，页面0~5的R位的值分别是1、0、1、0、1、1。换句话说，在时钟滴答0到时钟滴答1之间，访问了页0、2、4、5，它们的R位设置为1，而其他的设为0。对应的6个计数器右移并把R位插入左端后的值如图(a)所示。</p>
<p><img src="C:/Users/pengbin007/AppData/Roaming/Typora/typora-user-images/image-20211212002429361.png" alt="image-20211212002429361"></p>
<p>发生缺页中断时，将置换计数器值最小的页面。如果一个页面在前面4个时钟滴答中都没有访问过，那么它的计数器最前面应该有4个连续的0，因此它的值肯定要比在前面三个时钟滴答中都没有被访问过的页面的计数器小。</p>
<p>该算法与LRU由两个区别。如图e中的页面3和5，它们都连续两个时钟滴答没有被访问过了，而在这两个时钟滴答之前都被访问过了。根据LRU，如果必须置换一个页面，则应该二选一。但是，我们不知道在时钟滴答1到时钟滴答2期间它们中的哪个页面是后被访问到的。因为在每个时钟滴答中只记录了一位，所以无法区分在一个时钟滴答中哪个页面在较早的时间被访问哪个较晚，因此，我们所能做的就是置换页面3，原因是页面5在更往前的两个时钟滴答中也被访问过而3没有。</p>
<p>LRU和老化算法的第二个区别是老化算法的计数器只有有限位数（本例中是8位），这就限制了其对以往页面的记录。如果两个页面的计数器都是0，我们只能在两个页面中随机选一个进行置换。实际上，有可能其中一个页面上次被访问是在9个时钟滴答以前，另一个页面是在1000个时钟滴答以前，而我们却无法看到这些。在实践中，如果时钟滴答是20ms，8位一般是够用的。加入一个页面已经有160ms没有被访问过，那么它可能并不重要。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/11/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/" data-id="ckx2yjv9k000cpgtw5r2dez30" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2021/12/12/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-%E4%B8%8B/" class="article-nav-link">
    <strong class="article-nav-caption">Newer</strong>
    <div class="article-nav-title">
      
      页面置换算法(下)
      
    </div>
  </a>
  
  
  <a href="/2021/12/11/%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C%E5%8E%9F%E7%90%86/" class="article-nav-link">
    <strong class="article-nav-caption">Older</strong>
    <div class="article-nav-title">指令级并行原理</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>青稞 &copy; 2022</li>
      
        <li>ZHWANGART</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="青稞"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>





<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>