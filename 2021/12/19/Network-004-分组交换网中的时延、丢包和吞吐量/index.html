<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    分组交换网中的时延、丢包和吞吐量 |
    
    青稞
  </title>
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="青稞" type="application/atom+xml">
</head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-Network-004-分组交换网中的时延、丢包和吞吐量" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h1 class="article-title" itemprop="name">
  分组交换网中的时延、丢包和吞吐量
</h1>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/12/19/Network-004-%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E7%BD%91%E4%B8%AD%E7%9A%84%E6%97%B6%E5%BB%B6%E3%80%81%E4%B8%A2%E5%8C%85%E5%92%8C%E5%90%9E%E5%90%90%E9%87%8F/" class="article-date">
  <time datetime="2021-12-19T08:44:20.000Z" itemprop="datePublished">2021-12-19</time>
</a>
      
    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>在理想情况下，我们希望因特网服务能够在任意两个端系统之间瞬间移动我们想要的大量数据而没有任何数据丢失。然而，这是一个极高的目标，实践中难以达到。与之相反，计算机网络必定要限制在端系统之间的吞吐量，在端系统之间引入时延，而且实际上能够丢失分组。</p>
<h2 id="1、-分组交换网中的时延概述"><a href="#1、-分组交换网中的时延概述" class="headerlink" title="1、 分组交换网中的时延概述"></a>1、 分组交换网中的时延概述</h2><p>分组从一台主机出发，通过一系列路由器传输，在另一台主机中结束它的历程。当分组从一个结点沿着这条路径到后继结点，该分组在沿途的每个结点经受了几种不同类型的时延。这些时延最为重要的是<strong>结点处理时延（nodal processing delay）、排队时延（queuing delay）、传输时延（transmission delay）和传播时延（propagation delay）</strong>，这些时延总体累加起来就是<strong>结点总时延（total nodal delay）。</strong></p>
<h3 id="1-1-时延的类型"><a href="#1-1-时延的类型" class="headerlink" title="1.1 时延的类型"></a>1.1 时延的类型</h3><p>如图，作为源和目的地之间的端到端路径的一部分，一个分组从上游结点通过路由器A向路由器B发送。路由器A具有通往路由器B的出链路，该链路前面有一个队列（也称为缓存）。当该分组从上游结点到达路由器A时，路由器A检查该分组的首部以决定该分组的适当出链路，并将该分组导向该链路。</p>
<p><img src="https://gitee.com/pengzong888/imageSource/raw/master/img/2022/2/image-20220223090355077.png" alt="image-20220223090355077"></p>
<h4 id="1-处理时延"><a href="#1-处理时延" class="headerlink" title="1. 处理时延"></a>1. 处理时延</h4><p>检查分组首部和决定将该分组导向何处所需要的时间是处理时延的一部分。处理时延也能包括其它因素，如检查比特级别的差错所需要的时间。高速路由器的处理时延通常是微秒或更低的数量级。</p>
<h4 id="2-排队时延"><a href="#2-排队时延" class="headerlink" title="2. 排队时延"></a>2. 排队时延</h4><p>在队列中，当分组在链路上等待传输时，它经受排队时延。一个特定分组的排队时延长度将取决于先期到达的正在排队等待向链路传输的分组数量。实际的排队时延可以是毫秒到微秒量级。</p>
<h4 id="3-传输时延"><a href="#3-传输时延" class="headerlink" title="3.传输时延"></a>3.传输时延</h4><p>将所有分组的比特推向(传输)链路所需要的时间。实际的排队时延可以是毫秒到微秒量级。</p>
<h4 id="4-传播时延"><a href="#4-传播时延" class="headerlink" title="4.传播时延"></a>4.传播时延</h4><p>一旦一个比特被推向链路，该比特需要向路由器B传播。从该链路的起点到路由器B传播所需要的时间是传播时延。该比特以该链路的传播速率传播，传播速率取决于该链路的物理媒体。该传播时延等于两台路由器之间的距离除以传播速率。在广域网中，传播时延为毫秒量级。</p>
<h4 id="5-传输时延和传播时延的比较"><a href="#5-传输时延和传播时延的比较" class="headerlink" title="5. 传输时延和传播时延的比较"></a>5. 传输时延和传播时延的比较</h4><p>传输时延是路由器将分组推出所需要的时间，它是分组长度和链路传输速率的函数，而与两台路由器之间的距离无关。另一方面，传播时延是一个比特从一台路由器向另一台路由器传播所需要的时间，它是两台路由器之间距离的函数，而与分组长度或链路传输速率无关。</p>
<p>举个例子，假设在高速上每隔100km有一个收费站。在这里，可以认为收费站间的公路段就是链路，而收费站则是路由器。假设汽车以100km/h的速度行驶(即传播)。假定这是有10辆汽车的车队在行驶，并且这10辆汽车以固定的顺序互相跟随。可以认为每辆汽车是一个比特，该车队是一个分组。同时假定每个收费站以每辆车12s的速度服务(即传输)一辆汽车，由于时间是深夜，因此该车队是公路上唯一一批汽车。最后，假定无论该车队的第一辆汽车何时到达收费站，它在入口处等待，直到其它9辆汽车到达并整队依次前行(因此，整个车队在它能够“转发”之前，必须存储在收费站)。</p>
<p>在这里，收费站将整个车队推向公路所需时间是2min，该事件就类比于一台路由器中的传输时延。而一辆汽车从一个收费站出口行驶到下一个收费站所需时间1h，这个时间类比于传播时延。</p>
<h2 id="2、排队时延和丢包"><a href="#2、排队时延和丢包" class="headerlink" title="2、排队时延和丢包"></a>2、排队时延和丢包</h2><p>结点时延中最为复杂和有趣的成分是排队时延，与其他3项时延不同的是，排队时延对不同的分组可能是不同的(多个分组同时到达队列，先传输的分组排队时延自然就小，后传输的自然就更大)。因此，当表征排队时延时，人们通常使用统计量测度，如平均排队时延、排队时延的方差和排队时延超过某些特定值的频率。</p>
<p>假定所有分组都是由L比特组成的，a表示分组到达队列的平均速率(a的单位是分组/秒，即pkt/s)，R表示传输速率(以bps即b/s为单位)。那么比特到达队列的平均速率就是La bps。最后，假定该队列非常大，因此它基本能容纳无限数量的比特。比率La/R被称为<strong>流量强度</strong>。如果La/R &gt; 1，则比特到达队列的平均速率超过从该队列传输出去的速率。在这种不幸的情况下，该队列趋向于无界增加，并且排队时延将趋向无穷大！因此，流量工程中的一条金科玉律是：<em><strong>设计系统时流量强度不能大于1</strong></em>.</p>
<h3 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h3><p>在上述讨论中，我们假设队列能够容纳无穷多的分组，在现实中，一条链路前的队列只有有限的容量。而因为该排队容量时有限的，随着流量强度接近1，排队时延并不实际趋向无穷大。相反，到达的分组将发现一个满的队列。由于没有地方存储这个分组，路由器将<strong>丢失</strong>(drop)该分组，即该分组将会<strong>丢失</strong>(lost)。</p>
<p>从端系统的角度看，上述丢包现象看起来是一个分组已经传输到网络核心，但它绝不会从网络发送到目的地。分组丢失的份额随着流量强度的增加而增加。因此，一个结点的性能常常不仅根据时延来衡量，而且根据分组丢失的概率来度量。</p>
<h2 id="3、端到端时延"><a href="#3、端到端时延" class="headerlink" title="3、端到端时延"></a>3、端到端时延</h2><p>前面讨论的是单台路由器上的时延，现在考虑从源到目的地的总时延。假设源主机和目的主机之间有N - 1台路由器，网络无拥塞(因此排队时延微不足道)。此时端到端时延就是：N * (在每台路由器和源主机上的处理时延 + 分组长度 / 每台路由器和源主机的输出速率 + 每条链路的传播时延)。</p>
<h3 id="3-1-Traceroute"><a href="#3-1-Traceroute" class="headerlink" title="3.1 Traceroute"></a>3.1 Traceroute</h3><p><a target="_blank" rel="noopener" href="http://www.traceroute.org/">www.traceroute.org</a></p>
<h3 id="3-2-端系统、应用程序和其它时延"><a href="#3-2-端系统、应用程序和其它时延" class="headerlink" title="3.2 端系统、应用程序和其它时延"></a>3.2 端系统、应用程序和其它时延</h3><p>除了处理时延、传输时延和传播时延，端系统还有其它一些重要时延。例如，作为它的协议的一部分，希望向共享媒体传输分组的端系统可以有意地延迟它的传输以与其它端系统共享媒体。另一个重要的时延是媒体分组化时延。</p>
<h2 id="4、计算机网络中的吞吐量"><a href="#4、计算机网络中的吞吐量" class="headerlink" title="4、计算机网络中的吞吐量"></a>4、计算机网络中的吞吐量</h2><p>除了时延和丢包，计算机网络中另一个必不可少的性能测度是端到端吞吐量。我们考虑一个场景，从主机A到主机B跨越计算机网络发送一个大文件。在任何时间瞬间的瞬时吞吐量(instantaneous throughput)是主机B接收到该文件的速率(以bps计)。如果该文件由F比特组件，主机B接收到所有F比特用去T秒，则文件传送的平均吞吐量(average throughput)是F/T bps。</p>
<p>当没有其它干扰流量时，其吞吐量能够近似为沿着源和目的地之间路径的最小传输速率。如果许多其它的数据流通过同一条链路流动，那么即使这是一条高传输速率的链路，仍然可能成为文件传输的瓶颈链路。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/19/Network-004-%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E7%BD%91%E4%B8%AD%E7%9A%84%E6%97%B6%E5%BB%B6%E3%80%81%E4%B8%A2%E5%8C%85%E5%92%8C%E5%90%9E%E5%90%90%E9%87%8F/" data-id="ckzwc414i0011gotwhaf6ghu8" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2021/12/19/Network-009-Web%E5%92%8CHTTP/" class="article-nav-link">
    <strong class="article-nav-caption">Newer</strong>
    <div class="article-nav-title">
      
      Web和HTTP
      
    </div>
  </a>
  
  
  <a href="/2021/12/18/SpringSecurity-Web%E6%9D%83%E9%99%90%E6%96%B9%E6%A1%88-%E4%B8%8A/" class="article-nav-link">
    <strong class="article-nav-caption">Older</strong>
    <div class="article-nav-title">SpringSecurity Web权限方案(上)</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>青稞 &copy; 2022</li>
      
        <li>ZHWANGART</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="青稞"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>





<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>