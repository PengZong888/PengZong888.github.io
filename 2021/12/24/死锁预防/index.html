<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    死锁预防 |
    
    青稞
  </title>
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="青稞" type="application/atom+xml">
</head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-死锁预防" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h1 class="article-title" itemprop="name">
  死锁预防
</h1>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/12/24/%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2/" class="article-date">
  <time datetime="2021-12-23T19:41:46.000Z" itemprop="datePublished">2021-12-24</time>
</a>
      
    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>死锁避免从本质上来说是不可能的，因为它需要获知未来的请求，而这些请求是不可知的。</p>
<h1 id="1-破坏互斥条件"><a href="#1-破坏互斥条件" class="headerlink" title="1. 破坏互斥条件"></a>1. 破坏互斥条件</h1><p>如果资源不被一个进程所独占，那么死锁肯定不会产生。当然，允许两个进程同时使用打印机会造成混乱，通过采用假脱机打印机技术可以允许若干个进程同时产生输出。该模型中唯一真正请求使用物理打印机的进程是打印机守护进程，由于守护进程绝不会请求别的资源，所以不会因打印机而产生死锁。</p>
<p>假设守护进程被设计成在所有输出进入假脱机之前就开始打印。我们考虑这样一个情况，如果一个输出进程在头一轮打印之后决定等待几个小时，打印机就可能空闲。为了避免这一现象，一般将守护进程设计成在完整的输出文件就绪后才开始打印。</p>
<h1 id="2-破坏占有和等待条件"><a href="#2-破坏占有和等待条件" class="headerlink" title="2. 破坏占有和等待条件"></a>2. 破坏占有和等待条件</h1><p>只要禁止已持有资源的进程再等待其它资源便可以消除死锁。一种实现方法是规定所有进程在开始执行前请求所需的全部资源。如果所需的全部资源可用，那么就将它分配给这个进程，于是该进程肯定能够运行结束。反之，则不分配，进程等待。</p>
<p>这种方法的一个直接问题是很多进程直到运行时才知道它需要多少资源。实际上，如果进程能够知道它需要多少资源，就可以使用银行家算法了。另一个问题是这种方法的资源利用率不是最优的。例如，有一个进程先从输入磁带上读取数据，进行一小时的分析，最后会写到输出磁带上，同时会在绘图仪上绘出。如果所有资源都必须提前请求，这个进程就会把输出磁带机和绘图仪控制住一小时。</p>
<p>另一种破坏占有和等待条件的方案是，要求当一个进程请求资源时，先暂时释放当前占有的所有资源，然后再尝试一次获取所需的全部资源。</p>
<h1 id="3-破坏不可抢占条件"><a href="#3-破坏不可抢占条件" class="headerlink" title="3. 破坏不可抢占条件"></a>3. 破坏不可抢占条件</h1><p>假设一个进程已经分配到一台打印机，且正在进行打印输出，如果由于它需要的绘图仪无法获得而强制性把它占有的打印机抢占掉，就会引起一片混乱。但是，一些资源可以通过虚拟化的方式来避免发生这样的情况。</p>
<p>假脱机打印机向磁盘输出，并且只允许打印机守护进程访问真正的物理打印机，这种方式可以消除涉及打印机的死锁，然而却可能带来由磁盘空间导致的死锁。但是对于大容量磁盘，要消耗完所有的磁盘空间一般是不可能的。</p>
<p>但是，并不是所有的资源都可以进行类似的虚拟化。例如，数据库中的记录或者操作系统中的表都必须被锁定，因此存在出现死锁的可能。</p>
<h1 id="4-破坏环路等待条件"><a href="#4-破坏环路等待条件" class="headerlink" title="4. 破坏环路等待条件"></a>4. 破坏环路等待条件</h1><p>消除环路等待有几种方法。一种是保证每一个进程在任何时刻只能占用一个资源，如果要请求另外一个资源，它必须先释放第一个资源。</p>
<p>另一种是将所有资源统一编号，如图。现在的规则是：进程可以在任何时刻提出资源请求，但是所有请求必须按照资源编号顺序（升序）提出。进程可以先请求打印机后请求磁带机，但不可以先请求绘图仪再请求打印机。</p>
<p><img src="https://raw.githubusercontent.com/PengZong888/tuchuang/main/img/image-20211224065357041.png" alt="image-20211224065357041"></p>
<p>若按此规则，资源分配图中肯定不会出现环。右图所示，只有在A请求资源j且B请求i的情况下会产生死锁。假设i和j是不同资源，它们会具有不同编号。若i&gt;j，那么A不允许请求j，因为这个编号小于A已有资源的编号；反之，则B不允许请求i。不论哪种情况都不可能产生死锁。</p>
<p>对于多于两个进程的情况，同样的逻辑依然成立。<strong>在任何时刻，总有一个已分配的资源是编号最高的</strong>。占用该资源的进程不可能请求其它已分配的各种资源。它或者会执行完毕，或者最坏的情形是去请求编号更高的资源，而编号更高的资源肯定是可用的。最终，它会结束并释放所有资源，这是其它占有最高编号资源的进程也可以执行完。简言之，存在一种所有进程都可以执行完毕的场景，所以不会产生死锁。</p>
<p>该算法的一个变种是摈弃必须按升序请求资源的限制，而仅仅要求不允许进程请求比当前所独占资源编号低的资源。</p>
<p>尽管对资源编号的方法消除了死锁的问题，但几乎找不出一种使每个人都满意的编号次序。当资源包括进程表项、假脱机磁盘空间、加锁的数据库记录及其它抽象资源时，潜在的资源及各种不同用途的数目会变得很大，以至于使编号根本无法使用。</p>
<h1 id="5-死锁预防总结"><a href="#5-死锁预防总结" class="headerlink" title="5. 死锁预防总结"></a>5. 死锁预防总结</h1><table>
<thead>
<tr>
<th>条件</th>
<th>处理方式</th>
</tr>
</thead>
<tbody><tr>
<td>互斥</td>
<td>一切都是用假脱机技术</td>
</tr>
<tr>
<td>占有和等待</td>
<td>在开始就请求全部资源</td>
</tr>
<tr>
<td>不可抢占</td>
<td>抢占资源</td>
</tr>
<tr>
<td>环路等待</td>
<td>对资源按序编号</td>
</tr>
</tbody></table>
<h1 id="6-和死锁相关的问题"><a href="#6-和死锁相关的问题" class="headerlink" title="6. 和死锁相关的问题"></a>6. 和死锁相关的问题</h1><h2 id="6-1-两阶段加锁"><a href="#6-1-两阶段加锁" class="headerlink" title="6.1 两阶段加锁"></a>6.1 两阶段加锁</h2><p>虽然在一般情况下避免死锁和预防死锁并不是很有希望，但是在一些特殊的应用方面，有很多卓越的专用算法。例如，在很多数据库系统中，一个经常发生的操作是请求锁住一些记录，然后更新所有锁住的记录。当同时有多个进程运行时，就会有死锁的危险。</p>
<p>常用的方法是两阶段加锁。在第一阶段，进程试图对所有所需的记录进行加锁，一次锁一个记录。如果第一阶段加锁成功，就开始第二阶段，完成更新然后释放锁。在第一阶段并没有做实际的工作。</p>
<h2 id="6-2-通信死锁"><a href="#6-2-通信死锁" class="headerlink" title="6.2 通信死锁"></a>6.2 通信死锁</h2><h2 id="6-3-活锁"><a href="#6-3-活锁" class="headerlink" title="6.3 活锁"></a>6.3 活锁</h2><h2 id="6-4-饥饿"><a href="#6-4-饥饿" class="headerlink" title="6.4 饥饿"></a>6.4 饥饿</h2><p>与死锁和活锁非常相似的一个问题是饥饿（starvation）。在动态运行的系统中，在任何时刻都可能请求资源。这就需要一些策略来决定在什么时候谁获得什么资源。虽然这个策略表面上很有道理，但依然有可能使一些进程永远得不到服务，虽然它们并不是死锁进程。</p>
<p>饥饿可以通过先来先服务资源分配策略来避免。在这种机制下，等待最久的进程会是下一个被调度的进程。随着时间的推移，所有进程都会变成最“老”的，因而，最终能够获得资源而完成。</p>
<h1 id="7-死锁小结"><a href="#7-死锁小结" class="headerlink" title="7. 死锁小结"></a>7. 死锁小结</h1><p>死锁是任何OS的潜在问题。在一组进程中，每个进程都因等待由该组进程中的另一进程所占有的资源而导致阻塞，死锁就发生了。这种情况会使所有的进程都处于无限等待的状态。一般来讲，这是进程一直等待被其他进程占用的某些资源释放的事件。死锁的另外一种可能的情况是一组通信进程都在等待一个消息，而通信信道却是空的，并且也没有采用超时机制。</p>
<p>通过跟踪哪一个状态是安全状态，哪一个状态是不安全状态，可以避免死锁。安全状态就是这样一个状态：存在一个事件序列，保证所有的进程都能完成。不安全状态就不存在这样的保证。银行家算法可以通过拒绝可能引起不安全状态的请求来避免死锁。</p>
<p>也可以在设计系统时就不允许死锁发生，从而在系统结构上预防死锁的发生。例如，只允许进程在任何时刻最多占有一个资源，这就破坏了循环等待环路。也可以将所有资源编号，规定进程按严格的升序请求资源，这样也能预防死锁。</p>
<p>资源死锁并不是唯一的一种死锁。尽管我们可以通过设置适当的超时机制来解决通信死锁，但它依然是某些系统中潜在的问题。</p>
<p>活锁和死锁的问题有些相似，那就是它也可以停止所有的转发进程，但是二者在技术上不同，由于活锁包含了一些实际上并没有锁住的进程，因此可以通过先来先服务的分配策略来避免饥饿。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/24/%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2/" data-id="ckzb6dz4k0020zwtwc6wo111m" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2021/12/25/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/" class="article-nav-link">
    <strong class="article-nav-caption">Newer</strong>
    <div class="article-nav-title">
      
      内存管理概念
      
    </div>
  </a>
  
  
  <a href="/2021/12/23/%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D%EF%BC%88%E5%90%AB%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%EF%BC%89/" class="article-nav-link">
    <strong class="article-nav-caption">Older</strong>
    <div class="article-nav-title">死锁避免（含银行家算法）</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>青稞 &copy; 2022</li>
      
        <li>ZHWANGART</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="青稞"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>





<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>